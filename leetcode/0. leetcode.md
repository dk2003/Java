# leetcode

* 用户名：`rain-2m`
* 密码：`dqcyz20081103`

---

## 常见术语

* AC

AC是“Accept”的缩写，意味着程序通过了所有的测试用例，得到了题目的所有分数。这通常出现在编程比赛的语境中，如ACM竞赛，表示参赛者的程序完全正确地解决了给定的问题。

* AK

AK则是“All Killed”的缩写，是一种信息学竞赛用语。具体来说，在信息学竞赛（如IOI、NOI、NOIP、ACM等）中，如果一个参赛者获得了满分，即AC了所有题目，那么就可以说他AK了某个比赛。

## 刷题八极拳: 坑爹用例全出来 双分单哈滑递动

### 第1拳：坑爹用例全出来

- 最重要的一拳， 你要是少考虑了一种情况，整个算法函数就偏了，折腾半天就白耍了。卡在中间用例，或者死循环上，真噎人！即便你想到了后面的7拳，还是白耍！事实上差不多有一半的题目，它故意在例子上误导你，让你简单化算法，然后就偏了。
- 用例，用例！第一拳打在用例上，我觉得考虑全了，面试官，你看还漏不漏？

### 后7拳：双分单哈滑递动

- 绝大多数题目都是`1000`条数据以上，这就意味着你的算法效率必须低于`O(n*n)`, 要不会超时。想运行的快速，`O(n)`级的算法都给套一遍：
- 双指针：一快一慢，两端往中间走，中间往两端走，行不行吧？
- 二分：排个序，单侧加倍二分，双侧二分，中间往两边分，有没有答案？
- 单调栈：双侧单调栈刷一刷
- 哈希集合：万能的字典集合，不用白不用
- 滑动窗口：左滑一下，右滑一下，可能就过去了
- 递归：无论多少条数据，都可以万物归一递归下去，你就考虑一条的时候怎么整
- 动态规划：证明证明，状态转移，我要做数学推拿

面对新题目，你不可能很快想到思路，就给他耍一套八级拳，可以框住绝大多数中高难度的题目了。耍不出来的话，再耍一遍，一定是变形的题目，拳是对的，发错位置打空气了，找面试官确认哪一拳打空了？！！

## 链表题

### 三板斧：哑巴节点，栈（递归），快慢指针

链表解题经典三板斧，哑巴节点，栈（递归），快慢指针，回溯。哑巴节点一般是为了处理头尾节点用的，因为这边逻辑有区别，有时候会让代码变得比较长。但其实用指针+边界判断也行。这题因为逻辑简单，其实不用哑巴节点，直接用指针也行。 栈的话这题意义不大，你入栈一次不也就拿到长度了。而且对链表，pop意义不大。官方还创建了两次节点，我寻思用指针就可以了，官方这个内存消耗估计不低。 至于快慢指针，虽然少了一次常量遍历，但每次操作要操作两个指针，也快不了多少。总之就是为了解题而解题吧。但是这几个方法确实都是链表解题利器。面试的时候用上，基本题目都难不倒，跑起来不说，至少思路可以掰扯出来。

* 哑巴节点

> 在链表算法中，哑巴节点（dummy node）是一个特殊的节点，通常被添加到链表的开始位置，用于简化链表操作或解决某些特定问题。
>
> 哑巴节点的引入主要有以下几个好处：
>
> 1. 简化操作：当我们在链表的头部进行插入或删除操作时，哑节点的存在可以避免对头部节点进行特殊处理，从而简化代码逻辑。
> 2. 避免边界条件：在链表的某些操作中，哑节点可以帮助我们避免处理头节点为空的边界问题，减少代码执行异常的可能性。
> 3. 提供统一的操作接口：无论链表是否为空，哑节点都可以作为链表的头节点进行操作，这使得我们可以为链表提供统一的操作接口。
>
> 在实际应用中，哑节点的声明和使用方式可能会因具体需求和实现方式而有所不同。但总的来说，哑节点是一种有效的数据结构优化手段，可以提高代码的可读性和可维护性。

* 递归/栈

> 1. 显式地直接使用栈来解决问题
> 2. 利用递归隐式地使用栈的特性，因为递归实际上也是利用了栈
>
> 例如：题`19`

### 翻转绝技：头插 & 尾插

> 头插法和尾插法确实可以用于翻转链表，但它们各自有不同的特点和适用场景。
>
> 头插法是一种将新节点插入到链表头部的操作。在翻转链表的上下文中，可以使用头插法来逐个将链表中的节点插入到新链表的头部，从而实现链表的翻转。具体做法是，遍历原链表，对于每个节点，将其从原链表中移除，并插入到新链表的头部。通过这种方式，原链表的头节点会成为新链表的尾节点，原链表的尾节点会成为新链表的头节点，从而实现链表的翻转。
>
> 尾插法是一种将新节点插入到链表尾部的操作。虽然尾插法也可以用于翻转链表，但相比于头插法，它的实现方式更为复杂。使用尾插法翻转链表时，需要维护一个指向新链表尾部的指针，然后遍历原链表，对于每个节点，将其插入到新链表的尾部，并更新尾部指针。这种方式虽然可以实现链表的翻转，但相比于头插法，它需要更多的指针操作和内存管理，因此实现起来更为复杂。
>
> 总的来说，头插法和尾插法都可以用于翻转链表，但头插法相对更为简单和直观。在实际应用中，可以根据具体需求和场景选择合适的方法。

## 经典思想

### 反证法

算法种要证明是最优解或者不是最优解等问题时，一般会用到反证法。在贪心和动态规划问题中用的比较多

### logN

想要优化成`logN`的复杂度，不一定非要显式地写出二分法。

类似于分治法写快速幂，将问题拆成两个相同的子问题，也可以产生`logN`的复杂度

我们还可以将操作数每次翻倍地来逼近，最后处理一下逼近边界，也可以产生`logn`的复杂度，如题 `29`，解法`2`



二分法的一个注意点：

```py
mid=(left+right)//2
# 为了防止left+right溢出，求mid常常用另外一种做法
mid=left + (right-left)>>1
# 下面的方法使用了减法和移位进行配合
```



### 递归——数学归纳法

<font color='red'>递归实际上隐式利用了栈的特性，因此用递归写出来的算法一般都可以使用栈来非递归解决；使用栈解决的问题部分可以用递归来解决</font>

<font color='red'>递归虽然简单，但是由于函数调用栈的存在，一般会产生额外的空间复杂度。</font>

我以前也是这样的，只在乎时间复杂度。但当我被面试管问到：“空间复杂度还可以更优吗？”这个问题时，我才幡然醒悟，原来很多时候，做题是需要两方面考虑的。

递归的时间复杂度和遍历是一样的，但是递归的时间复杂度最少是O(n)，本质上，和“放到数组里面，然后获取第n个”的方法的没有任何区别。

若你未达到需要考虑生计的水平，我建议你从现在开始关注空间复杂度，这样未来面试管问你的时候你还能写出这些问题的遍历解法。

再说说为什么递归的空间复杂度是O(n)（n代表递归次数）：

需要知道方法的执行其实本质上是一个栈，一个方法对应一个栈帧，每个方法的内容保存在栈帧中。调用方法时创建栈帧放入栈中，结束时弹出栈。

所以，每递归一次，都需要创建一个栈帧。在方法中每创建一个变量，也会在栈帧中开辟一个空间。这就导致了每递归一次都会开辟一次，所以空间复杂度为O(n)。

但是额外的，假如每个方法设计的变量很少，也许比使用数据结构更加简单一些。

再说说额外的：为什么要刷题，练习算法。

我是做后端的，不会太去涉及算法的一个职业，但是仍然需要刷题，学算法。算法代表了一个程序员的代码实现能力，而这个实现能力在于——面对一个需求如何使用已知接口来实现。所以任何的算法实现，不是要看你的代码是否可读性高，刷题没人会看你这个，只会看你的思考是否灵活，思维角度是否全面。

#### 空间复杂度

取决于递归树的高度，而不是递归树的节点个数

> 递归的空间复杂度通常取决于递归的层数，而不是递归的次数。这是因为递归的空间复杂度主要涉及到递归过程中所需的栈空间大小。每次递归调用都会在函数调用栈上创建一个新的栈帧，用于存储局部变量、参数和返回地址等信息。当递归调用返回时，相应的栈帧才会被销毁。
>
> 递归的层数指的是递归调用的深度，即函数调用栈中栈帧的数量。递归层数越大，所需的栈空间也就越大，因此空间复杂度也就越高。相反，递归的次数可能很大，但如果递归的层数很小（例如，通过尾递归优化等方法），则所需的栈空间可能并不会很大。
>
> 因此，在评估递归算法的空间复杂度时，我们应该重点关注递归的层数，而不是递归的次数。

### 哈希表——查找利器

> 哈希表在算法中的常见作用主要包括：
>
> 1. **快速查找**：主要用于代替遍历查找，哈希表通过哈希函数将键映射到数组中的位置，从而实现数据的快速查找。无论数据规模如何，哈希表的查找时间复杂度都能保持为O(1)，即查找时间与数据量的大小无关。这种特性使得哈希表在需要频繁查找的场景中非常实用，如字典、数据库索引、缓存等。
> 2. **避免重复**：哈希表的一个重要特点是它不允许存储重复的数据。当向哈希表中插入数据时，会先通过哈希函数计算键的哈希值，然后检查该哈希值对应的位置是否已经有数据。如果有，则说明数据重复；如果没有，则将数据插入到该位置。这种特性使得哈希表在需要避免数据重复的场景中非常有用，如统计频率、检查元素是否出现过等。
> 3. **映射关系**：哈希表可以建立键与值之间的映射关系。通过键可以快速查找到对应的值，这种映射关系在很多算法中都有应用，如哈希表可以映射字符、字符串、数字的数量，也可以映射数字的下标等。
>
> 需要注意的是，虽然哈希表具有很多优点，但它也有一些缺点，如基于数组实现，当数组被基本填满时，性能会下降得非常严重。此外，哈希表的实现也需要考虑到哈希函数的设计、冲突处理等因素。

### 动态规划——从部分到全局

> 动态规划主要解决了一类具有<font color='red'>重叠子问题</font>和<font color='red'>最优子结构特性</font>的最优化问题。这类问题通常可以分解为<font color='red'>若干个相关联的子问题</font>，每个子问题的解可以被用来构建更大问题的解。
>
> 1. <a href='#dp1'>**重叠子问题**</a>：在动态规划问题中，子问题会被<font color='red'>重复求解多次</font>。为了避免重复计算，动态规划会将每个<font color='red'>子问题的解保存</font>下来，以便在需要时直接查找，而不是重新计算。这种特性使得动态规划在处理大规模问题时非常有效。
> 2. <a href='#dp2'>**最优子结构**</a>：在动态规划问题中，问题的最优解可以通过其子问题的最优解来构建。这意味着，如果我们能找到所有子问题的最优解，那么我们就可以利用这些最优解来构建出原问题的最优解。
>
> 通过利用这两个特性，动态规划可以在很大程度上提高算法的效率。常见的动态规划问题包括背包问题、最短路径问题、序列比对、矩阵链乘法等。
>
> 需要注意的是，虽然动态规划可以解决很多问题，但它并不适用于所有类型的问题。对于某些问题，使用其他算法可能会更加高效。因此，在选择算法时，需要根据问题的特性和需求来进行合理的选择。

### 双指针——破解多次循环

双指针实际上还是相当于遍历了两遍

> 和动态规划相同，<a href='#doublestick'>双指针</a>都可以记录之前的状态。
>
> 但是有些问题可以只需要用到最近一个子问题的结果而不需要之前所有子问题的结果，为了节约空间复杂度，我们常常使用双指针来代替`dp`数组，只记录上一次的结果

### 备忘录——记录子问题

> 在算法中，<a href='#dp1'>“备忘录”也称为“记忆化”或“记忆化搜索”</a>，是一种优化技术，用于避免递归算法中相同子问题的重复求解。当算法遇到已经解决过的子问题时，它可以从“备忘录”中快速检索答案，而不是重新计算。这样可以显著提高算法的效率，特别是在处理大规模或复杂问题时。
>
> 具体来说，备忘录法为每个解过的子问题建立一个记录项（通常是一个数组或哈希表），并将计算结果保存在其中。在需要求解相同子问题时，算法首先检查备忘录中是否已经有该子问题的解。如果有，则直接使用存储的结果；如果没有，则进行计算并将结果保存到备忘录中，以备将来使用。
>
> 备忘录法的实现通常涉及自顶向下的递归过程。在递归过程中，每次遇到一个子问题时，算法都会检查备忘录中是否已有该子问题的解。这种方法的实质是以空间换取时间，通过保存中间结果来避免重复计算。因此，在数据量较大时，使用备忘录法可以显著提高算法的性能。
>
> 需要注意的是，备忘录法并不适用于所有类型的递归问题。它主要适用于那些具有重叠子问题的情况，即相同子问题在算法中被多次求解。在这种情况下，使用备忘录法可以有效地减少重复计算并提高算法效率。

### 分治算法——快速/归并排序等

>分治算法（`Divide and Conquer Algorithm`）是一种很重要的算法。它的基本思想是将一个规模为N的问题分解为`K`个规模较小的子问题，这些子问题相互独立且与原问题性质相同。然后递归地解这些子问题，并将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。
>
>分治算法的核心思想是将难以直接解决的大问题分割成一些规模较小的相同问题，以便各个击破，分而治之。这种策略在很多情况下都非常有效，因为它可以通过将问题分解为更小、更易于处理的子问题来简化问题的复杂性。
>
>分治算法通常具有以下特点：
>
>1. 将大问题分解为小问题：分治算法首先将大问题分解为若干个相同或相似的小问题，这些小问题的规模和复杂度都比原问题小。
>2. 递归求解小问题：然后，分治算法递归地求解这些小问题。通常，这些小问题的求解过程与原问题的求解过程类似，只是规模更小。
>3. 合并小问题的解：最后，分治算法将各个小问题的解合并起来，得到原问题的解。合并的方式取决于问题的具体性质。
>
>分治算法在很多领域都有广泛的应用，如排序、图论、动态规划等。<font color='red'>一些著名的分治算法包括快速排序、归并排序、分治FFT等。</font>

### 排序——破解 O(n^3/4) & 去重复解

>使用时间复杂度为：`O(nlogn)`的排序算法将一个数组排序，原来需要`O(n^3)`的时间来解决问题，排序之后的时间复杂度变为了`O(n^2)`。
>
>同时排序还有利于解决去重问题，还可以使用`HashSet`进行去重

#### 快速排序

> 快速排序之所以名字中有“快速”两个字，主要是因为它在平均情况下的性能非常出色。快速排序的基本思想是选择一个基准元素，将数组分为两部分，其中一部分的元素都比基准元素小，另一部分的元素都比基准元素大，然后对这两部分递归地进行快速排序。
>
> 在平均情况下，快速排序的时间复杂度可以达到O(n log n)，其中n是待排序数组的长度。这是因为每次递归划分时，数组都可以被大致均等地分成两部分，从而使得递归树的深度较小，递归次数也较少。因此，快速排序在平均情况下的性能非常优秀，这也是它被称为“快速”的原因。
>
> 然而，快速排序的最坏时间复杂度是O(n^2)，这发生在输入数组已经有序或逆序的情况下。在这种情况下，每次划分时，基准元素都会将数组分成一个空数组和一个包含n-1个元素的数组，导致递归树的深度达到n，从而产生了大量的递归调用和比较操作。
>
> 虽然快速排序在最坏情况下的性能不如归并排序和堆排序，但归并排序和堆排序在平均情况下的性能也不如快速排序。归并排序的时间复杂度始终是O(n log n)，但其空间复杂度较高，因为需要额外的空间来合并两个有序子数组。堆排序虽然也能达到O(n log n)的时间复杂度，但其实现相对复杂，且在处理小数据集时可能不如快速排序高效。
>
> 因此，在选择排序算法时，需要根据具体的应用场景和需求来权衡各种因素。快速排序因其优秀的平均性能而在许多场合下被广泛使用，尽管它在最坏情况下的性能可能不如其他排序算法。

### 回溯——秒杀排列组合

<font color='red'>**当前路径不行回退选择其他路径**</font>

>回溯算法（`backtracking`）是一种系统地搜索问题解答的方法，也被称为试探法。其核心思想是在通过遍历所有路径的基础上，通过回溯（往回找）筛除不可能的路径，以提高效率。
>
>回溯算法的实现离不开【递归】
>
>以下是回溯算法的一般实现步骤：
>
>1. 定义问题的解空间：解空间应包含问题的所有可能解。
>2. 组织解空间：为了有效地搜索解空间，需要以一种适合搜索的方式组织它。这通常是通过图（如迷宫问题）或树（如N皇后问题）的形式来实现的。
>3. <font color='red'>深度优先搜索</font>：从解空间的根节点开始，按照深度优先的策略进行搜索。这意味着在搜索过程中，会尽可能深地搜索树的分支，直到达到叶子节点或发现当前路径不可能得到解为止。<font color='red'>DFS本身就是一次递归+一次回溯的过程</font>
>4. 剪枝：在搜索过程中，使用约束函数或限界函数来避免移动到不可能产生解的子空间。这可以大大减少搜索的空间，提高效率。
>5. <font color='red'>回溯：如果在某一步发现当前选择并不优或达不到目标，就退回一步重新选择</font>。这就是所谓的“回溯”。回溯到上一层后，会撤销当前决策，然后尝试其他分支。
>6. 重复以上步骤，直到找到问题的解或确定不存在解为止。
>
>请注意，回溯算法的一个有趣特性是，在搜索执行的同时产生解空间。在搜索期间的任何时刻，仅保留从开始节点到当前节点的路径。这使得回溯算法在解决某些问题时非常有效，如组合优化问题、排列问题、迷宫问题、数独等。
>
>以上是对回溯算法的基本解释和实现步骤。具体的实现方式会根据问题的特性和需求有所不同。

> 回溯算法是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解的话（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化来丢弃该解，即"回溯"。以下是编写回溯算法的一些要点：
>
> 1. **定义问题的可能解空间**：这是回溯算法的基础，需要定义出问题的可能解空间，通常这可以通过递归或迭代的方式来实现。
> 2. **搜索策略**：确定搜索策略，即如何遍历解空间。常见的搜索策略有深度优先搜索（DFS）和广度优先搜索（BFS）。
> 3. **约束条件**：定义问题的约束条件，即什么样的解是有效的。在搜索过程中，如果发现当前解违反了约束条件，就需要回溯到上一步，尝试其他的可能性。
> 4. **剪枝**：在搜索过程中，通过剪枝来减少搜索空间，提高效率。剪枝的策略需要根据具体问题的特点来设计。
> 5. **记录解**：当找到一个有效的解时，需要将其记录下来。通常可以使用一个列表或集合来保存所有的解。
> 6. **递归与循环**：回溯算法通常需要使用递归或循环来实现。递归的方式更直观，但可能会消耗更多的内存；循环的方式更节省内存，但实现起来可能更复杂。
> 7. **回溯**：当发现当前解不满足约束条件时，需要回溯到上一步，尝试其他的可能性。回溯的过程需要小心处理，避免重复搜索或漏掉某些解。
>
> 在编写回溯算法时，需要注意以下几点：
>
> - **理解问题**：首先，需要深入理解问题的特点和要求，明确问题的解空间和约束条件。
> - **设计搜索策略**：根据问题的特点，设计合适的搜索策略，确保能够遍历所有的解空间。
> - **编写清晰的代码**：回溯算法通常比较复杂，需要编写清晰的代码来确保算法的正确性。
> - **调试与测试**：在编写完算法后，需要进行充分的调试和测试，确保算法的正确性和效率。
>
> 最后，需要注意的是，回溯算法并不总是最高效的解决方案。对于某些问题，其他类型的算法（如动态规划、分治法等）可能更加适合。因此，在选择算法时，需要根据问题的特点来综合考虑。

### 剪枝——优化回溯算法

例如题`18`

>剪枝是算法优化中的一种技巧，主要用于搜索算法，如深度优先搜索（DFS）和广度优先搜索（BFS）。在搜索过程中，剪枝通过某种判断，避免一些不必要的遍历过程，从而优化搜索效率。具体来说，剪枝就是根据一定的规则，将搜索树中的某些“枝条”剪掉，从而减少搜索空间，提高搜索效率。
>
>剪枝的关键在于剪枝的判断：什么枝该剪、在什么地方剪。不同的剪枝策略有不同的应用场景和判断规则。例如，可行性剪枝是在当前状态和题意不符时，直接返回，不再继续搜索；最优性剪枝是在搜索过程中，如果当前花费的代价已超过前面搜索到的最优解，那么本次搜索已经没有继续进行下去的意义，此时停止对当前分支的搜索进行回溯；排除等效冗余是在搜索过程中，当几个枝桠具有完全相同的效果时，只选择其中一个进行搜索，从而避免重复搜索；顺序剪枝则是根据一定的顺序进行搜索，避免重复搜索和无效搜索。
>
>总的来说，剪枝是一种有效的搜索算法优化手段，可以显著提高搜索效率，减少搜索时间和空间复杂度。因此，在学习算法和与算法打交道的工作中，剪枝是一个非常重要的知识点。

### 极限`K`选`1`——log(K)

#### 败者树

> 败者树（`Loser Tree`）主要用于外部排序中的k路归并排序，其中`k`表示归并的路数。败者树可以高效地实现k个有序序列中的最小（或最大）元素的选取，时间复杂度为`O(log k)`。
>
> 具体来说，败者树是一种完全二叉树，每个节点存储的是其子树中败者的信息。在`k`路归并排序中，每个叶子节点通常对应一个有序序列的头部元素，内部节点则存储其子树中败者的信息。这样，通过遍历败者树，可以在`O(log k)`的时间复杂度内找到k个有序序列中的最小（或最大）元素。
>
> 败者树的构建和维护过程相对复杂，但在k路归并排序中，败者树的主要作用是快速选取最小（或最大）元素，其时间复杂度为`O(log k)`。这是因为败者树的高度是`O(log k)`，每次从根节点开始遍历到叶子节点，可以在对数时间内找到最小（或最大）元素。
>
> 需要注意的是，败者树在外部排序中的应用主要是为了解决磁盘`I/O`操作成为瓶颈的问题。通过增大归并的路数`k`，可以减少磁盘`I/O`操作的次数，提高排序效率。而败者树作为一种高效的数据结构，可以在k路归并排序中发挥重要作用。

`Python`标准库中并没有直接提供败者树（`Loser Tree`）的实现。败者树是一种特殊的数据结构，通常用于外部排序中的多路归并场景，以高效地找出多个有序序列中的最小（或最大）元素。

由于败者树并不是通用的数据结构，因此在`Python`中并没有现成的接口可以直接使用。如果你需要在`Python`中实现败者树来解决`k`选`1`的问题，你需要自己编写败者树的代码。

下面是一个简单的败者树的`Python`实现示例，用于解决k选1问题：

```python
class LoserTree:  
    def __init__(self, k):  
        self.k = k  
        self.tree = [None] * (2 * k - 1)  
        self.sequences = [None] * k  
  
    def initialize(self, sequences):  
        self.sequences = sequences  
        for i in range(self.k):  
            self.tree[self.k + i] = i  
  
        for i in range(self.k - 1, 0, -1):  
            self.update(i)  
  
    def update(self, index):  
        left = 2 * index  
        right = left + 1  
        winner = index  
  
        if left < self.k and (self.sequences[self.tree[left]] < self.sequences[self.tree[winner]]):  
            winner = left  
  
        if right < self.k and (self.sequences[self.tree[right]] < self.sequences[self.tree[winner]]):  
            winner = right  
  
        if winner != index:  
            self.tree[index], self.tree[winner] = self.tree[winner], self.tree[index]  
            self.update(winner)  
  
    def find_min(self):  
        return self.sequences[self.tree[0]]  
  
# 示例用法  
k = 5  
sequences = [  
    [3, 7, 9],  # 第1个有序序列  
    [1, 4, 5],  # 第2个有序序列  
    [2, 6, 8],  # 第3个有序序列  
    [0, 99],    # 第4个有序序列（只有一个元素）  
    [5, 55]     # 第5个有序序列（只有一个元素）  
]  
  
# 创建败者树并初始化  
loser_tree = LoserTree(k)  
loser_tree.initialize(sequences)  
  
# 查找k个有序序列中的最小值  
min_value = loser_tree.find_min()  
print(f"The minimum value among the {k} sequences is: {min_value}")
```

在这个示例中，`LoserTree` 类实现了败者树的基本功能。`initialize` 方法用于初始化败者树，`update` 方法用于在插入新序列或序列更新时维护败者树的结构，`find_min` 方法用于查找当前败者树中的最小值。

请注意，这个示例仅用于演示败者树的基本概念，并没有考虑一些边界情况和优化。在实际应用中，你可能需要根据具体需求对败者树的实现进行调整和优化。

#### 优先队列

> 优先队列（`Priority Queue`）是一种抽象数据类型，它类似于常规队列或栈，但每个元素都有一定的优先级。在优先队列中，元素的出队顺序不仅取决于它们进入队列的顺序，还取决于它们的优先级。优先级最高的元素最先出队。
>
> 优先队列可以通过多种数据结构来实现，例如数组、链表、堆等。下面简要介绍几种常见的实现方式：
>
> 1. **数组实现**：
>    在数组中，可以通过维护一个索引数组来记录元素在数组中的位置，以便快速访问和删除。插入时，将元素添加到数组的末尾，并更新索引数组。删除时，根据优先级找到最小/最大元素的位置，将其与数组末尾的元素交换，并更新索引数组，然后删除末尾元素。
> 2. **链表实现**：
>    链表实现优先队列通常不是很高效，因为需要遍历链表来找到最小/最大元素。插入时，将元素添加到链表的头部或尾部。删除时，遍历链表找到最小/最大元素并删除。
> 3. **堆实现**（特别是二叉堆）：
>    堆是一种完全二叉树，它满足堆性质：父节点的值不大于（或不小于）其子节点的值。二叉堆是优先队列最常见的实现方式之一，因为它可以在对数时间内完成插入和删除操作。在二叉堆中，最小元素（或最大元素）总是位于堆的根节点。插入时，将新元素添加到堆的末尾，并上滤（或下滤）以保持堆的性质。删除时，将根节点与堆的最后一个元素交换，然后删除最后一个元素，并对根节点进行下滤。
> 4. **斐波那契堆实现**：
>    斐波那契堆是一种特殊的堆结构，它用于解决合并多个优先队列的问题。斐波那契堆由一组最小堆组成，每个最小堆都是一个满足最小堆性质的二叉树。斐波那契堆通过合并和删除操作来维护堆的性质，并在这些操作中保持较好的性能。
>
> 实现优先队列时，通常需要考虑以下几个方面：
>
> - 如何快速比较元素的优先级？
> - 如何高效地插入和删除元素？
> - 如何维护队列的优先级顺序？
>
> 根据具体的应用场景和需求，可以选择合适的数据结构和算法来实现优先队列。

> 优先队列和败者树不是同一个东西，但它们都是用于处理数据排序和选择的数据结构，它们之间有一些联系和区别。
>
> 联系：
>
> 1. 目标相似：优先队列和败者树都是为了解决在大量数据中找到最优（最大或最小）元素的问题，以提高算法效率。
> 2. 应用场景重叠：在某些特定场景下，如外部排序，优先队列和败者树都可以被用来减少比较次数，提高排序效率。
>
> 区别：
>
> 1. 数据结构不同：优先队列是一种队列，它强调元素出队的优先级，每次出队的是优先级最高的元素。而败者树是一种树形选择排序的变种，它是一种完全二叉树，每个节点存储的是左右子树中的败者信息。
> 2. 操作方式不同：优先队列通常通过插入和删除操作来维护队列的优先级，它可以在插入新元素时进行排序，保证每次出队的是最大或最小元素。而败者树则通过比较左右子树中的元素，记录败者信息，从而快速找到最小或最大元素。
> 3. 应用场景不同：优先队列广泛应用于需要快速获取最大或最小元素的场景，如电脑进程调度、Android系统中的优先级调度等。而败者树则主要用于外部排序中的多路归并，以减少内部排序的比较次数。
>
> 总的来说，优先队列和败者树都是为了解决在大量数据中找到最优元素的问题而设计的数据结构，它们在某些应用场景下可以互相替代，但具体选择哪种数据结构取决于具体的需求和场景。

> 优先队列实现`k`选`1`的时间复杂度依赖于优先队列的具体实现方式。在理想情况下，如果优先队列使用<font color='red'>二叉堆</font>或斐波那契堆等高效数据结构来实现，那么`k`选`1`的时间复杂度可以达到`O(log k)`。
>
> 这是因为优先队列可以在对数时间内完成插入和删除最值（最大或最小元素）的操作。为了实现`k`选`1`，我们可以将`k`个元素插入到优先队列中，然后不断从队列中删除最值，直到队列为空。每次删除最值的时间复杂度是`O(log k)`，因此k选1的总时间复杂度也是`O(log k)`。
>
> 然而，需要注意的是，这里的时间复杂度分析是基于每个元素插入优先队列的时间复杂度为`O(log k)`的前提。如果插入操作的时间复杂度较高，比如使用数组实现优先队列时的`O(n)`时间复杂度，那么k选1的总时间复杂度也会相应提高。
>
> 另外，还需要考虑优先队列的空间复杂度。在实现`k`选`1`时，需要额外的空间来存储k个元素。因此，空间复杂度是`O(k)`。
>
> 综上所述，如果优先队列使用高效的数据结构来实现，并且插入操作的时间复杂度较低，那么`k`选`1`的时间复杂度可以达到`O(log k)`。但需要注意的是，这里的时间复杂度分析是基于一些假设和前提的，实际应用中还需要考虑具体的情况和需求。

#### 堆

> 在`Python`中，优先队列通常通过`heapq`模块实现，它提供了堆数据结构的相关操作，允许你以对数时间复杂度`（O(log k)）`来维护队列中的最小值（或最大值）。`heapq`模块默认实现的是最小堆，也就是说堆顶元素始终是最小的。
>
> 虽然`Python`标准库没有直接提供败者树`（Loser Tree）`的接口，但你可以使用`heapq`模块来模拟败者树的行为，从而快速实现`k`选`1`的问题。具体来说，你可以将k个序列的首个元素插入到最小堆中，然后每次从堆中取出最小值，并将该最小值所在序列的下一个元素（如果有的话）插入到堆中。这样，堆顶元素始终代表所有`k`个序列中的最小值。
>
> <font color='red'>例题：23</font>

在`Python`中，使用`heapq`模块建立包含`k`个元素的堆的时间复杂度是`O(k)`。`heapq`模块提供的`heapify`函数用于将一个列表转换为堆，其时间复杂度与列表的长度成正比。具体来说，`heapify`函数通过不断地调整元素的位置来确保父节点的值小于或等于其子节点的值（对于最小堆而言），这个过程需要遍历列表中的每个元素至多一次。

因此，对于`k`个元素，`heapify`函数需要执行`O(k)`次操作来建立堆。一旦堆被建立，你就可以使用`heapq`模块提供的其他函数（如`heappush`和`heappop`）来在堆上高效地执行插入和删除操作，这些操作的时间复杂度都是`O(log k)`。

总结一下，建立包含`k`个元素的堆的时间复杂度是`O(k)`，而随后在堆上进行的插入和删除操作的时间复杂度是`O(log k)`。

### 模式匹配

#### 暴力解法

#### KMP

#### 改进型KMP

题：`28`

### 单调栈

单调栈（`monotone-stack`）是一种特殊的数据结构，其特点在于栈内元素（从栈底到栈顶）都是单调递增或者单调递减的。也就是说，单调栈可以是单调递增栈或单调递减栈。单调递增栈意味着从栈顶到栈底的数据是从小到大的顺序排列，而单调递减栈则相反，数据是从大到小的顺序排列。

当有新的元素需要入栈时，单调栈会进行调整，确保栈内元素的单调性。这个过程中，所有可能破坏单调性的栈顶元素会被出栈，并且这些被出栈的元素不会再次入栈。由于每个元素最多只会入栈和出栈各一次，因此单调栈的维护时间复杂度是`O(n)`。

<font color='red'>单调栈中存储的元素既可以是数组的值，也可以是数组的下标</font>。

单调栈的应用非常广泛，包括字符串匹配、路径寻找、序列比对等场景。例如，在字符串匹配中，可以使用单调递减栈来优化暴力匹配算法；在路径寻找问题中，可以使用单调递增栈来存储每个节点的后继节点。

题 —— 42、739

#### 单调栈入门



### 快速幂、快速乘——手写幂、乘

* 模运算：

模运算：`a`除以`m`的余数，记为`a mod m = a % m`。

负数的取模，对于不同的语言可能不同。

> 在`c++`、`java`中，关于负数的取模
>
> 5 % 3 = 2 ；(-5) % (-3) = -2 ；5 % (-3) = 2 ；(-5) % 3 = -2
>
> 通过以上运算可以看出，模运算结果的符号和被除数的符号相同

> 在`python`中
>
> 5 % 3 = 2；(-5) % (-3) = -2；5 % (-3) = -1；(-5) % 3 = 1
>
> `python`中，向下取整、向负无穷方向取整

平时进行取模运算时，通常会将两个操作数取绝对值变成正数只会再进行计算，但是也要注意上述细节。

为什么要取模？

一个数太大，无法直接输出，可以把它取模之后，缩小数值在一个范围之内，再输出。哈希函数中通常用到取模运算。

模运算的性质：

> 加：(a+b)  mod m = ((a mod m) + (b mod m)) mod m
>
> 减：(a-b) mod m = ((a mod m) - (b mod m)) mod m
>
> 乘：(a*b) mod m = ((a mod  m) * (b mod m)) mod m

* 快速幂

快速幂是一种高效的计算幂运算（`a^n mod p`）的算法。

当我们要计算一个数的幂，特别是当指数`n`很大时，直接进行幂运算会导致大量的重复计算。

为什么说会导致重复计算呢？比如计算`2^10`，一般方法是`2*2*2*2...*2`，十个二相乘。但是若我们先计算`a=10^5`，再计算`a^2`，就可以将原来的`9`次乘法运算减少到`5`次。

直接连乘的方法时间复杂度可以达到`O(n)`,非常耗时。而且当`a`和`n`都特别大时，很容易发生<font color='red'>溢出</font>。

快速幂算法则可以在`O(log n)`的时间复杂度内完成幂运算。

* 快速幂的实现

  * 分治法：

    先计算`a^2`，再计算`(a^2)^2`，`...`，一直算到`a^n`

    ```py
    class Solution:
        def fastPow(self, a, n):
            if n == 1:
                return a
            temp = self.fastPow(a, n // 2)
            return temp * temp * (a if n & 1 == 1 else 1)
    ```

    上述代码用到了分治的思想，借助递归，计算`a ^ 2n`,先计算子问题`a^n`之后再相乘。

    ![image-20240307165502754](.\assets\image-20240307165502754.png)

    时间复杂度：`O(logn)`

  * 快速幂：

    以`a^11`为例，把`a^11`分解成`a^8`、`a^2`、`a^1`的乘积

    > a^11 = a^(8+2+1) = a^8 * a^2 * a^1
    >
    > 11 D = 1 0 1 1 B

    ![image-20240307173042195](.\assets\image-20240307173042195.png)

    其中`a^1、a^2、a^4、a^8……`的幂次都是`2`的背书，所有的幂`a^i`都是倍乘关系。

    如何将`11`分解为`8+2+1`?由于`11 = 2^3 * 1 + 2^2 * 0 + 2^1 * 1 + 2^0 * 1`，这不就是`11`的二进制`1011`吗？

    ```py
    def fastPow_binary(self, a, n):
        res = 1
        # 该循环内，temp = a^1,a^2,a^4,a^8,a^16....
        # 每次取n的二进制末尾，若为1，则结果乘上一个temp，否则不乘
        while n >= 1:
            # 判断最后一位是不是1，若是1，则结果需要乘上一个temp，否则不用乘
            if n & 1 == 1:
                res *= a
            # temp = a^1,a^2,a^4,a^8,a^16....
            a *= a
            # n = n>>1,逻辑右移，相当于 / 2
            n >>= 1
        return res
    ```

    时间复杂度：通过分析`while`循环的执行次数来判断时间复杂度，`n`每次`/2`，一直除到`n<1`，循环的次数为`logn`，因此总的时间复杂度是`O(logn)`

  * 快速幂取模版：

    由于`a^n`很快就变得非常非常大，因此需要取模将其限制在一个范围内，根据乘法取模的性质

    > 乘：(a*b) mod m = ((a mod  m) * (b mod m)) mod m

    上述代码可以优化成：

    ```py
        def fastPow_binary(self, a, n, mod):
            res = 1
            while n >= 1:
                if n & 1 == 1:
                    # 对乘法的结果进行取模
                    res = (res * a) % mod
                # 对乘法的因式进行取模
                a = (a * a) % mod
                n >>= 1
            return res
    ```

    `base = (base * base) % mod ` 将取模后的结果赋值给`base`，确实做到了对因式取模，但是这难道不会对下一次迭代中`base`取平方的值造成影响吗，新`base`的值应该是旧`base`的平方，而不是旧`base`取模之后再平方。

    但实际上这是可行的，例如我们本来是要求`a^2 mod n`,求`a^2`时却变成了`a%n * a%n`。因此`a^2 % n`就变成了`(a%n * a%n) % n`，这个等式恰巧就等于`a^2 mod n`，因此就算对因式取模之后再平方也可以得到相同的结果。

* 快速乘的实现：

  * 分治：

    ```py
    class Solution:
        def fastMultiple(self, a, b):
            if b == 1:
                return a
            temp = self.fastMultiple(a, b // 2)
            return temp + temp + (a if b & 1 == 1 else 0)
    ```

  * 二进制：

    ```py
    class Solution:
        def fastMultiple_binary(self, a, b):
            res = 0
            while b >= 1:
                if b & 1 == 1:
                    res += a
                a += a
                b >>= 1
            return res
    ```

### 二进制操作

* 位运算

  * 不仅能通过`mod 2`用来判断奇偶。也可以通过<font color='red'>位运算</font>来判断奇偶。

    > & 表示 与 运算，1 & 1 = 1，否则为 0 
    >
    > n & 1 == 1	奇数
    >
    > n & 1 == 0	偶数

    原理，二进制的最低位若为`1`，表示`2^0 * 1 = 1`，是一个奇数。

    二进制的最低位若为`0`，表示`2^0 * 0 = 0`，是一个偶数。

    其余位相与均为`0`。

  * 通过位运算判断两个`32`位整数是否同号

    在 `Python` 中，`>>>` 并不是一个运算符。如前所述，它通常用作 `Python `解释器或交互式 shell 的提示符，表示用户可以在其后输入` Python `代码。

    然而，在 `Java` 语言中，`>>>` 是一个无符号右移运算符（`unsigned right shift operator`）。这个运算符会将一个数的二进制表示向右移动指定的位数，并且在左侧用 `0 `来填充。这与 Java 中的有符号右移运算符 `>>` 不同，后者在左侧用符号位（正数为 `0`，负数为 `1`）来填充。也就是逻辑右移和算术右移的区别

    最高第`32`位是符号位

    ```java
    // ^ 表示异或操作
    (((dividend >>> 31) ^ (divisor >>> 31)) == 1);
    ```

### 数值的表示

在 `Python` 中，整数（`int`）类型使用任意精度的算术来实现，这意味着 `Python` 的整数可以表示任意大小的整数，只受限于可用内存的大小。这种实现方式使得 `Python` 的整数类型在数值范围和精度上都非常灵活，可以处理从非常小的数到非常大的数，而不会像其他语言中的固定大小整数类型那样受到限制。

下面详细解释一下` Python` 中 `int `类型的任意精度算术实现：

1. **动态内存分配**：
   `Python` 的整数类型不是固定大小的，而是根据整数的值动态分配内存。当一个整数的值变大时，`Python `会自动分配更多的内存来存储这个整数的完整表示。这意味着` Python` 的整数可以无限制地增长，只要系统还有可用的内存。

2. **大整数运算**：
   对于非常大的整数，`Python` 使用一种称为“大整数”或“任意精度算术”的技术来实现运算。这种技术基于一种高效的算法，可以在不限制整数大小的情况下执行加、减、乘、除等基本算术运算。

   具体来说，大整数运算通常使用一种称为“多精度算术”的方法，其中整数被分解为多个较小的部分（通常是机器字的大小），然后对这些部分执行运算。这种方法可以有效地处理非常大的数，并且在大多数情况下都能提供比固定大小整数更高的精度。

3. **优化和性能**：
   虽然任意精度算术在理论上可以处理任意大小的整数，但在实际应用中，处理非常大的整数可能会导致性能下降。因此，`Python` 的实现中包含了一些优化措施，以提高大整数运算的性能。

   例如，`Python `的整数类型实现通常会利用一些数学性质来加速运算，如使用<font color='red'>快速乘法算法（如 `Karatsuba` 算法）</font>来加速乘法运算。此外，`Python` 的解释器还会对整数运算进行缓存，以便更快地访问频繁使用的整数值。

4. **整数与浮点数的交互**：
   虽然 `Python `的整数类型使用任意精度算术，但当整数与浮点数进行运算时，结果通常会转换为浮点数类型。这是因为浮点数类型使用 `IEEE 754` 标准表示，具有固定的精度和范围限制。在这种情况下，整数会被转换为最接近的浮点数表示，然后进行运算。

需要注意的是，虽然 `Python` 的整数类型具有任意精度的特性，但在处理非常大的整数时仍然需要注意内存使用和性能问题。对于需要处理超大型整数的特定应用，可能需要使用专门的数学库或工具来提供更高效和精确的处理能力。

​			



* 移位运算

在Python中，移位运算符主要有两种：左移运算符（`<<`）和右移运算符（`>>`）。这些运算符用于将数字的二进制表示向左或向右移动指定的位数。

1. **左移运算符（`<<`）**

左移运算符将数字的二进制表示向左移动指定的位数。右侧空出的位用0填充。左移操作实际上相当于乘以2的移位次数次方。

例如：

```python
x = 5  # 二进制表示为 0101  
y = x << 2  # 左移2位，变为 10100，即十进制中的20  
print(y)  # 输出: 20
```

1. **右移运算符（`>>`）**

右移运算符将数字的二进制表示向右移动指定的位数。在`Python`中，右移操作执行的是逻辑右移，即左侧空出的位用`0`填充。这与某些其他编程语言（如`C`或`C++`）中的算数右移不同，后者在右移负数时会保持符号位不变。

例如：

```python
x = 20  # 二进制表示为 10100  
y = x >> 1  # 右移1位，变为 01010，即十进制中的10  
print(y)  # 输出: 10
```

需要注意的是，`Python`的整数是无限精度的，因此在实际应用中，你通常不需要担心溢出或固定位数的问题。移位运算符主要用于位操作和低级编程任务，例如处理二进制数据、优化算法性能或实现某些加密算法。

如果你确实需要模拟算数右移的行为（保持符号位），你需要像之前提到的那样，通过额外的逻辑来实现。然而，在大多数情况下，`Python`程序员不需要关心这种细节，因为`Python`的整数类型已经为我们处理了这些问题。







## 1. 两数之和（哈希表）

* 利用`hashTable`<font color='red'>代替遍历</font>来提高<font color='red'>查找</font>效率

  当需要遍历查找某个元素时，不妨使用`hashTable`

* `python`中`dict`底层就是用`hashTable`实现的，因此可以利用`dict`来模拟`hashTable`



## 2. 两数相加（单链表）

* 加法规则：利用**本位和**和**进位**，逐位相加

  注意，最后一次加法，当两个加数都为0，但若存在进位，也要单独为进位创建一个结点

> 迭代法

```py
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        i = l1
        j = l2
        carrier = 0
        # res是哨兵节点
        res = node = ListNode()
        while i or j:
            tmp = (i.val if i else 0) + (j.val if j else 0) + carrier
            # 表示本位和
            cur = tmp % 10
            # 表示来自低位的进位
            carrier = tmp // 10
            # // 表示取整除法 9//4=2 9.0//4.0=2.0
            if i:
                i = i.next
            if j:
                j = j.next
            node.next = ListNode(cur)
            node = node.next
        if carrier == 1:
            node.next = ListNode(1)
        # 返回哨兵节点的下一个
        return res.next
```

> 递归法

```py
def add(node1, node2, node, carrier):
    if node1 or node2 or carrier:
        num1 = node1.val if node1 else 0
        num2 = node2.val if node2 else 0
        tmp = num1 + num2 + carrier
        node.next = ListNode(tmp % 10)
        add(
            node1.next if node1 else None,
            node2.next if node2 else None,
            node.next,
            tmp // 10,
        )
    else:
        return

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        res = node = ListNode()
        add(l1, l2, node, 0)
        return res.next


# @lc code=end
```



## 3. 无重复字符的最长子串（动态规划 / 滑动窗口 + 哈希表）

> <font color='red' id='dp2'>动态规划</font>的思想：
>
> <font color='red'>将一个大的问题，分解为许多求解的小步骤 </font>
>
> 利用一个辅助数组`tmp[index]`来记录以`s[index]`<font color='red'>结尾</font>的子串中，最长无重复子串`str1`的长度
>
> 对于以`s[index+1]`结尾的子串，相当于在`str1`之后又加了一个字符`s[index+1]`
>
> 若`str1`中不包含`s[index+1]`，则以`s[index+1]`结尾最长无重复子串的长度加一：`s[index+1]=s[index]+1`
>
> 若`str1`中包含了`s[index+1]`，位置在`index2`，则以`s[index+1]`结尾最长无重复子串为`s[index2+1]~s[index]`
>
> ，长度为`index-index2`
>
> 
>
> <font color='red'>哈希表</font>对**查找**进行优化：
>
> 以上动态规划中，只需要遍历一遍字符串`s`,但是每次都需要向前找，判断是否存在上一个最长无重复子串中是否含有`s[index]`，
>
> <font color='red'>这里既然已经提到了查找，那么我们显然可以使用哈希表进行优化</font>
>
> 我们在哈希表`dict`中记录下每一个字符在字符串`s`最后一次出现的位置，并且判断该位置是不是在上一个最长无重复子串中即可。
>
> 如果不在，那么`tmp[index+1]=tmp[index]+1`
>
> 如果在，那么`tmp[index]=index-dict[s[index]]`
>
> 
>
> <font color='red' id='doublestick'>滑动窗口</font>优化**空间复杂度**：
>
> 以上代码中，我们用一个数组记录下来了以每个字符作为结尾时的最长无重复子串的长度。
>
> 但是实际运行时，研究`s[index+1]`时我们只需要用到`s[index]`的数据，因此我们只需要知道当前字符的上一个字符的最长无重复子串的起始位置即可。
>
> 因此我们可以仅仅使用一个`start`变量来记录以上一个字符结尾的最长无重复子串的起始位置即可
>
> 这样`start`和当前`index`就构成了一个滑动窗口，实际上是一个双指针

```py
# 法1：动态规划
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        max = 0
        tmp = [0] * len(s)

        for index, item in enumerate(s):
            tmp[index] = 1
            if index != 0:
                for index1 in range(index - 1, index - 1 - tmp[index - 1], -1):
                    if s[index1] != item:
                        tmp[index] += 1
                    else:
                        break
            max = tmp[index] if tmp[index] > max else max
        return max


# 哈希表优化：使用哈希表优化动态规划中的查找过程
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        max = 0
        tmp = [0] * len(s)

        d = dict()

        for index, item in enumerate(s):
            tmp[index] = 1
            if index != 0:
                if item in d and d[item] >= index - tmp[index - 1]:
                    tmp[index] = index - d[item]
                else:
                    tmp[index] = tmp[index - 1] + 1

            d[item] = index
            max = tmp[index] if tmp[index] > max else max
        return max
    
# 滑动窗口优化，使用start变量记录最长无重复子串的起始位置
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        max = 0
        start = 0
        d = dict()

        for index, item in enumerate(s):
            if item in d and d[item] >= start:
                start = d[item] + 1
            d[item] = index
            tmp = index - start + 1
            max = tmp if tmp > max else max
        return max
```

## 4. 寻找两个正序数组的中位数（归并)

```py
# 法一：将两个数组归并到一个新的数组
# 时间复杂度：o(m+n)
# 空间复杂度：o(m+n)
class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """

        length1 = len(nums1)
        length2 = len(nums2)
        length = length1 + length2
        nums3 = []
        i = j = 0
        while i < length1 or j < length2:
            if i == length1:
                nums3.extend(nums2[j::])
                break
            if j == length2:
                nums3.extend(nums1[i::])
                break
            if nums1[i] < nums2[j]:
                nums3.append(nums1[i])
                i += 1
            else:
                nums3.append(nums2[j])
                j += 1
        if length % 2 == 0:
            return (nums3[length // 2 - 1] + nums3[length // 2]) / 2
        else:
            return nums3[length // 2]
```

## 5. 最长回文子串（动态规划 / 中心扩展）

> 滑动窗口(双指针)方法：
>
> 若此题采用类似于题3（滑动窗口）的做法，从头到尾遍历字符串，借助以上一个字符结尾的【最长】回文子串计算以当前字符结尾的【最长】回文子串。
>
> 按照以上思想会得到以下代码的错误做法：比如`eababa`以最后一个`a`结尾的最长回文子串是`ababa`，当遍历到其下一个字符`eababab`中的`b`时，`b!=e`，但是以其结尾的最长回文子串是`babab`，而不是单独的`b`。这种做法的缺陷是我们只记录下了以`a`结尾的最长回文子串`str1`，而不是记录下来了以`a`结尾的所有回文子串，导致以`b`结尾但是不能与`str1`构成回文子串时，无法判断能不能构成其他的回文子串。

```py
# @lc code=start
class Solution:
    def longestPalindrome(self, s: str) -> str:
        max = 1
        maxStart = maxEnd = laststart = 0
        for index, str in enumerate(s):
            if laststart - 1 != -1 and s[laststart - 1] == str:
                laststart -= 1
            else:
                laststart = index
            if index - laststart + 1 > max:
                maxStart = laststart
                maxEnd = index
        return s[maxStart : maxEnd + 1]
```

> 滑动窗口(双指针) vs 动态规划
>
> 改进方式：不能仅仅记录下以`s[i]`结尾的最长回文子串，而必须记录下以`s[i]`结尾的所有回文子串。这就需要用到一个二维数组。实际上是用到了动态规划的方法。
>
> 这样从一定程度上反映了动态规划和滑动窗口(双指针)两种方式的区别：动态规划记录下了每一种可能的情况（所有回文子串），而滑动窗口仅仅用双指针记录下了上一次最优的情况（最长回文子串）。但是此题中，若仅仅用双指针记录下上一个最长回文子串，该信息并不能帮助我们递推出下一个最长回文子串。简而言之就是记录的信息量太少了，无法构建出状态转移方程。

> 动态规划方法：
>
> <font color='red'>无论是是滑动窗口还是动态规划，实际上都是一个递推的过程。</font>
>
> 基本思想：以`s[i+1]`结尾的回文子串必然包含了所有以`s[i]`结尾的回文子串（除了`s[i+1]`自身这个单字符串），这就给了我们从`s[i]`递推到`s[i+1]`的可能性，这也就是动态规划的状态转移方程（类似于递推式）。
>
> 二维`dp`数组：`dp[i][j]`：如果子串`s[i]~s[j]` 是回文串，`dp[i][j]=1`，若不是回文串，则为`0`。注意若`i>j`，这是一个不合法的子串，此时`d[i][j]=0`。也就是说该矩阵是一个对角线元素全部为`1`的上三角矩阵。
>
> <font color='red'>状态转移方程</font>：只有 `s[i+1:j−1]` 是回文串，并且 `s` 的第`i`和`j`个字母相同时，`s[i:j]` 才会是回文串。
>
> 动态规划的<font color='red'>边界条件</font>：若上一个回文串的长度为`1`，即`s[i-1]`单字符构成了一个回文串，若`s[i]=s[i-1]`，那么`s[i-1:i+1]`也是一个回文串。

```py
class Solution:
    def longestPalindrome(self, s: str) -> str:
        max = 1
        maxStart = 0
        
        # 数组推导式构建初始dp二维数组
        dp = [[1 if i == j else 0 for j in range(0, len(s))] for i in range(0, len(s))]
        for index, char in enumerate(s):
            # 第一个字符不必递推，直接跳过
            if index == 0:
                continue
                
            else:
                for j in range(0, index):
    				# 若是回文子串
                    if dp[j][index - 1] == 1:
                        # 若回文子串长度为1
                        if j == index - 1 and s[j] == s[index]:
                            dp[j][index] = 1
                            if index - j + 1 > max:
                                max = index - j + 1
                                maxStart = j
                        if j == 0:
                            continue
                        # 状态转移递推
                        if s[j - 1] == char:
                            dp[j - 1][index] = 1
                            if index - j + 2 > max:
                                max = index - j + 2
                                maxStart = j - 1
        return s[maxStart : maxStart+max: 1]
```

> 时间复杂度：`O(n^2)`（双重循环）
>
> 空间复杂度：`O(n^2)`（`dp`数组）

> 中心扩展方法：
>
> 枚举所有的可扩展中心并且向两端扩展，但是要注意扩展中心是一个字符还是两个字符的边界情况。
>
> 时间复杂度：`O(n^2)`
>
> 空间复杂度：`O(1)`（双指针，无需二维数组）

```py
class Solution:
    def expandAroundCenter(self, s, left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return left + 1, right - 1

    def longestPalindrome(self, s: str) -> str:
        start, end = 0, 0
        for i in range(len(s)):
            left1, right1 = self.expandAroundCenter(s, i, i)
            left2, right2 = self.expandAroundCenter(s, i, i + 1)
            if right1 - left1 > end - start:
                start, end = left1, right1
            if right2 - left2 > end - start:
                start, end = left2, right2
        return s[start: end + 1]
```

## 6. z-字形变换（将数据同时作为tag）

> 使用变量`carrier`巧妙地解决`index`增加还是减少的问题
>
> 不必要单独设置一个`tag`标识增加还是减少，直接利用`carrier`本身的正负解决这个问题

```py
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        tmp = [[] for i in range(numRows)]
        carrier = 1
        index = 0
        for char in s:
            tmp[index].append(char)
            index = index + carrier if numRows != 1 else 0
            if index == numRows - 1:
                carrier = -1
            elif index == 0:
                carrier = 1
        return "".join(["".join(item) for item in tmp])
```

## 7. 整数反转（商与余数的使用）

```py
class Solution:
    def reverse(self, x: int) -> int:
        res = 0
        tmp = abs(x)
        while tmp >= 1:
            res = res * 10 + tmp % 10
            tmp = (tmp - tmp % 10) // 10
        if res >= 2**31 - 1:
            return 0
        return res if x > 0 else -res
```

> 位运算扩展：`2**31`=`1<<31`

## 8. 字符串转换整数 (atoi)

> 依旧使用位运算
>
> 若不使用 `trim() / strip()` 删除首部空格，而采取遍历跳过空格的方式，则可以将空间复杂度降低至 `O(1)`
>
> 将字符`9`转化为数字`9`的方法：
>
> * `int('9')`
> * `ascii('9')-ascii('0')`

```py
class Solution:
    def myAtoi(self, s: str) -> int:
        s = s.strip()
        if s == "":
            return 0
        tag = s[0]
        res = 0
        for index, char in enumerate(s):
            if char in ["-", "+"] and index == 0:
                continue
            elif char >= "0" and char <= "9":
                res = res * 10 + int(char)
            else:
                break
        if tag == "-":
            return -res if res <= 1 << 31 else (-1) << 31
        else:
            return res if res <= (1 << 31) - 1 else (1 << 31) - 1
```

## 9. 回文数

> 无脑转字符串

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        tmp=str(x)
        return tmp[::-1]==tmp
```

> 不转字符串
>
> 边取出原数最后一位，一边把他加到最终结果中

```py
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        tmp = 0
        y=x
        while x >= 1:
            tmp = tmp * 10 + x % 10
            x = (x - x % 10) // 10
        return tmp == y
```

## 10. 正则表达式匹配（递归 + 动态规划 + 备忘录）

* 法一：普通递归

  思想：

  > 如果匹配到的字符后面没有跟`*`，那么直接按照规则匹配：
  >
  > * 如果是`.`，无脑匹配
  > * 否则需要匹配串和模式串的当前字符相同
  >
  > 如果匹配到的字符后面跟了`*`：比如`a*`，此时的主要问题就是不知道应该匹配多少个`a`，可以是`0`个，也可以是若干个，匹配不同个数的`a`会影响到后面的匹配。
  >
  > 我们可以试着依次匹配`0~max`个`a`。
  >
  > 例如：`s:aaabc`，`p:a*bc`
  >
  > 首先匹配`0`个`a`：那么就是要递归判断剩下的`aaabc`和`bc`是否匹配，如果剩下的也可以匹配，那么说明初始`s`和`p`可以成功匹配，如果剩下的`aaabc`和`bc`不匹配，那么就不能只匹配`0`个`a`
  >
  > 接下来匹配`1`个`a`：那么就是要递归判断剩下的`aabc`和`bc`是否匹配，不匹配
  >
  > 接下来匹配`2`个`a`：那么就是要递归判断剩下的`abc`和`bc`是否匹配，不匹配
  >
  > 接下来匹配`3`个`a`：那么就是要递归判断剩下的`bc`和`bc`是否匹配，可以匹配

  ```py
  class Solution:
      def isMatch(self, s: str, p: str) -> bool:
          # index1指向字符串s，index2指向模式串p
          index1, index2 = 0, 0
          length1, length2 = len(s), len(p)
          while index2 < length2:
              char1 = p[index2]
              char2 = p[index2 + 1] if index2 < length2 - 1 else ""
              if char2=='*':
                  p_tmp = p[index2 + 2 :]
                  # 依次匹配0个到多个a
                  while True:
                      if self.isMatch(s_tmp, p_tmp):
                          return True
                      elif index1 >= length1:
                          return False
                      elif s[index1] == char1 or char1 == ".":
                          index1 += 1
                      else:
                          return False
              else:
                  if (index1 >= length1) or (char1 != "." and s[index1] != char1):
                      return False
                  else:
                      index1, index2 = index1 + 1, index2 + 1
          if index1<length1:
              return False
          return True
  ```

* 法二：<font id='dp1'>使用备忘录进行记忆化递归</font>

  上面的做法存在一个问题，例如：

  `"s=aaaaaaaaaaaaaaaaab", p="a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*"`

  按照上面的做法就会递归到判断`aaaaaaaaaaaaaaaaab`和`a*`是否匹配，然后一直到`ab`和`a*`是否匹配，这一步的结果是不匹配

  之后就会回到上一层还是会用到`aaaaaaaaaaaaaaaaab`和`a*`是否匹配的结果，因此我们可以将每一次匹配的结果利用字典存储下来，达到一种空间换时间的效果：

  ```py
  class Solution:
      dict_ = dict()
      def isMatch(self, s: str, p: str) -> bool:
          # index1指向字符串s，index2指向模式串p
          index1, index2 = 0, 0
          length1, length2 = len(s), len(p)
          while index2 < length2:
              char1 = p[index2]
              char2 = p[index2 + 1] if index2 < length2 - 1 else ""
              if char2=='*':
                  p_tmp = p[index2 + 2 :]
                  while True:
                      s_tmp = s[index1:]
                      # 这里的key要选合适，如果选用index1,index2作为key，在多层递归中的index1和index2会重复覆盖
                      key = f"{p_tmp},{s_tmp}"
                      if key not in self.dict_:
                          # 存放子问题的结果
                          self.dict_[key] = self.isMatch(s_tmp, p_tmp)
  
                      if self.dict_[key]:
                          return True
                      elif index1 >= length1:
                          return False
                      elif s[index1] == char1 or char1 == ".":
                          index1 += 1
                      else:
                          return False
              else:
                  if (index1 >= length1) or (char1 != "." and s[index1] != char1):
                      return False
                  else:
                      index1, index2 = index1 + 1, index2 + 1
          if index1<length1:
              return False
          return True
  ```

* 递归改进：

  上述代码中，在递归中依旧使用到了`while`循环来解决遇到`*`时匹配若干次的问题。这种做法过于繁琐，实际上我们可以<font color='red'>将这个迭代的过程融合到迭代本身的逻辑中</font>

  ```py
  class Solution:
      dict_ = dict()
      
      def isMatch(self, s: str, p: str) -> bool:
          # 以主串s和模式串p构造关键字key
          key = f"{s},{p}"
  		
          # 先查备忘录，如已经记录了子问题的结果，则直接返回
          if key in self.dict_:
              return self.dict_[key]
  		# 递归的退出条件
          if s==p:
              return True
          
  		# 判断当前字符是否可以匹配: 1.字符相等; 2.使用.通配
          equalFirst = len(p) > 0 and len(s) > 0 and (p[0] in (s[0], "."))
          # 判断后面是否有* 
          ignoreFirst = len(p)>1 and p[1]=='*'
          
          # 如果当前字符匹配而且后面没有*
          if equalFirst and not ignoreFirst:
              # 则直接递归匹配s[1:]和p[1:]
              self.dict_[key] = self.isMatch(s[1:], p[1:])
          # 如果当前字符不匹配但是后面有*，可以匹配0个
          elif not equalFirst and ignoreFirst:
              # 直接匹配0个，接下来继续匹配s和p[2:]
              self.dict_[key] = self.isMatch(s, p[2:])
          # 如果当前字符不匹配而且接下来也不是*
          elif not equalFirst and not ignoreFirst:
              # 那么匹配失败
              self.dict_[key] = False
          # 如果当前字符匹配成功而且后面也有*，此时不确定需要匹配多少个
          # 可能是匹配0个，1个，2个...
          elif equalFirst and ignoreFirst:
              # 将依次匹配0、1、2、3...个的逻辑融合到迭代中
              # 若匹配0个，则判断s和p[2:]是否可以正常匹配
              # 若匹配1个，则先进入递归1判断s[1:]和p是否可以正常匹配，然后递归1中匹配0个，此时相当于外层匹配了1个
              # 若匹配2个，则先进入递归1匹配s[1:]和p，然后递归1中再次匹配一个s[1:]和p，此时就相当于外层递归匹配了两个
              # ...
              self.dict_[key] = self.isMatch(s, p[2:]) or self.isMatch(s[1:], p)
  
          return self.dict_[key]
  ```


## 11. 盛最多水的容器（双指针，两侧往中间）

暴力解法：直接双重循环枚举出所有面积的可能性，时间复杂度为：`O(n^2)`

要有一种直觉：这种双重循环的题目一般可以使用双指针来解决，一次遍历可以将时间复杂度降低为：`O(n)`

双指针代表的是 **可以作为容器边界的所有位置的范围**。

> 双指针做法：前后两个指针分别指向数组的两端，这就控制了水槽的起始长度是最大的。
>
> 若还想要增加水槽的容积，就得增加水槽的高度。
>
> 然后就比较左右两个壁`a`,`b`是哪一个限制了水槽的容积，也就是短板效应中的短板`a`。之后我们试着从该短板一直往内部移动找到一个比短板更长的板`c`，之后使用`c`，`b`算出容积。
>
> 再用`c`和`b`重复以上操作，若是`b`是短板限制了水槽的容积，那么就需要将`b`往内部移动，找到一个比`b`更长的板`d`，以`c`和`d`算出一个容积

```py
class Solution:
    def maxArea(self, height: list[int]) -> int:bi
        left, right = 0, len(height) - 1
        area = 0
        while left<right:
            min_height=min(height[left], height[right])
            area_cur = (right - left) * min_height
            area = area_cur if area_cur > area else area
            if height[left]<height[right]:
                while left<right and height[left]<=min_height:
                    left += 1
            else:
                while left<right and height[right]<=min_height:
                    right -= 1
        return area
```

## 12. 整数转罗马数字（贪心+哈希表）

贪心法则：我们每次尽量使用最大的数来表示。 比如对于 `1994` 这个数，如果我们每次尽量用最大的数来表示，依次选 `1000`，`900`，`90`，`4`，会得到正确结果 `MCMXCIV`。

```py
class Solution:
    def intToRoman(self, num: int) -> str:
        res = ""
        
        # 为每个数字指定一个编码，这样的做法叫做 硬编码
        dict_ = {
            1000: "M",
            900: "CM",
            500: "D",
            400: "CD",
            100: "C",
            90: "XC",
            50: "L",
            40: "XL",
            10: "X",
            9: "IX",
            5: "V",
            4: "IV",
            1: "I",
        }
        
        for key in dict_:
            value = dict_[key]
            quotient = num // key
            remainder = num % key
            res += f"{value}" * quotient
            num = remainder
        return res
```

## 13. 罗马数字转整数（贪心，哈希表，Switch）

若想进一步提高性能，将`Hash`表转化为`Switch`语法即可

```py
class Solution:
    def romanToInt(self, s: str) -> int:
        res=0
        dict_ = {
            # key : value
            1000: "M",
            900: "CM",
            500: "D",
            400: "CD",
            100: "C",
            90: "XC",
            50: "L",
            40: "XL",
            10: "X",
            9: "IX",
            5: "V",
            4: "IV",
            1: "I",
        }
        for key in dict_:
            value = dict_[key]
            while s.startswith(value):
                res += key
                s = s[len(value) :]
        return res
```

## 14. 最长公共前缀

法一：巧用`map`求最短长度和`set`去重，但是需要多次遍历`strs`数组，时间复杂度比较高

时间复杂度：`O(min_len * len(strs))`

```py
class Solution:
    def longestCommonPrefix(self, strs: list[str]) -> str:
        min_len = min(map(lambda x: len(x), strs))
        set_=set()
        res=''
        for i in range(min_len):
            for str in strs:
                set_.add(str[i])
            if len(set_)==1:
                res += set_.pop()
            else:
                break
        return res
```

利用推导式快速生成集合：

```py
class Solution:
    def longestCommonPrefix(self, strs: list[str]) -> str:
        min_len = min(map(lambda x: len(x), strs))
        res = ""
        for i in range(min_len):
            set_ = {str[i] for str in strs}
            if len(set_) == 1:
                res += set_.pop()
            else:
                break
        return res
```

法二：巧用`reduce`，横向扫描一遍`strs`即可

时间复杂度：`O(len(strs) * min_len)`

```py
class Solution:
    def longestCommonPrefix(self, strs: list[str]) -> str:
        def func(x,y):
            res=''
            for i in range(min(len(x),len(y))):
                if x[i]==y[i]:
                    res+=x[i]
                else:
                    break
            return res
        return reduce(func,strs)
```

法三：巧用`zip`函数和`set`去重

```py
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        ans = ''
        for i in list(zip(*strs)):
            if len(set(i)) == 1:
                ans += i[0]
            else:
                break
        return ans
```

## 15. 三数之和（排序 + 双指针）

法一：三层暴力循环，时间复杂度：`O(n^3)`

法二：二层循环 + `hashMap`，时间复杂度：`O(n^2)`。但是这种方法不利于三元组的去重操作。

<font color='red'>涉及到结果的去重，我们一般使用到的方法是将数组进行排序</font>

法三：排序+一层循环+双指针

若想要使用前后双指针往中间移动，在`O(n)`的时间复杂度内解决两数之和的问题，就必须将数组排序，排序的时间复杂度是：`O(nlogn)`

```py
class Solution:
    def threeSum(self, nums: list[int]) -> list[list[int]]:
        res=[]
        set_ = set()
        len_nums=len(nums)
        nums=sorted(nums)
        for i in range(len_nums):
            left = i + 1
            right = len_nums - 1
            while left<right:
                tmp=nums[i]+nums[left]+nums[right]
                if tmp<0:
                    left+=1
                elif tmp>0:
                    right-=1
                else:
                    string = str([nums[i], nums[left], nums[right]])
                    
                    # 利用Hashset进行去重，因为i<left<right，而且数组有序，故该三元组[nums[i], nums[left], nums[right]]也一定是内部有序的，因此可以将其转化为str类型进行去重
                    if string not in set_:
                        res.append([nums[i], nums[left], nums[right]])
                        set_.add(string)
                    left += 1
        return res
```

法3存在的问题，时间复杂度为：`O(n^2)`，会有`1-2`个用例超时

改进版，不利用`set`去重，直接利用排序逻辑进行去重

```py
class Solution:
    def threeSum(self, nums: list[int]) -> list[list[int]]:
        res=[]
        len_nums=len(nums)
        nums=sorted(nums)
        for i in range(len_nums):
            # 去重，若当前i指向的数字不变，那么直接跳过
            if nums[i] == nums[i - 1] and i != 0:
                continue

            left = i + 1
            right = len_nums - 1
            while left<right:
                tmp=nums[i]+nums[left]+nums[right]
                if tmp<0:
                    left+=1
                elif tmp>0:
                    right-=1
                else:
                    res.append([nums[i], nums[left], nums[right]])
                    tag=nums[left]   

                    # 去重，移动左指针，直到左指针指向的值发生变化
                    while nums[left] == tag and left < right:
                        left+=1
        return res
```

#### 破解`O(n^3)` & 去重

若想要将`O(n^3)`的时间复杂度降低到`O(n^2)`，排序通常是一个比较好的解决方法。

排序的时间复杂度是`O(nlogn)`，远远低于`O(n^3)`。

而且排序之后，通常可以在`O(n^2)`的时间复杂度内解决问题，而且`O(nlogn)`远远低于`O(n^2)`，故最终的时间复杂度为`O(n^2)`

而且此题使用排序之后还可以轻易进行去重



## 16. 最接近的三数之和（排序 + 双指针）

依旧类似上一题，使用排序+双指针的方式，时间复杂度可以达到：`O(n^2)`。`leetcode`运行时间为`450ms`，但是看到前`5%`的运行时间只有`45ms`。其实大体思路没有变，只是增加了一些优化剪枝操作

```py
class Solution:
    def threeSumClosest(self, nums: list[int], target: int) -> int:
        nums.sort()
        length = len(nums)
        res = nums[0] + nums[1] + nums[2]

        for i in range(length):
            if nums[i]==nums[i-1] and i>0:
                continue
            left, right = i + 1, length - 1
            while left<right:
                tmp = nums[i] + nums[left] + nums[right]
                if abs(tmp-target)<abs(res-target):
                    res = tmp
                if tmp==target:
                    return target
                elif tmp>target:
                    tag=nums[right]
                    while nums[right]==tag and left<right:
                        right -= 1
                else:
                    tag=nums[left]
                    while nums[left] == tag and left < right:
                        left += 1

        return res
```



## 17. 电话号码的字母组合（递归 / 回溯)

法一：递归 + 全排列

```py
class Solution:
    dict_ = {
        "2": ["a", "b", "c"],
        "3": ["d", "e", "f"],
        "4": ["g", "h", "i"],
        "5": ["j", "k", "l"],
        "6": ["m", "n", "o"],
        "7": ["p", "q", "r", "s"],
        "8": ["t", "u", "v"],
        "9": ["w", "x", "y", "z"],
    }
    def letterCombinations(self, digits: str) -> list[str]:
        if len(digits) == 0:
            return []
        elif len(digits) == 1:
            return self.dict_[digits]
        else:
            tmp = self.letterCombinations(digits[1:])
            return [f"{first}{item}" for first in self.dict_[digits[0]] for item in tmp]
```

法二：迭代（非递归）

```py
class Solution:
    dict_ = {
        "2": ["a", "b", "c"],
        "3": ["d", "e", "f"],
        "4": ["g", "h", "i"],
        "5": ["j", "k", "l"],
        "6": ["m", "n", "o"],
        "7": ["p", "q", "r", "s"],
        "8": ["t", "u", "v"],
        "9": ["w", "x", "y", "z"],
    }
    def letterCombinations(self, digits: str) -> list[str]:
        pre=[]
        for char in digits:
            if pre==[]:
                pre = self.dict_[char]
            else:
                pre = [item + cur for item in pre for cur in self.dict_[char]]
        return pre
```

法三：回溯：【递归 + 深度优先（`DFS`)】

![image-20240301190435638](.\assets\image-20240301190435638.png)

![image-20240301190538922](.\assets\image-20240301190538922.png)

```py
class Solution:
    dict_ = ["","",'abc','def','ghi','jkl','mno','pqrs','tuv','wxyz']
    def letterCombinations(self, digits: str) -> list[str]:
        res, length = [], len(digits)

        if length == 0:
            return []

        path=['']*length

        def dfs(i):
            # 边界条件
            if i==length:
                res.append("".join(path))
                return
            # 非边界条件
            else:
                for char in self.dict_[int(digits[i])]:
                    path[i]=char
                    dfs(i + 1)
        dfs(0)
        return res
```

时空复杂度计算方法：

时间复杂度：将这棵树进行深度优先搜索，<font color='red'>因此树的节点都会被遍历一次。树的节点的个数就是时间复杂度</font>：`O(3^m × 4^n)`

空间复杂度：`O(m+n)`,其中`m`是输入中对应 `3` 个字母的数字个数，`n` 是输入中对应 `4` 个字母的数字个数，`m+n` 是输入数字的总个数。除了返回值以外，<font color='red'>空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数</font>，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为 `m+n`。



## 18. 四数之和（排序+双指针+剪枝）

若用暴力解法，时间复杂度为：`O(n^4)`

若排序之后，再用二层循环+双指针，时间复杂度为：`O(n^3)`

未剪枝版本：

```py
class Solution:
    def fourSum(self, nums: list[int], target: int) -> list[list[int]]:
        # 先排序，方便使用双指针和去重
        nums.sort()
        length = len(nums)
        res = []
        for i in range(length):
            # 去重关键步骤：若nums[i]和nums[i-1]相同，则直接跳过
            # 因为满足包含nums[i]的四元组，肯定已经含于nums[i-1]的四元组
            if nums[i]==nums[i-1] and i>0:
                continue
            for j in range(i + 1, length):
                # 去重关键步骤：若nums[j]和nums[j-1]相同，则直接跳过
                if nums[j] == nums[j - 1] and j > i + 1:
                    continue
                front, end = j + 1, length - 1
                while front < end:
                    sum = nums[i] + nums[j] + nums[front] + nums[end]
                    if sum > target:
                        end -= 1
                    elif sum < target:
                        front += 1
                    else:
                        res.append([nums[i], nums[j], nums[front], nums[end]])
                        flag=nums[front]
                        while front < end and nums[front] == flag:
                            front += 1
        return res
```

去重原理（以最外层的`nums[i]`举例）

若`nums[i]=nums[i-1]`。对于`nums[i-1]`，内层循环已经找到了在`i-1`之后的所有三元组，使得这个三元组和`nums[i-1]`的和等于`target`，因此当最外层循环遍历到`nums[i]`时，需要找到在`i`之后满足条件的三元组`M`。又因为`nums[i]=nums[i-1]`，所以满足条件的三元组`M`已经在上一次循环中被找到过了，因此直接跳过该层循环以达到去重效果

剪枝版本：

```py
class Solution:
    def fourSum(self, nums: list[int], target: int) -> list[list[int]]:
        # 先排序，方便使用双指针和去重
        nums.sort()
        length = len(nums)
        res = []
        for i in range(length-3):
            # 去重
            if nums[i]==nums[i-1] and i>0:
                continue
            # 剪枝1：若以nums[i]开头最小的四元组之和都大于target，则直接跳出循环
            if nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target:
                break
            # 剪枝2：若以nums[i]开头最大的四元组之和都小于target，则直接跳过当前次循环
            if nums[i]+nums[length-1]+nums[length-2]+nums[length-3]<target:
                continue
            for j in range(i + 1, length - 2):
                # 去重
                if nums[j] == nums[j - 1] and j > i + 1:
                    continue
                # 剪枝3
                if nums[j]+nums[j+1]+nums[j+2]>target-nums[i]:
                    break
                # 剪枝4
                if nums[j] + nums[length - 1] + nums[length - 2] < target - nums[i]:
                    continue
                front, end = j + 1, length - 1
                while front < end:
                    sum = nums[i] + nums[j] + nums[front] + nums[end]
                    if sum > target:
                        end -= 1
                    elif sum < target:
                        front += 1
                    else:
                        res.append([nums[i], nums[j], nums[front], nums[end]])
                        flag=nums[front]
                        while front < end and nums[front] == flag:
                            front += 1
        return res
```

## 19. 删除链表的倒数第 N 个结点（快慢双指针 / 栈 / 递归）

法一：快慢双指针

双指针貌似是一次遍历同时移动两个指针，但是实际上和两次遍历每次移动一个指针的时间消耗差不多。

这么讲，我写两个循环，但是每个循环都是一次操作，时间复杂度为`O(n+n)=O(2n)`，我写一个循环，但是一个循环内就有两个操作了，那么时间复杂度为`O(2*n)=O(2n)`。

但是少了循环语句的汇编代码执行次数。但是`python`又是解释性语言，不需要变成汇编语言。

在第二种方法中，如果确实使用了两个独立的 `for` 循环来分别递增 `a` 和 `b`，则理论上可能会生成更多的汇编指令。这是因为每个循环都需要独立的迭代控制和递增操作。

然而，这并不意味着第二种方法一定会比第一种方法运行得更慢。实际性能取决于多个因素，包括：

1. **循环次数**：如果两个循环的迭代次数相同，那么总的指令数量虽然更多，但每次迭代的时间可能相同。
2. **指令优化**：现代编译器通常会对生成的代码进行优化，包括循环展开、指令合并等，以减少实际执行的指令数量。
3. **硬件特性**：CPU 的指令执行速度、缓存大小、内存带宽等硬件特性也会影响性能。
4. **并行性**：如果两个循环能够并行执行（例如，在不同的处理器核心上），那么总的执行时间可能不会增加。
5. **其他负载**：系统的其他负载和进程调度也会影响性能。

通常，除非循环次数非常大，或者每次迭代中的操作非常复杂，否则两个独立的循环不太可能显著影响总体性能。实际上，在大多数现代硬件和编译器优化下，这两种方法的性能差异可能是微不足道的。

如果你真的关心性能，并且循环次数很大，最好的做法是编写实际的代码并进行基准测试（benchmarking），以测量两种方法的实际性能。这样，你可以根据具体的硬件和编译器设置得出最准确的结论。

> Python是一种高级编程语言，它的执行过程通常不是直接由高级语言翻译成机器语言。Python的执行过程涉及几个步骤：
>
> 1. **源代码（Source Code）**：这是你写的`Python`代码，它是人类可读的。
> 2. **编译（Compilation）**：`Python`语言通常不经过传统的编译过程，因为它是一种解释型语言。但是，`Python`代码可以被“编译”成字节码（`bytecode`）。这个过程通常在你运行`Python`程序时自动进行。`Python`提供了一个模块叫`py_compile`，它可以用来编译`Python`源文件为字节码文件（`.pyc`文件）。
> 3. **解释执行（Interpretation）**：`Python`虚拟机（`Python Virtual Machine, PVM`）读取这些字节码并执行它们。这个过程是解释执行，意味着`PVM`逐行读取字节码并立即执行它。
>
> 因此，`Python`不直接翻译成机器语言，而是先翻译成字节码，然后由`Python`虚拟机解释执行这些字节码。
>
> 此外，有些工具和技术，如`JIT（Just-In-Time compilation）`编译器，如`PyPy`，可以在运行时将`Python`代码编译成机器码，以提高执行效率。但这仍然是间接的，不是直接将高级语言翻译成机器语言。
>
> 至于汇编语言，现代的高级语言编译器或解释器通常不会直接生成汇编语言。汇编语言是一种低级语言，与特定的机器或处理器架构紧密相关。高级语言编译器通常会生成与目标机器架构相关的中间代码或机器码，而不是汇编语言。在`Python`的情况下，如前所述，它通常生成字节码并由虚拟机解释执行，而不是生成汇编语言。

> C语言的编译过程通常包括以下几个步骤：
>
> 1. **预处理（Preprocessing）**：编译器首先处理源代码中的预处理指令，如`#include`和`#define`等。
> 2. **编译（Compilation）**：在预处理之后，编译器将C语言源代码转换为汇编语言代码。这个过程包括语法分析、语义分析、优化等步骤。
> 3. **汇编（Assembly）**：汇编器将编译生成的汇编语言代码转换为机器语言的目标文件（通常是`.o`或`.obj`文件）。
> 4. **链接（Linking）**：链接器将多个目标文件以及所需的库文件合并成一个可执行文件。
>
> 汇编语言是在编译阶段由C语言转换而来的，并且在链接阶段生成最终的可执行文件之前，汇编语言代码会被转换成机器语言代码。
>
> 需要注意的是，有些编译器或工具可能提供了在运行时动态编译或解释C语言代码的功能，但这并不是C语言的标准执行方式。这些工具通常是为了特定的应用场景或性能优化而设计的。

```py
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next: ListNode = next
        
class Solution:
    # Optional[ListNode]: 这是一个类型注解，表示head和返回值可以是ListNode类型或None。
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # python支持连续赋值
        slow = fast = head
        for i in range(n - 1):
            fast = fast.next
        slow_prev=None
        while fast.next != None:
            fast = fast.next
            slow_prev=slow
            slow = slow.next

        if slow_prev == None:
            return head.next
        else:
            slow_prev.next=slow_prev.next.next
            return head
# @lc code=end
```

法二：栈

我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 `n` 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。

新加一个哑巴节点，来使得删除操作一致

```py
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        # dummy是新加的一个头节点，也叫做哑巴节点，dummy.next=head。
        # 这样可以使得对每个节点的删除操作一致，不必额外考虑头节点
        dummy = ListNode(0, head)
        stack = list()
        cur = dummy
        while cur:
            stack.append(cur)
            cur = cur.next
        
        for i in range(n):
            stack.pop()

        prev = stack[-1]
        prev.next = prev.next.next
        return dummy.next
```

法三：递归大法

既然可以用栈解决，我们很可能也可以利用递归隐式使用栈。

<font color='red'>递归法和栈法的思想世界上是一致的</font>

空间复杂度提升为：`O(n)`

```py
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next: ListNode = next

class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        # travel函数的作用是获取node节点是倒数第几个节点
        def travel(node, n):
            # None是倒数第0个节点
            if node == None:
                return 0
            # 回溯一个节点，该节点是倒数+1个节点
            last_k = travel(node.next, n) + 1
            # 如果回溯到倒数第n+1个节点，则删除该节点之后的节点
            # 如果要删除头节点，那么该if语句不会执行，删除操作需要额外进行
            if last_k == n + 1:
                node.next = node.next.next
            return last_k
        
        # 头节点是倒数第last_k个节点
        last_k = travel(head, n)
        # 如果头节点就是倒数第n个节点，那么直接删除头节点
        if last_k == n:
            return head.next
        # 否则直接返回头节点
        else: 
            return head
```

```java
class Solution {
public:
   int endCout =0;
   ListNode* removeNthFromEnd(ListNode* head, int n) {
       if(!head) //跳出条件
       {
           return nullptr;
       };
       head->next = removeNthFromEnd(head -> next,n); //递归到最后一个元素
       return ++endCout == n ? head->next : head; //从最后一个元素，开始累加，当符合计数的时候，返回该节点的下个节点，即删除节点，没有进行内存释放哦
   }
};
```

## 20. 有效的括号（栈）

法一：栈

利用`map`：把字符配对处理放一起还是值得借鉴的，后续扩展会比较好，比如再加`<>`配对，你这个修改就很麻烦，也容易出错，你写的代码，后续不一定是你维护修改，代码设计其中一个原则：<font color='red'>对扩展开放，对修改关闭</font>。

利用`map`配对，扩展性和健壮性都更强，可读性也高

题目简单，不过题解的细节还是值得学习。一是`s`长度为奇数时可以直接排除，二是可以用哈希表实现快速配对(而不是写一堆`switch`和`if else`)

```py
class Solution:
    def isValid(self, s: str) -> bool:
        # 增加一个剪枝操作，瞬间秒杀长度为奇数的字符串，时间效率明显提高
        if len(s) % 2 == 1:
            return False
        
        stack = list()
        # 哈希表快速配对，而不需要一堆 if else语句一个个配对
        map = {")": "(", "]": "[", "}": "{"}
        for char in s:
            if char in '([{':
                stack.append(char)
            else:
                if len(stack) == 0 or stack.pop() != map[char]:
                    return False
        return True if len(stack) == 0 else False
```

## 21. 合并两个有序链表（迭代 / 递归）

* 法一：迭代法

类似于归并排序的一趟

```py
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        node1, node2 = list1, list2
        cur=node3=ListNode()
        while node1!=None and node2!=None:
            if node1.val<node2.val:
                cur.next = node1
                node1 = node1.next
            else:
                cur.next = node2
                node2 = node2.next
            cur = cur.next
        cur.next = node2 if node1 == None else node1
        return node3.next

# @lc code=end
```

时间复杂度：`O(n+m)`，其中 `n` 和 `m` 分别为两个链表的长度。因为每次循环迭代中，`l1` 和 `l2` 只有一个元素会被放进合并链表中， 因此 `while `循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 `O(n+m)`。

空间复杂度：`O(1)`。我们只需要常数的空间存放若干变量。

* 法二：递归法

自己写：

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        res=ListNode()
        def merge(list1, list2, cur):
            if list1 == None:
                cur.next = list2
                return
            if list2 == None:
                cur.next = list1
                return
            if list1.val<list2.val:
                cur.next = list1
                merge(list1.next,list2,cur.next)
            else:
                cur.next = list2
                merge(list1, list2.next, cur.next)

        merge(list1, list2, res)
        return res.next
```

官方：

```py
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        if list1==None:
            return list2
        if list2==None:
            return list1
        if list1.val<list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2
```

时间复杂度：`O(n+m)`，其中 `n` 和 `m` 分别为两个链表的长度。因为每次调用递归都会去掉 `l1` 或者 `l2` 的头节点（直到至少有一个链表为空），函数 `mergeTwoList` 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即 `O(n+m)`。

空间复杂度：`O(n+m)`，其中 `n` 和 `m` 分别为两个链表的长度。递归调用 `mergeTwoLists` 函数时需要消耗栈空间，栈空间的大小取决于<font color='red'>递归调用的深度</font>。结束递归调用时 `mergeTwoLists` 函数最多调用 `n+m` 次，因此空间复杂度为 `O(n+m)`。

## 22. 括号生成（回溯 / 递归）

生成所有的组合问题，瞬间想到回溯

* 法一：回溯

思想：每一次添加到`path[]`中的值可能是`(`或者`)`，添加路径就可以构成一颗二叉树。利用回溯算法遍历所有的解空间可以轻易解决。

以下是未剪枝版本的回溯树

![image-20240304025409251](.\assets\image-20240304025409251.png)

```py
# 回溯模板
class Solution:
    def generateParenthesis(self, n: int) -> list[str]:
        res=[]
        path=[]
        # already_left_num：表示已经添加的（的个数，初始值为0
        # already_left_num：表示可以添加的）的个数，初始值为0
        def add(already_left_num,remain_left_num):
            # 剪枝
            if already_left_num == n and remain_left_num == 0:
                res.append(''.join(path))
                return
            # 添加（
            if already_left_num<n:
                path.append("(")
                add(already_left_num + 1, remain_left_num + 1)
                path.pop()
            # 回溯 添加）
            if remain_left_num>0:
                path.append(")")
                add(already_left_num, remain_left_num - 1)
                path.pop()
        add(0,0)
        return res
```

我们的复杂度分析依赖于理解 `generateParenthesis(n)`所形成的回溯树中有多少个元素。这个分析超出了本文的范畴，但事实证明这是第 `n` 个卡特兰数`h(n) = C(2n,n)/(n+1) (n=0,1,2,...)`,这是由 ` 4^n / n^(3/2)`, 渐近界定的。

时间复杂度：`O( 4^n / n^(3/2) )`在回溯过程中，每个答案需要 `O(n)`的时间复制到答案数组中。

空间复杂度：`O(n)`，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 `O(1)`的空间，最多递归 `2n`层，因此空间复杂度为 `O(n)`。

回溯代码2：

```py
class Solution:
    def generateParenthesis(self, n: int) -> list[str]:
        res = []

        def add(str,left,right):
            if left>right or left<0:
                return
            if left == 0 and right == 0:
                res.append(str)
            add(str + "(", left -1, right)
            add(str + ")", left, right - 1)

        add("", n, n)
        return res
```

* 法二：按括号序列的长度递归。在所有可能的位置加一对括号

```py
class Solution:
    def generateParenthesis(self, n: int) -> list[str]:
        if n==1:
            return ["()"]

        set_=set()
        # 将 () 插入每一个可能的位置，然后去重
        for item in self.generateParenthesis(n - 1):
            for i in range(len(item)+1):
                set_.add(item[0:i]+'()'+item[i:])
        return list(set_)
```



## 23. 合并 K 个升序链表（K路归并 vs 二路归并 vs 堆）

* 法一：利用递归法进行一次`k`路归并

```py
class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        min_node = ListNode(10000, None)
        min_index = 0
        None_time = 0
        for index, list_firstNode in enumerate(lists):
            if list_firstNode == None:
                None_time += 1
                continue
            if list_firstNode.val < min_node.val:
                min_node = list_firstNode
                min_index = index
        if None_time==len(lists):
            return None
        lists[min_index] = min_node.next
        min_node.next = self.mergeKLists(lists)
        return min_node
```

时间复杂度相当之高：假设有`k`条链表，链表的最大长度是`n`。一趟确定一个结点，一共有`nk`个结点，因此一共要`nk`趟。

而每趟需要比较`k`次才能确定一个结点。

因此一共的比较次数是`n * k^2`。

<font color='red'>最终的时间复杂度是：`O(k^2 * n)`</font>

![image-20240304182223818](.\assets\image-20240304182223818.png)

* 法二：败者树 / 堆

对于法一，每次从`k`路链表中选出一个最小的元素，时间复杂度是`O(k)`，我们可以用败者树将这个过程的时间复杂度降低为`O(logK)`

虽然`Python`标准库没有直接提供败者树`（Loser Tree）`的接口，但你可以使用`heapq`模块来模拟败者树的行为，从而快速实现`k`选`1`的问题。具体来说，你可以将k个序列的首个元素插入到最小堆中，然后每次从堆中取出最小值，并将该最小值所在序列的下一个元素（如果有的话）插入到堆中。这样，堆顶元素始终代表所有`k`个序列中的最小值。

```py
from typing import Optional, List
import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        res =cur= ListNode()
        # 堆实际上就是一颗完全二叉树，因此可以直接使用数组表示，heap是未建堆前的数组
        heap = [
            # (list_node.val, list_id, list_node)这个元组可以自定义，但是第一个元素必须是建堆的基准元素
            (list_node.val, list_id, list_node)
            for list_id, list_node in enumerate(lists)
            if list_node
        ]
        # 将heap这个列表建堆,建立的堆仍然顺序存储在heap这个列表中
        # heapq模块提供的heapify函数用于将一个列表转换为堆,使用heapq模块建立包含k个元素的堆的时间复杂度是O(k)
        heapq.heapify(heap)
        
        # 一旦堆被建立，你就可以使用heapq模块提供的其他函数（如heappush和heappop）来在堆上高效地执行插入和删除操作，这些操作的时间复杂度都是O(log k)。
        # 如果堆非空，那么就一直取出堆顶的最小元素
        while heap:
            # 取堆顶最小元素，并且调整堆
            value, list_id, list_node = heapq.heappop(heap)
            # 添加到结果链表中
            cur.next = list_node
            cur = cur.next
            
            # 将堆顶结点的下一个结点加入堆中，并且调整堆
            if list_node.next != None:
                next_value = list_node.next.val
                heapq.heappush(heap, (next_value, list_id, list_node.next))
        return res.next
```

一共有`nk`个元素（`n`是一条链表元素个数，`k`是链表条数），每从堆中取出一个元素的时间复杂度是`O(logk)`

时间复杂度：`O( nk * log(k) )`

![image-20240304201252763](.\assets\image-20240304201252763.png)

* 法三：进行多次二路归并，<font color='red'>这相当于一种分治的思想</font>

![img](.\assets\6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png)

如何根据该图分析时间复杂度，要按照数据结构中的**趟**来分析，以上二叉归并树一共有`k`个叶子结点，`k`是链表的个数。因此该树高度是`logK`这个量级。

该树的每一层都相当于是一趟归并，<font color='red'>把所有的元素都处理一遍叫一趟</font>.每趟的时间复杂度取决于所有结点的个数—`nk`。（假设每个链表的最长长度是 `n`）。

<font color='red'>因此总的时间时间复杂度：`O(nk * logk)`</font>

```py
from typing import Optional, List

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution:
    # 迭代二路归并
    def merge2Lists(self, list_1, list_2):
        node_1, node_2 = list_1, list_2
        res = cur = ListNode()
        while node_1 != None and node_2 != None:
            if node_1.val < node_2.val:
                cur.next = node_1
                node_1 = node_1.next
            else:
                cur.next = node_2
                node_2 = node_2.next
            cur = cur.next
        cur.next = node_1 if node_2 == None else node_2
        return res.next

    # 递归二路归并
    def mergeTwoLists(
        self, list1: Optional[ListNode], list2: Optional[ListNode]
    ) -> Optional[ListNode]:
        if list1 == None:
            return list2
        if list2 == None:
            return list1
        if list1.val < list2.val:
            list1.next = self.mergeTwoLists(list1.next, list2)
            return list1
        else:
            list2.next = self.mergeTwoLists(list1, list2.next)
            return list2

    # 以下是迭代合并，当然也可以用递归来完成
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        while True:
            length = len(lists)
            if length == 0:
                return None
            if length == 1:
                return lists[0]
            temp = []
            for i in range(0, length, 2):
                temp.append(
                    self.merge2Lists(lists[i], lists[i + 1] if i + 1 < length else None)
                )
            lists = temp

# @lc code=end
```

二路合并链表时，如果采用迭代合并，空间复杂度表现优异，若使用递归合并，空间复杂度表现较差：

迭代合并：

![image-20240304181806193](.\assets\image-20240304181806193.png)

递归合并：

![image-20240304181910573](.\assets\image-20240304181910573.png)



## 24. 两两交换链表中的节点（迭代 / 递归）

* 法一：迭代

简单的迭代一次链表即可，这里设置了一个哑巴头结点来保证所有的结点处理逻辑保持一致。

哑巴结点又叫哨兵结点

难点就在于搞清楚三个指针指向的切换，在纸上多画一下就可以解决

```py
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head == None or head.next == None:
            return head
        list = ListNode(0, head)
        left, mid, right = list, head, head.next
        while mid and right:
            left.next = right
            mid.next = right.next
            right.next = mid
            left = mid
            mid = mid.next
            if mid:
                right = mid.next
        return list.next

# @lc code=end
```

时间复杂度：`O(n)`，其中 `n`是链表的节点数量。需要对每个节点进行更新指针的操作。

空间复杂度：`O(1)`。

* 法二：递归

自己写的：

```py
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        def swap(left):
            if left.next == None or left.next.next == None:
                return
            mid, right = left.next, left.next.next
            left.next = right
            mid.next = right.next
            right.next = mid
            swap(mid)
        list = ListNode(0, head)
        swap(list)
        return list.next
```

官方：

```py
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        new_head=head.next
        head.next=self.swapPairs(new_head.next)
        new_head.next = head
        return new_head
```

## 25. K 个一组翻转链表（递归 / 迭代）

* 法一：迭代

尾插法：找到每组的头结点和尾结点，然后将头节点不断尾插即可翻转一组结点。然后再找到下一组的头节点和尾结点重复上面的操作即可

```py
from typing import Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head:
            return head
        list=ListNode(0,head)
        prev = next = list
        while True:
            for i in range(k):
                if next.next:
                    next = next.next
                else:
                    return list.next
            tag=prev.next
            for i in range(k-1):
                cur = prev.next
                if i==0:
                    tag=cur
                prev.next = cur.next
                cur.next = next.next
                next.next = cur
            prev = next = tag
# @lc code=end
```

![image-20240305010233316](.\assets\image-20240305010233316.png)

* 法二：递归

虽然这里用到了递归，但是空间复杂度不会太高，表现甚至优于上面的迭代。

这是因为递归的层数较少，空间复杂度是：`O(n/k)`

```py
class Solution:
    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
        if not head:
            return head
        prev = next = head
        for i in range(k - 1):
            if next.next:
                next = next.next
            else:
                return head
        next_prev = next.next
        cur=prev
        # 翻转prev和next之间的结点
        while cur!=next:
            tag=cur.next
            cur.next=next.next
            next.next=cur
            cur = tag
        prev.next = self.reverseKGroup(next_prev, k)
        return next
```

![image-20240305011650190](.\assets\image-20240305011650190.png)

## 26. 删除有序数组中的重复项（双指针）

空间复杂度：注意题目只能原地修改数组，不能申请额外的空间，空间复杂度限定：`O(1)`.

时间复杂度：移动数组元素是万万不可的，这题明显要在`O(n)`的时间复杂度内解决，移动元素的时间复杂度会远远超过这个量级。

遍历一次，时间复杂度`O(n)`，空间复杂度`O(1)`，这三个关键条件，立马想到双指针

* 法一：相邻的两个指针，若前后两个元素不一样，则`res+1`，并且将后面元素复制到`nums[res]`处

```py
from typing import List

# @lc code=start
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        length=len(nums)
        if length==0 or length==1:
            return length
        res=1
        for index in range(length):
            if index+1<length and nums[index]!=nums[index+1]:
                nums[res]=nums[index+1]
                res+=1
        return res
    
# @lc code=end
```

![image-20240305164923545](.\assets\image-20240305164923545.png)

* <font color=red>通用解法：快慢指针</font>，`fast`指针先扫描，若扫描到了一个不同的元素，就将其复制到`slow`慢指针的位置。

`fast`指针用来找到不同的数，`slow`指针用于将`fast`指针找到的不同的数填写到合适的位置。

时间复杂度也是：`O(n)`

```py
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        length = len(nums)
        if length == 0 or length == 1:
            return length
        # slow指针
        slow = 1
        # fast指针
        for fast in range(1, length):
            if nums[fast] != nums[fast - 1]:
                nums[slow] = nums[fast]
                slow += 1
        return slow
```

## 27. 移除元素（双指针）

* 法一：

比如：`Solution().removeElement([3, 2, 2, 3], 3)`

要删除`3`，从头到尾扫描一遍，如果遇到`3`，就往后找到一个不是`3`的数来代替`3`，并且将用来代替的那个数修改为`3`

但是这样做用到了双重循环，`j`指针可能会回退，时间复杂度达不到`O(n)`，而是`O(n^2)`.

但是这种`O(n^2)`的算法看起来表现还不错？

![image-20240305174333344](.\assets\image-20240305174333344.png)

```py
from typing import List

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        length = len(nums)
        for i in range(length):
            if nums[i] == val:
                flag = 0
                for j in range(i + 1, length):
                    if nums[j] != val:
                        nums[i] = nums[j]
                        nums[j] = val
                        flag = 1
                        break
                if flag==0:
                    return i
print(Solution().removeElement([3, 2, 2, 3], 3))
```

* 法二：

如何将时间复杂度降低到`O(n)`?

`j`指针一直往前，不能后退。例如：`Solution().removeElement([0,1,2,2,3,0,4,2], 2)`

`i`若扫描到`2`，那么往后找到一个`3`，将`3`填到`2`的位置，并且将`3`修改为`2`。

下一次`i`扫描到`2`的时候，`j`继续从`3`的位置往后找到`0`，重复上述操作

改进之后算法的时间复杂度为：`O(n)`

```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        length = len(nums)
        j = 0
        for i in range(length):
            if nums[i] == val:
                while j <= i or (nums[j] == val):
                    j += 1
                    if j == length:
                        return i
                nums[i] = nums[j]
                nums[j] = val
```

![image-20240305180359661](.\assets\image-20240305180359661.png)

<font color='red'>法三：通用解法，快慢指针</font>

设置`slow`，`fast`两个指针，`fast`指针探测下一个应该留下的元素，`slow`记录下一个该留下的元素应该写在哪里

时间复杂度：`O(n)`，其中 `n` 为序列的长度。我们只需要遍历该序列至多两次.

```py
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        length = len(nums)
        slow = 0
        for fast in range(length):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
        return slow
```

![image-20240305183646802](.\assets\image-20240305183646802.png)

## 28. 找出字符串中第一个匹配项的下标（KMP & 改进型KMP）

这实际上就是一个对主串和模式串进行模式匹配的问题

* 法一：暴力匹配

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        len1, len2 = len(haystack), len(needle)
        for index1 in range(len1):
            tmp = index1
            for index2 in range(len2):
                if tmp<len1 and haystack[tmp] == needle[index2]:
                    tmp += 1
                else:
                    break
            if tmp - index1 == len2:
                return index1
        return -1
```

一个时间复杂度为：`O(mn)`的算法（`m`是主串的长度，`n`是模式串的长度），实测表现居然这么好？

![image-20240305185058318](.\assets\image-20240305185058318.png)

* 法二：`kmp`算法，主串指针只会前进，不会回退

注意，这里的`next[0]`求出来和平时不一样，结合具体编码具体分析，但是最长相同前后缀的思路是相同的

```py
class Solution:
    def getNext(self, needle):
        length = len(needle)
        next = [0] * (length if length >= 2 else 2)
        next[0], next[1] = 0, 0
        for i in range(2, length):
            for j in range(1, i):
                if needle[j:i] == needle[0 : i - j]:
                    next[i] = i - j
                    break
        return next

    def strStr(self, haystack: str, needle: str) -> int:
        len1, len2 = len(haystack), len(needle)
        next = self.getNext(needle)
        i = j = 0
        while i < len1:
            while i<len1 and j < len2:
                if haystack[i] == needle[j]:
                    i += 1
                    j += 1
                else:
                    if j==0:
                        i += 1
                    j = next[j]
                    break
            if j==len2:
                return i - len2
        return -1
```

但是时间效率直线下降，甚至比不过暴力解法：

![image-20240305201419991](.\assets\image-20240305201419991.png)

但是这里求`next`数组的时间复杂度是：`O(n^2)`，（`n`是模式串的长度）

模式匹配的时间复杂度是：`O(m)`，（主串指针扫一遍即可）。

总的时间复杂度是：`O(m + n^2)`.

这个求`next`数组的过程可以优化到：`O(n)`吗？如果可以，总的时间复杂度就变成了：`O(m+n)`

* 优化的思路有点难，接下来会以图的方式展现：

如下图所示。已知`next[16]=8`，即图中蓝色方框内的前后缀完全相同。现在要求`next[17]`.

![image-20240305214045863](.\assets\image-20240305214045863.png)

* `next[j+1]`最多只能是`next[j]+1`.以下用`next[17]`和`next[16]`作为例子来证明：

`next[17]`最多只能是`next[16]+1=9`，以下是证明过程，若`next[17]=10`，则说明`1~9`和`8~16`相同，也可以说明`1~8`和`8-15`相同。那么`next[16]`就等于`9`。同样的，如果`next[17]=x>=10`，则说明`1 ~ x-1`和`18-x ~ 16`相同，也可以说明`1 ~ x-2`和`18-x ~ 15`相同，那么`next[16]`就等于`x-1 >= 9`。同题设`next[16]=8`相矛盾。由反证法得知`next[17]`最多等于`next[16]+1`。

* `next[j+1]`在什么时候等于`next[j]+1`？接下来还是用`next[17]`和`next[16]`来证明：

如上图所示，如果`P16=P8`,那么对于`next[17]`来说，最长相同前后缀显然长度加`1`，此时`next[j+1]=next[j]+1`

* 若`P16 != P8`，我们该如何处理？

此时我们可以缩小两个蓝色框框的宽度，也就是寻找长度更小的相同的前后缀。如下图所示：

![image-20240305215806440](.\assets\image-20240305215806440.png)



我们尝试着从最长的两个前后缀`C、D`，往内缩小，直到又找到前后缀`A`和`B`，`A、B`是除了`C、D`之外，长度最大而且相同的前后缀，那么我们怎么保证`A`和`B`是长度最长的呢?

奇妙的地方来了！！！！！

此时我们假设`A=B`，我们要找最长的`A`和`B`。由于`C`和`D`完全相同，那么`B`也应该和下图中的`E`完全相同。

![image-20240305220330727](.\assets\image-20240305220330727.png)

也就是说`A、E、B`三者完全相同。要寻找最长的`A、B`，就是寻找最长的`A、E`.

寻找最长的`A、E`，那不正就是`next[8]`所包含的内容吗？？？？？

我们这里不妨就认为`next[8]=4`,那么此时`A、B`就是除了`C、D`之外，最长而且相同的两个前后缀。

我们只需要继续判断`P4 == P16`，如果该等式成立，那么`next[17]`就等于`4+1=5`。如果该等式不成立，那么继续重复以上的步骤即可，直到找到`next[k]=-1`,那么`next[17] = -1+1 =0`

改进后的求`next`数组代码如下：

```py
class Solution:
    def getNext(self, needle):
        length = len(needle)
        next = [0] * (length if length >= 2 else 2)
        next[0], next[1] = -1, 0
        for i in range(2, length):
            k = next[i - 1]
            while k != -1 and needle[k] != needle[i - 1]:
                k = next[k]
            next[i] = k + 1
        return next

    def strStr(self, haystack: str, needle: str) -> int:
        len1, len2 = len(haystack), len(needle)
        next = self.getNext(needle)
        i = j = 0
        while i < len1:
            while i < len1 and j < len2:
                if haystack[i] == needle[j] or j == -1:
                    i += 1
                    j += 1
                else:
                    j = next[j]
                    break
            if j == len2:
                return i - len2
        return -1
```

![image-20240305223052511](.\assets\image-20240305223052511.png)

此时的时间复杂度：`O(m+n)`

* 法3：改进型的`kmp`算法。对于`next`数组，我们还有机会将其优化成`nextVal`数组`nextVal`的求法如下

```py
    def getNextVal(self,needle):
        length = len(needle)
        nextVal = [0] * (length if length >= 2 else 2)
        nextVal[0], nextVal[1] = -1, 0
        for i in range(2, length):
            k = nextVal[i - 1]
            while k != -1 and needle[k] != needle[i - 1]:
                k = nextVal[k]
            tmp=k+1
            while tmp >= 0 and needle[tmp] == needle[i]:
                tmp = nextVal[tmp]
            nextVal[i] = tmp
        return nextVal
```

注意，以上做法是错误的，如果生成`next`的同时去生成`nextVal`，由于生成`nextVal`的逻辑会改变`next`数组里的值，从而反过来对`next`本身值的生成造成影响。因此必须先得到`next`数组，然后再对齐加工得到`nextVal`数组。

正确代码如下：

```py
class Solution:

    def getNext(self, needle):
        length = len(needle)
        next = [0] * (length if length >= 2 else 2)
        next[0], next[1] = -1, 0
        for i in range(2, length):
            k = next[i - 1]
            while k != -1 and needle[k] != needle[i - 1]:
                k = next[k]
            next[i] = k + 1
        return next

    def getNextVal(self,needle):
        next=self.getNext(needle)
        for i in range(2,len(next)):
            tmp=next[i]
            while needle[i] == needle[tmp] and tmp >= 0:
                tmp = next[tmp]
            next[i] = tmp
        return next

    def strStr(self, haystack: str, needle: str) -> int:
        len1, len2 = len(haystack), len(needle)
        next = self.getNextVal(needle)
        i = j = 0
        while i < len1:
            while i < len1 and j < len2:
                if haystack[i] == needle[j] or j == -1:
                    i += 1
                    j += 1
                else:
                    j = next[j]
                    break
            if j == len2:
                return i - len2
        return -1


print(Solution().strStr("mississippi", "issip"))
# @lc code=end
```

## 29. 两数相除（快速乘 + 二分）

被除数：`dividend`，除数：`divisor`。

* 法一：我们需要查到到一个数`z`，使得：`divisor * z < dividend < divisor * (z+1)`。显然，这个查找过程使用二分查找是最快的，时间复杂度可以达到`O(logn)`，否则顺序查找的时间复杂度是`O(n)`。

但是题目要求不能使用乘、除、取模运算。因此我们只能使用加、减法运算。

我们可以想到利用加减法实现快速乘，代码如下：

```py
class Solution:
    def fastMultiple(self, a, b):
        res = 0
        while b >= 1:
            if b & 1 == 1:
                res += a
            a += a
            b >>= 1
        return res

    def divide(self, dividend: int, divisor: int) -> int:
        Max, Min = (1 << 31) - 1, 1 << 31
        positive = (dividend > 0 and divisor > 0) or (divisor < 0 and dividend < 0)
        dividend, divisor = abs(dividend), abs(divisor)
        if dividend < divisor:
            return 0
        left, right, mid, tmp, res = 1, dividend, 1, divisor, 1
        while left <= right:
            # 不能使用除法
            mid = (left + right) >> 1
            tmp = self.fastMultiple(divisor, mid)
            if tmp > dividend:
                # 等于mid-1而不是mid
                right = mid - 1
            elif tmp < dividend:
                # 若mid>=Max，那么下一次在mid右边区域继续二分一定会越界，直接返回
                if mid >= Max and positive:
                    return Max
                if mid >= Min and not positive:
                    return -Min
                # 等于mid+1而不是mid
                left = mid + 1
            else:
                res = mid
                break
        res = right if tmp > dividend else mid
        return res if positive else -res
```

![image-20240307190228942](.\assets\image-20240307190228942.png)

时间复杂度：`O(log⁡C ^ 2)`，其中 `C` 表示 `32` 位整数的范围。二分查找的次数为 `O(log⁡C)`，其中的每一步我们都需要 `O(log⁡C)` 使用「快速乘」算法判断 `Z×Y≥X` 是否成立，因此总时间复杂度为 `O(log⁡C ^ 2)`

空间复杂度：`O(1)`

坑点：然后就是坑点了, 如何转换使两数同号, 因为对应符号不同的两数, 除法实际上是需要加法模拟的, 为了统一用减法模拟, 需要进行符号转换, 这里千万注意数据范围最小是`-2147483638`, 因此如果转换为正数, 会很悲惨的溢出, 所以需要转换为负数.但是对于`python`来说，整型没有规定的精度，因此都转化为正数也没关系

* 法二：若一次一次地让被减数`+1`，复杂度太高了，因此我们试着让被减数翻倍来比较

  举个例子，现要求`11/3`

  > 11 - 3 = 8 > 0，则说明商 > 1
  >
  > 11 - 3+3 = 5 > 0，则说明商 > 2
  >
  > 11 - 6+6 = -1 < 0，则说明商 < 4
  >
  > 以上说明商在 2-4 之间，那我们不妨先商2，看看商2之后剩下的余数除以3可以商几，比如
  >
  > 11 - 3*2 = 5，之后再加上 5/3 的商即可，此时则可以用递归

  * 递归实现

  ```py
  class Solution:
      def divide(self, dividend: int, divisor: int) -> int:
          Max, Min = (1 << 31) - 1, 1 << 31
          positive = (dividend > 0 and divisor > 0) or (divisor < 0 and dividend < 0)
          dividend, divisor = abs(dividend), abs(divisor)
          if dividend < divisor:
              return 0
          cnt, tmp = 1, divisor
          while dividend >= tmp:
              tmp += tmp
              cnt <<= 1
          res = (cnt >> 1) + self.divide(dividend - (tmp >> 1), divisor)
          if positive and res > Max:
              return Max
          if not positive and res > Min:
              return -Min
          return res if positive else -res
  ```

  时间复杂度接近：`O(logN)`

  * 迭代实现

  ```py
  class Solution:  
      def divide(self, dividend: int, divisor: int) -> int:  
          if dividend == 0:  
              return 0  
            
          is_negative = (dividend < 0) ^ (divisor < 0)  
          dividend = abs(dividend)  
          divisor = abs(divisor)  
          result = 0  
            
          # 和上面一样的思路，只不过递归变成了迭代
          while dividend >= divisor:  
              temp, i = divisor, 1  
              while dividend >= temp << 1:  
                  temp <<= 1  
                  i <<= 1  
              dividend -= temp  
              result += i  
            
          # 处理剩余部分  
          if dividend > divisor // 2:  
              result += 1  
            
          if is_negative:  
              result = -result  
            
          # 处理溢出情况  
          return min(result, 2**31 - 1) if result > 0 else max(result, -2**31)
  ```

* 法三：模拟无符号二进制数的除法

  ![image-20240308020654884](.\assets\image-20240308020654884.png)

  商一共有五位

  第一位商`1`：就相当于除数`1001 * 2^4`，即`1001 << 4 = 10010000`

  然后求得第一个余数：`10110110 - 10010000 = 100100 `

  第二位商`0`：若第二位商`1`，就相当于除数`1001 * 2^3 = 1001 << 3 = 1001000`，比余数`100100`更大，因此第二位只能商0

  第三位商`1`：就相当于除数`1001 * 2^2 = 1001 << 2 = 100100`

  然后球的第二个余数：`100100 - 100100 = 0`

  因此商就等于`2^4 + 2^2 = 10100`

  

  因此我们就得到了二进制代码求商的思路，（商是二进制）：

  按照除法规则，我们需要商一个最高位的`1`，这个最高位的`1`可以将除数向左移位成一个小于被除数的最大数

  ```py
  class Solution:
      def divide(self, dividend: int, divisor: int) -> int:
          positive = (dividend > 0) == (divisor > 0)
          dividend, divisor, res = abs(dividend), abs(divisor), 0
  
          # 依次确定最高位到最低位商几
          for i in range(32, -1, -1):
              # 除数左移i位之后终于小于被除数，第 i+1 位商 1
              if divisor << i <= dividend:
                  # i+1 位商1就是 2^i，这一步实际上是在二进制转十进制
                  res += 1 << i
                  # 求得一个余数，再作为被除数
                  dividend -= divisor << i
          return min(res, (1 << 31) - 1) if positive else max(-1 << 31, -res)
  ```

  

## 30. 串联所有单词的子串（滑动窗口+哈希表）

首先想办法生成所有的串联子串，排列组合的问题首先想到两种方法：回溯 和 递归

* 法一：回溯

  用一个数组记录下已经访问过的结点

  ```py
  class Solution:
      def findSubstring(self, s: str, words: List[str]) -> List[int]:
          length = len(words)
          res = []
          path = [""] * length
  		
          # 用一个数组，来记录dfs时一个元素是否已经被遍历过
          traveled = [False] * length
  
          def dfs(i):
              if i == 3:
                  res.append("".join(path))
                  return
  
              for j in range(length):
                  if not traveled[j]:
                      path[i] = words[j]
                      traveled[j] = True
                      dfs(i + 1)
                      traveled[j] = False
          dfs(0)
          return res
  ```

  如何分析回溯法的时间复杂度？

  回溯树的层数是`words.length`，假设第一层的结点个数是`1`.第二层`m`，第三层`m*(m-1)`，第四层`m*(m-1)*(m-2)`...最下面一层`m!`.

  然而，对于分析算法的时间复杂度而言，我们通常关注的是叶子结点的数量，因为它们代表了所有可能的输出（在这个例子中是所有可能的排列）。因此，尽管树的结点总数远大于`m!`，算法的时间复杂度仍然是`O(m!)`，因为我们需要生成所有`m!`个排列。这里的时间复杂度是由输出的大小（即排列的数量）决定的，而不是由树中所有结点的数量决定的

* 法二：递归

  ```py
  class Solution:
      def findSubstring_1(self, words: List[str]) -> List[int]:
          def find_array(words):
              length = len(words)
              if length == 1:
                  return [words]
              temp = find_array(words[1:])
              res = []
              for i in range(len(temp)):
                  for j in range(len(temp[i]) + 1):
                      res.append([*(temp[i][0:j]), words[0], *temp[i][j:]])
              return res
          array = find_array(words)
          return ["".join(item) for item in array]
  ```


得到所有的串联子串之后再用`kmp`算法进行模式匹配，找到所有串联子串的起始位置。但是这样做的时间复杂度很高。

`kmp`算法的时间复杂度是`O(m+n)`。`n`表示模式串的长度，`m`表示主串的长度。

假设`p`是`words`的长度

求`next`数组的时间复杂度是`O(n)`。进行模式匹配的时间复杂度是`O(m+n)`。

总的时间复杂度是：`O(p！*（m+n）)`

所以上面得到所有串联子串之后再进行模式匹配的方法行不通，我们需要转换思路。

* 法三：双指针+哈希表

思路：首先利用一个字典`map`记录下`words`中每个单词的出现次数。

然后将主串`s`划分为一个一个单词。划分方法有多种，例如

`s="aaabbbcccdddeeefff"`,每个单词的长度为`3`，那么就有三种单词的划分方式：

1. 从下标`0`开始划分：`aaa、bbb、ccc、ddd、eee、fff`
2. 从下标`1`开始划分：`aab、bbc、ccd、dde、eef`
3. 从下标`2`开始划分：`abb、bcc、cdd、dee、eff`

分析可知，单词`word`的长度为`n`，那么就有`n`种单词的划分方式

分别单独处理所有的划分方式，以第一种划分方式为例：

每次往后读取一个单词，若其存在于字典`map`,而且剩余个数大于`1`，那就将该单词加入到当前字符串，并且将对应单词数`-1`，再去检查下一个单词。

若读取的单词不存在于字典或者该单词剩余的个数不够了，则说明当前字符串匹配失败，紧接着从字符串前面舍弃一个单词，并且将其数目`+1`，再去检查最后一个单词是否匹配。

以此往复，直到当前字符串长度达到要求，则成功匹配到一个串联子串。

```py
from typing import List

# 实现深拷贝
from copy import deepcopy

class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        len_s, len_word, len_words = len(s), len(words[0]), len(words)
        res = []
        len_str = len_word * len_words
        map = dict()
        for word in words:
            if word in map:
                map[word] += 1
            else:
                map[word] = 1


        # 将s划分为一个一个单词，从下标0~len_word-1划分即可
        for i in range(0, len_word):
            if len_s - i < len_str:
                return res
        
            # 深拷贝一份
            map_tmp=deepcopy(map)

            p, q = i, i + len_word
            while p < q and q <= len_s:
                tmp = s[q - len_word : q]
                if tmp in map_tmp and map_tmp[tmp] >= 1:
                    if q-p==len_str:
                        res.append(p)
                    map_tmp[tmp] -= 1
                    q += len_word
                else:
                    if q - p == len_word:
                        p = q
                        q += len_word
                    else:
                        map_tmp[s[p : p + len_word]] += 1
                        p += len_word

        return res
```

时间复杂度分析：假设`word`长度为`n`，`s`长度为`m`

那么外层循环次数是`n`次，内层使用了双指针，遍历次数是`m`这个数量级。

因此总的时间复杂度是：`O(m*n)`



## 31. 下一个排列（双指针）

解题原则：

1. 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。

2. 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

思路，找到下一个排列，应该尽量从个位、十位往高位找。

比如说一个序列为`9835421`，那么我们尽量变动低位，这样能保证得到的下一个排列不会变动太多。我们设置一个`i`指针指向末尾往前面扫，`1—2—4—5`一直扫到`5`，过程中得到的`1`、`21`、`421`、`5421`都无法再变大，因为它已经是最大的了。

当我们扫描到`3`时，我们发现`3<5`，此时`35412`这个序列有调整的空间，它可以变得更大。但是对于`5412`来说，已经无法变得更大了，因此我们需要用一个更大的数来替换掉`3`，这样`35412`才能变得更大，但是又不能变得太大，否则会违反“下一个排列”。

因此我们从5开始往后寻找，找到一个大于`3`的最小数为`4`，我们用`4`和`3`进行替换之后得到`98 4 5321`。按照上述替换规则`5321`必定是升序的。

但是此时`4 5321`并不是以`4`开头最小的。又因为`5321`必定是升序排序，我们将他变得最小，只需要进行逆转即可。最后得到`4 1235`

因此最终结果为`9841235`

```py
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        length=len(nums)
        i = length - 1
        while i-1>=0 and nums[i-1]>=nums[i]:
            i-=1
        if i == 0:
            self.reverse(0,length-1,nums)
            return nums

        tag = length - 1
        for j in range(i,length):
            if nums[j]<=nums[i-1]:
                tag = j - 1
                break
        nums[i-1],nums[tag]=nums[tag],nums[i-1]
        self.reverse(i, length - 1, nums)
        return nums

    # 将nums[i]~nums[j]进行逆转，使用双指针即可
    def reverse(self,i,j,nums):
        if i < 0 or j > len(nums) - 1 or i > j:
            return False
        while i<j:
            nums[i],nums[j]=nums[j],nums[i]
            i += 1
            j -= 1
        return True
```

时间复杂度分析：`O(n)`



## 32. 最长有效括号（动态规划/栈/贪心）

* 法一：动态规划

  思路：依次求出以`s[i]`结尾的最长符合要求的子串。

  比如`()()(())`，`arr=[0,2,0,4,0,0,2,8]`

  当遇到`(`时，`arr[i]=0`，因为以`(`结尾，肯定无法形成有效的括号。

  当求`s[i+1]`且为`)`时，需要用到`s[i]`的信息。通过`s[i]`我们可以知道以上一个字符结尾的最长有效子串`str`.

  我们试着判断`str`之前是否是`(`，若是，则和`s[i+1]`配对成功。`arr[i+1]`不仅要在`arr[i]`的基础上`+2`，更有可能连接起了前面的有效括号，因此还要加`arr[index - 1]`.

  若`str`之前不是`(`，与当前的`s[i+1]=)`匹配不成功，那我们必须证明`arr[i+1]=0`，这里用反证法来证明。

  `s[i+1]`必不可能与`str`内的`(`匹配成功，因为`str`内的(已经被`str`内的`)`消耗完毕了

  `s[i+1]`必不可能与`str`外的`(`匹配成功，因为如果匹配成功，则说明去掉最外层的一对括号，内部依旧是有效括号，那么`str`的长度应该更大.

  `s[i+1]`只可能和`str`前一个字符匹配成功。

  ```py
  class Solution:
      def longestValidParentheses(self, s: str) -> int:
          length = len(s)
          res = 0
          arr = [0] * length
          for i in range(0, length):
              if s[i] == ")":
                  # 边界条件
                  index = -1
                  if i - 1 >= 0:
                      index = i - 1 - arr[i - 1]
                  if index < 0:
                      continue
  
                  tmp = s[index]
                  if tmp == "(":
                      # 状态转移方程
                      arr[i] = arr[i - 1] + 2 + arr[index - 1]
                      res = res if res > arr[i] else arr[i]
          return res
  ```

* 法二：贪心

  `()()()()))`

  遇到`(`，则左括号数目+1；遇到`)`，则右括号数目+1

  当右括号数目等于左括号时，表示成功匹配一对，当前括号对数+1

  当左括号数目大于右括号时，继续往后扫描

  当左括号数目小于右括号时，表示出现了失配，直接将左右括号数目全部设置为0，当前括号对数也变成0，并且继续往后扫描

  贪心算法的正确性证明：

  当前括号为什么可以直接设置为0？当出现）失配时，前面难道不可能会有一个（与之匹配吗？若存在，按照贪心规则，）前面的都匹配成功，那么对于之前的（，一定存在一个）将其消耗了，轮不到当前的这个）。

  这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算

  

  <font color='red'>但是这种贪心算法并不是最优解，漏了类似于`(()`的情况，此时右括号数目永远不可能等于左括号，但是显然存在一对匹配的括号。</font>

  因此我们按照上面类似的规则，从右往左遍历一遍即可

  ```py
  class Solution:
      def longestValidParentheses(self, s: str) -> int:
          res = 0
          left = right = 0
          for char in s:
              if char == "(":
                  left += 1
              else:
                  right += 1
                  if right == left:
                      res = res if res > left * 2 else left * 2
                  elif right > left:
                      left = 0
                      right = 0
  
          left=right=0
          for char in s[::-1]:
              if char == ")":
                  right += 1
              else:
                  left += 1
                  if right == left:
                      res = res if res > left * 2 else left * 2
                  elif right < left:
                      left = 0
                      right = 0
  
          return res
  ```

* 法三：栈

  例子：`(()()`

  当匹配到一个`(`时，直接入栈

  当匹配到一个多余的`)`时（没有`(`与之匹配），将其放到栈底，表示上一次匹配失败的位置

  当匹配到一个不多余的`)`，弹出一个`(`，并且当前长度为`index-stack.top`

  ```py
  class Solution:
      def longestValidParentheses(self, s: str) -> int:
          tmp = res = 0
          stack = list()
          # 栈底 存放上一次匹配失败的）的下标，-1作为哨兵下标
          stack.append(-1)
          # 每次栈底元素出栈，就表示当前次匹配到头了
          for index, char in enumerate(s):
              if char == "(":
                  stack.append(index)
              else:
                  top = stack.pop()
                  length = len(stack)
                  if length == 0:
                      stack.append(index)
                  else:
                      tmp = index - stack[length - 1]
              res = res if res > tmp else tmp
  
          return res
  ```




## 33. 搜索旋转排序数组（二分）

* 法一：

思想：先使用类似于二分查找的方法得到数组中的断点位置，然后在该断点位置的左边或者右边进行二分查找即可。

因为该断点的左边是递增的，该断点的右边也是递增的

总体的时间复杂度都在：`O(logn)`这个数量级

<font color='red'>二分法的难点在于细节：while循环条件是怎么样的？left、right修改后的值应该是怎么样的？应该用严格小于还是小于等于？各种条件一定要判断清除</font>

```py
class Solution:
    def search_binary(self, nums, left, right, target):
        while left <= right:
            mid = (left + right) // 2
            tmp = nums[mid]
            if tmp == target:
                return mid
            elif tmp < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1

    def search(self, nums: List[int], target: int) -> int:
        length = len(nums)
        if length == 1:
            if nums[0] == target:
                return 0
            else:
                return -1
        left_val, right_val = nums[0], nums[length - 1]
        left, right = 0, length - 1
        position = -1
        while left <= right:
            mid = (left + right) // 2
            tmp = nums[mid]
            if tmp > nums[mid + 1]:
                position = mid
                break
            if tmp >= left_val and tmp <= right_val:
                position = length - 1
                break
            elif tmp >= left_val and tmp > right_val:
                left = mid + 1
            elif tmp < left_val and tmp <= right_val:
                right = mid - 1
        if target >= left_val:
            return self.search_binary(nums, 0, position, target)
        else:
            return self.search_binary(nums, position + 1, length - 1, target)
```



* 法二：

首先进行二分，左右两边必定有一侧是完全有序的，另外一侧半有序。

现在完全有序的一侧进行二分查找，找到则返回，找不到则在半有序的一侧再次二分，按照上述规则继续查找。

法二和法一的时间复杂度在同一个数量级，但是实际表现比法一优秀很多

```py
class Solution:
    def search_binary(self, nums, left, right, target):
        while left <= right:
            mid = (left + right) // 2
            tmp = nums[mid]
            if tmp == target:
                return mid
            elif tmp < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1

    def search(self, nums: List[int], target: int) -> int:
        length = len(nums)
        left, right = 0, length - 1
        # 这里其实可以用递归，因为每次的操作都是相同的
        # 但是这里用到了迭代的写法，最终效果都是一样的
        while left <= right:
            mid = (left + right) // 2
            tmp_1 = nums[mid]
            if tmp_1 == target:
                return mid
            if tmp_1 >= nums[0] and tmp_1 <= nums[length - 1]:
                return self.search_binary(nums, 0, length - 1, target)
            if tmp_1 >= nums[0] and tmp_1 > nums[length - 1]:
                tmp_2 = self.search_binary(nums, left, mid - 1, target)
                if tmp_2 != -1:
                    return tmp_2
                else:
                    left = mid + 1
            elif tmp_1 < nums[0] and tmp_1 <= nums[length - 1]:
                tmp_3 = self.search_binary(nums, mid + 1, right, target)
                if tmp_3 != -1:
                    return tmp_3
                else:
                    right = mid - 1
        return -1
```





## 34. 在排序数组中查找元素的第一个和最后一个位置（二分）

先查找目标元素，若不存在，返回[-1,1]

若存在，递归查找其最靠左/右边的相同元素，方法是在其左/右边区域不断进行二分查找，直到找不到为止

* 法一：递归法

```py
class Solution:
    def searchBinary(self, nums: List[int], target: int, left, right) -> List[int]:
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid - 1
            elif nums[mid] < target:
                left = mid + 1
        return -1

	
    # 递归法查找左边界，其实可以转化为迭代，用一个while循环即可
    def search_boundary(self, nums, target, mid, isLeft):
        # isLeft为True表示在mid左边查找，isLeft为False表示在mid右边查找
        tmp = self.searchBinary(
            nums, target, *((0, mid - 1) if isLeft else (mid + 1, len(nums) - 1))
        )
		# 在mid的左边进行二分查找，如果找不到，那么mid就是左边界
        if tmp == -1:
            return mid
        else:
            return self.search_boundary(nums, target, tmp, isLeft)

    def searchRange(self, nums: List[int], target: int) -> List[int]:
        tmp = self.searchBinary(nums, target, 0, len(nums) - 1)
        if tmp == -1:
            return [-1, -1]
        return [
            self.search_boundary(nums, target, tmp, True),
            self.search_boundary(nums, target, tmp, False),
        ]
```

* 法二：迭代法

```py
class Solution:
    def searchBinary(self, nums: List[int], target: int, left, right) -> List[int]:
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid - 1
            elif nums[mid] < target:
                left = mid + 1
        return -1

    def searchRange(self, nums: List[int], target: int) -> List[int]:
        length = len(nums)
        tmp = self.searchBinary(nums, target, 0, len(nums) - 1)
        if tmp == -1:
            return [-1, -1]
        else:
            tmp_left = tmp_right = tmp
            while True:
                tmp_1 = self.searchBinary(nums, target, 0, tmp_left - 1)
                if tmp_1 != -1:
                    tmp_left = tmp_1
                else:
                    break

            while True:
                tmp_2 = self.searchBinary(nums, target, tmp_right + 1, length - 1)
                if tmp_2 != -1:
                    tmp_right = tmp_2
                else:
                    break

            return [tmp_left, tmp_right]
```



## 35. 搜索插入位置（二分）

简单二分查找即可

```py
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        length = len(nums)
        left, right = 0, length - 1
        while left <= right:
            mid = (left + right) // 2
            tmp = nums[mid]
            if tmp == target:
                return mid
            elif tmp < target:
                left = mid + 1
            else:
                right = mid - 1
        # 如果最后mid=left=right大于目标值，right为mid-1，此时插入位置为left；如果mid小于目标值，left为mid+1，此时插入位置为left。
        return left
```

关于二分法一个注意的点

```py
mid = (left+right)//2
# 为了防止left+right溢出，求mid常常用另外一种做法
mid = left + (right-left)>>1
# 下面的方法使用了减法和移位进行配合
```



## 36. 有效的数独（哈希表空间换时间）

典型时间换空间。

判断每行中没有相同元素，为其设置一个`set`

判断每列没有相同的元素，为其设置一个`set`

判断每个小方框中没有相同的元素，为九个小框每个设置一个`set`.

```py
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        tmp_1 = set()
        tmp_2 = set()
        tmp_3 = [set() for i in range(0, 9)]
        for i in range(0, 9):
            tmp_1.clear()
            tmp_2.clear()
            for j in range(0, 9):
                tmp_4 = 3 * (i // 3) + (j // 3)
                if (
                    (board[i][j] in tmp_1 and board[i][j] != ".")
                    or (board[j][i] in tmp_2 and board[j][i] != ".")
                    or (board[i][j] in tmp_3[tmp_4] and board[i][j] != ".")
                ):
                    print(i, j, board[i][j], board[j][i])
                    return False
                else:
                    tmp_1.add(board[i][j])
                    tmp_2.add(board[j][i])
                    tmp_3[tmp_4].add(board[i][j])
        return True
```

最终时间复杂度：`O(n^2)`



## 37. 解数独（哈希+回溯）

遇到这种尝试所有可能的题目，首先想到回溯，回溯其实就是和银行家算法相同，先试着往下，发现错误就回溯

* 法一：无脑回溯

```py
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        # 表示某一列还未被使用到的元素
        row_remian = [
            set(["1", "2", "3", "4", "5", "6", "7", "8", "9"]) for i in range(0, 9)
        ]
        # 表示某一行还未被使用到的元素
        column_remain = [
            set(["1", "2", "3", "4", "5", "6", "7", "8", "9"]) for i in range(0, 9)
        ]
        # 表示某一块还未被使用到的元素
        square_remain = [
            set(["1", "2", "3", "4", "5", "6", "7", "8", "9"]) for i in range(0, 9)
        ]

        # 遍历一遍数独表，将出现了的元素从上述三张表中剔除
        for i in range(0, 9):
            for j in range(0, 9):
                # 元素[i][j]处于第square_index块
                square_index = 3 * (i // 3) + (j // 3)
                tmp = board[i][j]
                if tmp != ".":
                    # 从第i行未出现的元素中剔除
                    row_remian[i].remove(tmp)
                    # 从第j列未出现的元素中剔除
                    column_remain[j].remove(tmp)
                    # 从第square_index块未出现的元素中剔除
                    square_remain[square_index].remove(tmp)
		
        # 统计所有 '.' 元素的坐标到tmp中
        tmp = []
        for i in range(0, 9):
            for j in range(0, 9):
                if board[i][j] == ".":
                    tmp.append([i, j])
        length = len(tmp)
		
        # 对于这种罗列所有可能性的问题，通常使用回溯算法，回溯算法的思想和我们尝试赋值的思想一致，可以一次一次尝试
        def dfs(high):
            # high表示当前正在处理tmp[high]
            if high == length:
                # 如果处理到了最后一个元素都没有出现错误，则说明找到了唯一的数独解，返回True
                return True
            # 获取坐标
            i, j = tmp[high]
            # 获取块号
            square_index = 3 * (i // 3) + (j // 3)
            # 所在行、列、块剩余元素集合，三个集合求交集就是当前位置可能的元素集合
            remain = row_remian[i] & column_remain[j] & square_remain[square_index]
            # 如果当前位置没有可填入的元素，则说明当前路径失败，返回False，向上回溯
            if len(remain) == 0:
                return False
            else:
                # 遍历当前位置可能填入的元素
                for ele in remain:
                    board[i][j] = ele
                    # 填入之后修改相应行、列、块剩余元素表
                    row_remian[i].remove(ele)
                    column_remain[j].remove(ele)
                    square_remain[square_index].remove(ele)
                    # 向下递归，处理下一个 '.'
                    res = dfs(high + 1)
                    # 如果下一次处理返回 False，则说明当前填入的元素不合理
                    if res == False:
                        # 恢复相应行、列、块剩余元素表，并且填入其他可能的元素
                        row_remian[i].add(ele)
                        column_remain[j].add(ele)
                        square_remain[square_index].add(ele)
                    else:
                        # dfs函数第一次返回True，必定是high==length，找到了一种可能的解
                        # 此时其他可能填入的元素都不用尝试了，直接返回True，因为已经找到了唯一解
                        return True
                # 如果把当前层所有可能填入的元素都试过了，还没有返回True，则说明上一层的元素选错了，返回False回溯即可
                # 这样上一层会填入其他元素
                board[i][j] = "."
                return False

        dfs(0)
```

* 改进版

```py
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        row_remian = [
            set(["1", "2", "3", "4", "5", "6", "7", "8", "9"]) for i in range(0, 9)
        ]
        column_remain = [
            set(["1", "2", "3", "4", "5", "6", "7", "8", "9"]) for i in range(0, 9)
        ]
        square_remain = [
            set(["1", "2", "3", "4", "5", "6", "7", "8", "9"]) for i in range(0, 9)
        ]

        for i in range(0, 9):
            for j in range(0, 9):
                square_index = 3 * (i // 3) + (j // 3)
                tmp = board[i][j]
                if tmp != ".":
                    row_remian[i].remove(tmp)
                    column_remain[j].remove(tmp)
                    square_remain[square_index].remove(tmp)

        # 一个优化：先确定仅仅只有一种可能的元素
        while True:
            tag = False
            for i in range(0, 9):
                for j in range(0, 9):
                    square_index = 3 * (i // 3) + (j // 3)
                    tmp = board[i][j]
                    if tmp == ".":
                        remain = (
                            row_remian[i]
                            & column_remain[j]
                            & square_remain[square_index]
                        )
                        if len(remain) == 1:
                            tag = True
                            cur = remain.pop()
                            board[i][j] = cur
                            row_remian[i].remove(cur)
                            column_remain[j].remove(cur)
                            square_remain[square_index].remove(cur)

            if tag == False:
                break

        tmp = []
        for i in range(0, 9):
            for j in range(0, 9):
                if board[i][j] == ".":
                    tmp.append([i, j])
        length = len(tmp)

        # 利用回溯法解决余下无法处理的位置
        def dfs(high):
            if high == length:
                return True
            i, j = tmp[high]
            square_index = 3 * (i // 3) + (j // 3)
            remain = row_remian[i] & column_remain[j] & square_remain[square_index]
            if len(remain) == 0:
                return False
            else:
                for ele in remain:
                    board[i][j] = ele
                    row_remian[i].remove(ele)
                    column_remain[j].remove(ele)
                    square_remain[square_index].remove(ele)
                    res = dfs(high + 1)
                    if res == False:
                        row_remian[i].add(ele)
                        column_remain[j].add(ele)
                        square_remain[square_index].add(ele)
                    else:
                        return True
                board[i][j] = "."
                return False

        dfs(0)
```

优化算法2直接击败 100% 的用户

![image-20240408194153840](.\assets\image-20240408194153840.png)

* 优化三：上述我们申请了很多集合来记录一个数在某行、列、块是否出现过，空间复杂度比较高，其实我们有方法可以减少复杂度

若我们使用长度为 `9` 的数组表示每个数字是否出现过。我们同样也可以借助位运算，仅使用一个整数表示每个数字是否出现过。

具体地，数 `b` 的二进制表示的第 `i` 位（从低到高，最低位为第 `0` 位）为 `1`，当且仅当数字 `i+1` 已经出现过。例如当 `b` 的二进制表示为 `(011000100)2` 时，就表示数字 `3`，`7`，`8` 已经出现过。

然后我们就可以使用与、或、非、异或等运算来求交集等等



## 38. 外观数列（打表法）

* 法一：

多迭代几次即可

```py
class Solution:
    def countAndSay(self, n: int) -> str:
        res = "1"
        for i in range(0, n - 1):
            times = 1
            index = 1
            tmp = ""
            while index <= len(res):
                if index == len(res) or res[index] != res[index - 1]:
                    tmp += f"{times}{res[index-1]}"
                    times = 1
                else:
                    times += 1
                index += 1
            res = tmp
        return res
```

时间复杂度：`O(N×M)`，其中 `N` 为给定的正整数，`M` 为生成的字符串中的最大长度。

空间复杂度：`O(M)`。其中 `M` 为生成的字符串中的最大长度。

* 法二：无脑打表

由于`1 <= n <= 30`，只需要将前`30`个外观数列记录下来即可

> 基操，我当年打比赛的时候，就这样过过题，直接暴力超时，答案的数据量小，就可以打表过。甚至，如果答案太多放不下，还可以分块打表过题

```py
class Solution:
    def countAndSay(self, n: int) -> str:
        arr = ["","1","11","21","1211","111221","312211","13112221",...]
        return arr[n]
```



## 39. 组合总和（回溯）

* 法一：简单回溯

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res=[]
        tmp=[]
        def dfs(remain):
            if remain==0:
                res.append([*tmp])
                return
            if remain<candidates[0]:
                return

            for num in candidates:
                if num>target:
                    break
                else:
                    tmp.append(num)
                    dfs(remain-num)
                    tmp.pop()
        dfs(target)
        return res

print(Solution().combinationSum([2,3,6,7],7))
# [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]
```

此时会出现以上bug，之前提到过，除去重复解的方式是只允许往后选择数

* 改进：单向取数去除重复解

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        tmp = []
        length = len(candidates)
        # 输入数组并不是有序的，因此需要事先排序
        # 排序的时间复杂度不会超过后续处理的时间复杂度，大胆排序即可
        candidates.sort()

        def dfs(i, remain):
            if remain == 0:
                res.append([*tmp])
                return
            if remain < candidates[0]:
                return

            for index in range(i, length):
                # 每次只能选择下标>=i的元素
                num = candidates[index]
                if num > target:
                    break
                else:
                    tmp.append(num)
                    dfs(index, remain - num)
                    tmp.pop()

        dfs(0, target)
        return res
```

* 法三：还可以不排序

```py
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        tmp = []
        length = len(candidates)
        minValue = min(candidates)

        def dfs(i, remain):
            if remain == 0:
                # 传递的是拷贝
                res.append([*tmp])
                return
            if remain < minValue:
                return

            for index in range(i, length):
                num = candidates[index]
                # 当前数比remain更大，则直接跳
                if num > remain:
                    # 排序用break，不排序用continue
                    continue
                else:
                    tmp.append(num)
                    dfs(index, remain - num)
                    tmp.pop()

        dfs(0, target)
        return res
```

复杂度分析：对于分析算法的时间复杂度而言，我们通常关注的是叶子结点的数量或者总结点的数量，因为它们代表了所有可能的输出。

时间复杂度：`O(S)`，其中 `S`为所有可行解的长度之和。从分析给出的搜索树我们可以看出时间复杂度取决于搜索树所有叶子节点的深度之和，即所有可行解的长度之和。

空间复杂度：`O(target)`。除答案数组外，空间复杂度取决于递归的栈深度，在最差情况下需要递归 `O(target)` 层。

回溯树如下：

![fig1](.\assets\39_fig1.png)

当然，搜索回溯的过程一定存在一些优秀的剪枝方法来使得程序运行得更快，而这里只给出了最朴素不含剪枝的写法



## 40. 组合总和 II（回溯+去重）

* 法一：基于39的改进，使用到了排序版本，以及去重常用操作

```py
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        tmp = []
        length = len(candidates)
        # 输入数组并不是有序的，因此需要事先排序
        # 排序的时间复杂度不会超过后续处理的时间复杂度，大胆排序即可
        candidates.sort()

        def dfs(i, remain):
            if remain == 0:
                res.append([*tmp])
                return
            if remain < candidates[0]:
                return

            # 由于一个位置的数不能重复，所以下标需要变成i+1
            for index in range(i + 1, length):
                # 每次只能选择下标>=i的元素
                num = candidates[index]
                # [1,1,2,5,6,7,10]，当前回溯层选择了第一个1之后就要跳过第二个1，否则就会出现重复解
                # 因此当 candidates[index]==candidates[index - 1]，时，就需要continue
                # 但是以上做法会出现一个问题，假如target=2，那么一个可行的解是 [1,1]（分别选择了第一个和第二个1）
                # 但是这个判断会让第二层无法选择第二个1，而是被continue
                # 由于第二层是从i+1往后选数，因此检查的前提条件是 index-1>=i+1，才不会使得第二层选择第二个1时被跳过
                if index >= 1 and num == candidates[index - 1] and index-1 >= i + 1:
                    continue
                if num > target:
                    break
                else:
                    tmp.append(num)
                    dfs(index, remain - num)
                    tmp.pop()

        dfs(-1, target)
        return res
```



## 41. 缺失的第一个正数（原地哈希）

在`Python`中，当你申请一个长度为`n`的字符串时，该字符串会占用与`n`成正比的内存空间。因此，空间复杂度是`O(n)`，而不是`O(1)`。还有一种方法，申请指定位数的二进制串，某一位起到和哈希表一样的作用，可惜这在`python`中是无法实现的。

而此题的难点在于，如何在空间复杂度为`O(1)`的情况下解决？若不限制空间复杂度，那我们直接申请一个长度为`n`的哈希表进行映射即可。但是违反题意。

「真正」满足时间复杂度为 `O(N)` 且空间复杂度为 `O(1)` 的算法是不存在的，但是我们可以退而求其次：利用给定数组中的空间来存储一些状态。也就是说，如果题目给定的数组是不可修改的，那么就不存在满足时空复杂度要求的算法；但如果我们可以修改给定的数组，那么是存在满足要求的算法的。

仔细想一想，我们为什么要使用哈希表？这是因为哈希表是一个可以支持快速查找的数据结构：给定一个元素，我们可以在 `O(1)` 的时间查找该元素是否在哈希表中。因此，我们可以考虑将给定的数组设计成哈希表的「替代产品」。



* 法一：原地哈希，将输入的`nums`数组作为哈希表，但是为了避免数据的覆盖需要进行一些额外操作

```py
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        # 数组长度为 n，那么最小未出现的数 target <= n+1
        # 若 target>n+1，那么 1~n+1 都必须出现过，数组长度 >= n+1
		# 我们将所有在 [1,N] 范围内的数放入哈希表，也可以得到最终的答案。而给定的数组恰好长度为 N
        length = len(nums)
		
        # 若要将num哈希到nums[num-1],那就必须把num-1位置的数据也哈希走
        for index, num in enumerate(nums):
            while True:
                if num <= 0 or num > length or nums[num - 1] == num:
                    break
                elif num - 1 < index:
                    nums[num - 1] = num
                    break
                else:
                    tmp_1 = nums[num - 1]
                    nums[num - 1] = num
                    num = tmp_1

        for index, num in enumerate(nums):
            if index + 1 != num:
                return index + 1

        return length + 1
```

但是这种方法的实际表现却不是很好，时间复杂度比较高，可能是`while`循环带来了额外的时间开销

![image-20240410175251984](.\assets\image-20240410175251984.png)

* 法二：

  我们对数组进行遍历，对于遍历到的数 `x`，如果它在 `[1,N]` 的范围内，那么就将数组中的第 `x−1` 个位置（注意：数组下标从 `0` 开始）打上「标记」。在遍历结束之后，如果所有的位置都被打上了标记，那么答案是 `N+1`，否则答案是最小的没有打上标记的位置加 `1`。

  那么如何设计这个「标记」呢？由于数组中的数没有任何限制，因此这并不是一件容易的事情。但我们可以继续利用上面的提到的性质：由于我们只在意 `[1,N]` 中的数，因此我们可以先对数组进行遍历，把不在 `[1,N]` 范围内的数修改成任意一个大于 `N` 的数（例如 `N+1`）。这样一来，数组中的所有数就都是正数了，因此我们就可以将「标记」表示为「负号」。算法的流程如下：

  1. 我们将数组中所有小于等于 `0` 的数修改为 `N+1`；

  2. 我们遍历数组中的每一个数 `x`，它可能已经被打了标记，因此原本对应的数为 `∣x∣`，其中 `| |` 为绝对值符号。如果 `∣x∣∈[1,N]|`，那么我们给数组中的第 `∣x∣−1` 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；

  3. 在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 `N+1`，否则答案是第一个正数的位置加 `1`。

  ```py
  class Solution:
      def firstMissingPositive(self, nums: List[int]) -> int:
          length = len(nums)
          for index, num in enumerate(nums):
              if num <= 0 or num > length:
                  nums[index] = length + 1
  
          for index, num in enumerate(nums):
              tmp = abs(num)
              if tmp <= length:
                  if nums[tmp - 1] > 0:
                      nums[tmp - 1] = -nums[tmp - 1]
  
          for index, num in enumerate(nums):
              if num > 0:
                  return index + 1
  
          return length + 1
  ```

  但是时间效率还是不高：

  ![image-20240410182045618](.\assets\image-20240410182045618.png)

  



## 42. 接雨水（动态规划/双指针/单调栈）

* 法一：

看一个时间复杂度较高的做法：

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        length = len(height)
        i, j, res, tmp = 0, 0, 0, 0
        while i < length:
            
            # 每当遇到一个height[i] <= height[i + 1]，表示遇到了一个左边界i
            if i + 1 < length and height[i] <= height[i + 1]:
                i += 1
                continue

            # j往右尝试寻找右边界
            j = i + 1
            # 可疑右边界，初始值为-1
            tmp = -1
            while j < length:
                # 如果j处的高度大于左边界，那么直接将其设置为右边界
                if height[j] >= height[i]:
                    break
				# 如果高度递减，那么j一定不是右边界，继续往后探查
                while j + 1 < length and height[j + 1] < height[j]:
                    j += 1
                    
				# 如果探查到最后都是递减，则直接返回，认为可疑tmp就是右边界
                if j + 1 == length:
                    break
				# 更新可疑右边界
                if tmp == -1:
                    # 第一次直接更新
                    tmp = j + 1
                else:
                    # 如果违反递减处的高度比可疑右边界更高，那么更新可疑右边界，否则不更新
                    tmp = j + 1 if height[j + 1] >= height[tmp] else tmp
                # 更新tmp之后，j继续往后探查可疑右边界
                j = j+1
			# tmp是其右边界
            if tmp != -1:
                short = min(height[i], height[tmp])
                while i < tmp:
                    # 此时可能会出现 8 6 4 5, 左边界可能会出现一些错误，因此若rest<0，直接+0
                    rest = short - height[i]
                    res += rest if rest > 0 else 0
                    i += 1
            # 如果最后都没有右边界，则说明此时对应的左边界之后高度全部递减，无法存储雨水            
        	else:
                break

        return res
```

> - 322/322 cases passed (7925 ms)
> - Your runtime beats 5.01 % of python3 submissions
> - Your memory usage beats 70.73 % of python3 submissions (17.9 MB)

遇到一种情况`[10000,0,9999,0,9998,0,9997,0,9996,0,9995,0...,0,1]`，每次确定一个左边界之后，探测右边界时都需要找到数组末尾，时间复杂度：`O(n^2)`

* 法二：动态规划

对于下标 `i`，下雨后水能到达的最大高度等于下标 `i` 两边的最大高度的最小值，下标 `i` 处能接的雨水量等于下标` i`处的水能到达的最大高度减去 `height[i]`。

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        length = len(height)
        # maxLeft[i]表示 i 左边的最大高度
        # maxRight[i]表示 i 右边的最大高度
        maxLeft, maxRight = [0] * length, [0] * length
        for i in range(1, length):
            maxLeft[i] = (
                height[i - 1] if height[i - 1] > maxLeft[i - 1] else maxLeft[i - 1]
            )
            maxRight[length - 1 - i] = (
                height[length - i]
                if height[length - i] > maxRight[length - i]
                else maxRight[length - i]
            )

        res = 0
        for i in range(1, length - 1):
            tmp = min(maxLeft[i], maxRight[i]) - height[i]
            res += tmp if tmp > 0 else 0
        return res
```

> - 322/322 cases passed (60 ms)
> - Your runtime beats 39.92 % of python3 submissions
> - Your memory usage beats 39.1 % of python3 submissions (18.1 MB)

* 法三：双指针，继续优化空间复杂度

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        length = len(height)
        LeftMax, rightMax = height[0], height[length - 1]
        left, right = 1, length - 1
        res = 0
        while left <= right:
            # 左Max < 右Max，则说明左边更容易限制当前处水的高度
            if LeftMax < rightMax:
                # 说明Left处的 左边最大高度 小于 右边最大高度
                if height[left] < LeftMax:
                    # 当前处可以蓄水，加上当前水高
                    res += LeftMax - height[left]
                else:
                    # 当前处更高，无法蓄水，则更新左边最大高度
                    LeftMax = height[left
                left += 1
            # 右Max < 左Max，则说明右边更容易限制当前处水的高度
            else:
                # 说明Right处的 右边最大高度 小于 左边最大高度
                if height[right] < rightMax:
                    # 当前处可以蓄水，加上当前水高
                    res += rightMax - height[right]
                else:
                    # 当前处更高，无法蓄水，则更新右边最大高度
                    rightMax = height[right]
                right -= 1
        return res
```

> - 322/322 cases passed (41 ms)
> - Your runtime beats 95.68 % of python3 submissions
> - Your memory usage beats 70.73 % of python3 submissions (17.9 MB)

* 法三：单调栈

```py
class Solution:
    def trap(self, height: List[int]) -> int:
        # res表示雨水量
        res = 0
        length = len(height)
        # 一个单调递减栈，存放的是下标
        stack = []
        for i in range(0, length):
            # 满足单调递减，则入栈
            if len(stack) == 0 or height[stack[-1]] >= height[i]: # 利用[-1]快速获得最后一个元素
                # 将下标入栈
                stack.append(i)
            else:
                # 将不满足递减的栈顶元素全部出栈
                while len(stack) >= 1 and height[stack[-1]] < height[i]:
                    # 每出栈一个元素，就增加一些雨水的体积

                    # 获取底边高度
                    lower = height[stack.pop()]
                    # 若底边出栈之后，左边界为空，无法蓄水，直接跳出
                    if len(stack) == 0:
                        break
                    # 有效高度取决于短板效应
                    higher = min(height[stack[-1]], height[i])
                    # 该蓄水区的宽度
                    width = i - stack[-1] - 1
                    # 该蓄水区的体积
                    res += (higher - lower) * width
                # 入栈
                stack.append(i)
        return res
```

> - 322/322 cases passed (50 ms)
> - Your runtime beats 76.19 % of python3 submissions
> - Your memory usage beats 77.61 % of python3 submissions (17.8 MB)

![image-20240415163544193](.\assets\image-20240415163544193.png)

单调栈存储下标，可以很快得到图中每一块颜色区域的左下标和右下标，进一步可以得到宽度`width`

而上边界`higher`取决于左右两边的短板效应

下边界`lower`取决于当前出栈位置的高度



## 43. 字符串相乘（模拟乘法/加法）

注意点：不能直接转整数，因为直接转整数可能会溢出，但是可以对每一位单独转整数

* 法一：做加法：

```py
class Solution:
    def accumulate(self, num1: str, num2: str):
        length1, length2 = len(num1), len(num2)
        if length1 > length2:
            num2 = "0" * (length1 - length2) + num2
        else:
            num1 = "0" * (length2 - length1) + num1

        carrier = 0
        length = len(num1)
        res = ""
        for i in range(length - 1, -1, -1):
            acc = int(num1[i]) + int(num2[i]) + carrier
            res = f"{acc%10}{res}"
            carrier = acc // 10
        res = ("1" if carrier == 1 else "") + res
        return res

    def multiply(self, num1: str, num2: str) -> str:
        if num1=='0' or num2=='0':
            return '0'
        
        res=''
        a = 0
        for num_str1 in num1[::-1]:
            carrier = 0
            tmp = ""
            for num_str2 in num2[::-1]:
                mul = int(num_str1) * int(num_str2) + carrier
                tmp = f"{mul%10}{tmp}"
                carrier = mul // 10
            tmp = f"{'' if carrier==0 else carrier}{tmp}" + "0" * a
            a += 1
            res=self.accumulate(res,tmp)
        return res
```

时间复杂度：`O(mn+n^2)`，其中 `m` 和 `n` 分别是 `num1`  和 `num2` 的长度。需要从右往左遍历 `num2`,对于 `num2`的每一位，都需要和 `num1`  的每一位计算乘积，因此计算乘积的总次数是 `mn`。字符串相加操作共有 `n` 次，相加的字符串长度最长为 `m+n`，因此字符串相加的时间复杂度是 `O(mn+n^2)` .总时间复杂度是 `O(mn+n^2)`

* 法二：用一个整型数组存放结果的每一位

  首先证明`m`位整数和`n`位整数相乘，结果位数不超过`m+n`位，这个很容易证明，因此可以用一个`m+n`位的数组·`res`存放最终结果

  将每次相乘的结果及时更新到`res`数组中即可

  ```py
  class Solution:
      def multiply(self, num1: str, num2: str) -> str:
          if num1 == "0" or num2 == "0":
              return "0"
  
          length1, length2 = len(num1), len(num2)
          res = [0] * (length1 + length2)
  
          for index_1, num_str1 in enumerate(num1[::-1]):
              position = length2 + length1 - 1 - index_1
              for index_2, num_str2 in enumerate(num2[::-1]):
  
                  # 方法一：res数组中每一位必须小于10，也就是说写入某一位的值若超过10，则需要理解向上一位传递一个1
                  position_cur = position - index_2
                  mul = int(num_str1) * int(num_str2)
                  tmp1 = res[position_cur] + mul % 10
                  res[position_cur] = tmp1 % 10
                  tmp2 = res[position_cur - 1] + mul // 10 + tmp1 // 10
                  res[position_cur - 1] = tmp2 % 10
                  res[position_cur - 2] += tmp2 // 10
  
          return "".join(map(str, res)).lstrip("0")
  ```

  当然还有另外一种方法，就是将结果无脑加到`res`的对应位置，最后统一一次性处理进位等问题

  ```py
  class Solution:
      def multiply(self, num1: str, num2: str) -> str:
          if num1 == "0" or num2 == "0":
              return "0"
  
          length1, length2 = len(num1), len(num2)
          res = [0] * (length1 + length2)
  
          for index_1, num_str1 in enumerate(num1[::-1]):
              position = length2 + length1 - 1 - index_1
              for index_2, num_str2 in enumerate(num2[::-1]):
                  position_cur = position - index_2
                  mul = int(num_str1) * int(num_str2)
                  res[position_cur] += mul
  
          # 方法2：集中一次性处理进位问题
          for i in range(length1 + length2-1, 0, -1):
              tmp = res[i]
              res[i] = tmp % 10
              res[i - 1] += tmp // 10
  
          return "".join(map(str, res)).lstrip("0")
  ```

  时间复杂度：`O(mn)`，其中 `m` 和 `n` 分别是 `num1` 和 `num2` 的长度。需要计算 `num1`的每一位和 `num2`的每一位的乘积。

  

## 44. 通配符匹配（递归+备忘录 / 动态规划 / 贪心）

* 法一：初始版本，使用递归

```py
class Solution:
    cache = dict()

    def isMatch(self, s: str, p: str) -> bool:
        if s == p or p == "*":
            return True

        if len(p) == 0 and len(s) != 0:
            return False

        if len(s) == 0 and p[0] != "*":
            return False

        if p[0] == "?":
            return self.isMatch(s[1:], p[1:])
        elif p[0] == "*":
            # 改进：多个连续的'*'只需当作一个进行匹配即可
            index = 0
            while index < len(p) and p[index] == "*":
                index += 1
            return self.isMatch(s, p[index:]) or (
                len(s) > 0 and self.isMatch(s[1:], p[index - 1 :])
            )
            # 匹配两个可以看作先匹配两个一个然后再匹配0个
            # 正所谓一生二，二生三，三生万物
        else:
            return False if p[0] != s[0] else self.isMatch(s[1:], p[1:])
```

这种写法会重复递归判断很多个相同的`s`和`p`，某些情况会出现超时，因此使用一个备忘录将子问题的结果记录下来，从而进行优化

* 方法2：备忘录

```py
class Solution:
    cache = dict()

    def isMatch(self, s: str, p: str) -> bool:
        if s == p or p == "*":
            return True

        if len(p) == 0 and len(s) != 0:
            return False

        if len(s) == 0 and p[0] != "*":
            return False

        key = f"{s},{p}"
        if key in self.cache:
            return self.cache[key]

        if p[0] == "*":
            index = 0
            while index < len(p) and p[index] == "*":
                index += 1

            cur = self.isMatch(s, p[index:]) or (
                len(s) > 0 and self.isMatch(s[1:], p[index - 1 :])
            )

        else:
            isMatch = self.isMatch(s[1:], p[1:])
            cur = isMatch if p[0] == "?" else (False if p[0] != s[0] else isMatch)

        self.cache[key] = cur
        return cur
```

使用备忘录之后，虽然不会超时，但是时间效率依然较低，而且备忘录的开销非常大，达到了六百多`MB`

> - 1811/1811 cases passed (1406 ms)
> - Your runtime beats 6.1 % of python3 submissions
> - Your memory usage beats 5.05 % of python3 submissions (652.8 MB)

有时候还会内存超了：

> ## Memory Limit Exceeded
>
> - 1811/1811 cases passed (N/A)

优化方法，将`s`和`p`这个字符串作为字典的`key`太过于占用内存，因此考虑使用其他`key`

```py
class Solution:

    def isMatch(self, s: str, p: str) -> bool:
        length1, length2 = len(s), len(p)
        cache = dict()

        def dfs(index1, index2):
            if index2 >= length2:
                return index1 >= length1
            if index1 >= length1 and p[index2] != "*":
                return False

            key = f"{index1},{index2}"
            if key in cache:
                return cache[key]

            if p[index2] == "*":
                index = index2
                while index < len(p) and p[index] == "*":
                    index += 1
                
                # 这里使用朴素的方法，依次匹配0~最大数目
                cur=any(dfs(si_, index ) for si_ in range(index1, length1 + 1))
            else:
                isMatch = dfs(index1 + 1, index2 + 1)
                cur = (
                    isMatch
                    if p[index2] == "?"
                    else (False if p[index2] != s[index1] else isMatch)
                )

            cache[key] = cur
            return cur

        return dfs(0, 0)
```

> ## Time Limit Exceeded
>
> - 1738/1811 cases passed (N/A)

还是有少量用例超时

* 方法三：装饰器实现备忘录

```py
class Solution:

    def isMatch(self, s: str, p: str) -> bool:
        length1, length2 = len(s), len(p)

        @cache
        def dfs(index1, index2):
            if index2 >= length2:
                return index1 >= length1
            if index1 >= length1 and p[index2] != "*":
                return False

            if p[index2] == "*":
                index = index2
                while index < len(p) and p[index] == "*":
                    index += 1

                return any(dfs(si_, index) for si_ in range(index1, length1 + 1))
            else:
                isMatch = dfs(index1 + 1, index2 + 1)
                return (
                    isMatch
                    if p[index2] == "?"
                    else (False if p[index2] != s[index1] else isMatch)
                )


        return dfs(0, 0)
```

> - 1811/1811 cases passed (1400 ms)
> - Your runtime beats 6.31 % of python3 submissions
> - Your memory usage beats 12.4 % of python3 submissions (95.1 MB)

其实递归也可以做到较优秀的时空复杂度，但是需要精细的剪枝，因此还可以用别的方法

* 方法四：动态规划

话不多说，直接看代码：

```py
class Solution:
    # 模式串 p，主串 s
    def isMatch(self, s: str, p: str) -> bool:
        # 获取主串和模式串的长度
        len_s, len_p = len(s), len(p)

        # 处理特殊情况
        if len_p == 0:
            # 若模式串为空，则主串必须为空
            return len_s == 0
        if len_s == 0:
            # 若主串为空，那么模式串中只能含有 '*'
            for char_p in p:
                if char_p != "*":
                    return False
            return True

        # 设置二维 dp 数字，dp[i][j] 表示 s[0:i+1] 和 p[0:j+1] 是否匹配，初始值全部设置为 False
        # 横向是主串 s，纵向是模式串 p
        dp = [[False] * len_s for i in range(len_p)]

        # 设置初始值
        dp[0][0] = (s[0] == p[0]) or (p[0] in ["?", "*"])

        for i in range(0, len_p):
            for j in range(0, len_s):
                # 单独解决第一行
                if i == 0:
                    if j != 0:
                        dp[i][j] = p[0] == "*"
                    continue

                # 单独解决第一列
                if j == 0:
                    # 当 j==0，即主串为 s[0] 时，模式串中不能出现 '*','?',s[0] 之外的字符
                    # 而且 '?' 和 s[0] 只能出现一次
                    dp[i][j] = True
                    cnt = 0
                    for char in p[0 : i + 1]:
                        if char not in ["?", "*", s[0]]:
                            dp[i][j] = False
                            break
                        elif char in ["?", s[0]]:
                            cnt += 1
                            if cnt > 1:
                                dp[i][j] = False
                                break
                    continue

                # 模式串 p i，进行状态转移
                if dp[i - 1][j - 1]:
                    dp[i][j] = p[i] in ["?", "*", s[j]]
                elif dp[i][j - 1]:
                    if p[i] == "*":
                        dp[i][j] = True
                    elif p[i] == "?":
                        # 若 '?' 没有与任何主串中的字符串匹配，那么在 dp[i][j-1]==True 的情况下
                        # dp[i-1][j-1] 也定为 True，因此'?'必存在相应字符与其匹配
                        dp[i][j] = False
                    else:
                        # 假设一种情况：p[i] 为一个字母，且 dp[i][j]==True 成立，那么 p[i] 必然与 s[j] 相同，因此 dp[i-1][j-1]==True 成立，不会进入该分支
                        # 因此，p[i] 为一个字母时，dp[i][j]==False 成立
                        dp[i][j] = False
                elif not dp[i][j - 1]:
                    # 假设一种情况： dp[i][j-1]==False，dp[i][j]==True
                    # 若 p[i]=[a-z]，那么必然 p[i]=s[j] 相匹配，故 dp[i-1][j-1]==True 成立，不会进入该分支，因此 p[i]!=[a-z]
                    # 若 p[i]='?'，如果这个'?'匹配到了相应的字符，同理 dp[i-1][j-1]==True 成立，但是此题中'?'不能匹配空串
                    # 若 p[i]='*'，如果'*'匹配到了一个字符，则dp[i-1][j-1]==True 成立；如果匹配到了更多的字符，则 dp[i][j-1]==True 成立
                    # 综上所示，dp[i][j-1]==False，dp[i][j]==True 的必要条件为：p[i]只能为 '*' ，而且匹配不到任何字符
                    # 若满足这个必要条件，那么 dp[i-1][j] 必为 True
                    if p[i] != "*":
                        dp[i][j] = False
                    else:
                        dp[i][j] = dp[i - 1][j]
            # 使用循环打印二维数组
        for row in dp:
            for element in row:
                print(element, end=" ")
            print()  # 在每一行结束后换行

        return dp[len_p - 1][len_s - 1]
```

以下是简化版：

```py
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        # 获取子串，模式串长度
        len_s, len_p = len(s), len(p)

        # 处理特殊情况
        if len_p == 0:
            return len_s == 0
        if len_s == 0:
            for char_p in p:
                if char_p != "*":
                    return False
            return True

        # 初始化 dp 数组
        dp = [[False] * len_s for i in range(len_p)]
        dp[0][0] = (s[0] == p[0]) or (p[0] in ["?", "*"])

        # 状态转移
        bool1 = p[0] == "*"
        for i in range(0, len_p):
            for j in range(0, len_s):
                # 单独确定第一行
                if i == 0:
                    if j != 0:
                        dp[i][j] = bool1
                    continue

                # 单独确定第一列
                if j == 0:
                    dp[i][j] = True
                    cnt = 0
                    for char in p[0 : i + 1]:
                        if char not in ["?", "*", s[0]]:
                            dp[i][j] = False
                            break
                        elif char in ["?", s[0]]:
                            cnt += 1
                            if cnt > 1:
                                dp[i][j] = False
                                break
                    continue

                if dp[i - 1][j - 1]:
                    dp[i][j] = p[i] in ["?", "*", s[j]]
                elif dp[i][j - 1]:
                    if p[i] == "*":
                        dp[i][j] = True
                    else:
                        dp[i][j] = False
                elif not dp[i][j - 1]:
                    dp[i][j] = False if p[i] != "*" else dp[i - 1][j]

        return dp[len_p - 1][len_s - 1]
```

![image-20240908105706506](.\assets\image-20240908105706506.png)

易知，动态规划的时间复杂度是 O(m*n)

* 方法五：贪心算法

> 贪心不像是动态规划有一种具体的套路，它是一种解决问题的思想

因此，如果模式 p 的形式为 * u1 * u2 * u3 * ... * ux，即字符串（可以为空）和星号交替出现，并且首尾字符均为星号，那么我们就可以设计出下面这个基于贪心的暴力匹配算法。算法的本质是：如果在字符串 s 中首先找到 u1，再找到 u2, u3, ⋯, ux，那么 s 就可以与模式 p 匹配。这样「贪心地」找到最早出现的子串是比较直观的，因为如果 s 中多次出现了某个子串，那么我们选择最早出现的位置，可以使得后续子串能被找到的机会更大。

```py
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        def allStars(st: str, left: int, right: int) -> bool:
            return all(st[i] == '*' for i in range(left, right))
        
        def charMatch(u: str, v: str) -> bool:
            return u == v or v == '?'

        sRight, pRight = len(s), len(p)
        while sRight > 0 and pRight > 0 and p[pRight - 1] != '*':
            if charMatch(s[sRight - 1], p[pRight - 1]):
                sRight -= 1
                pRight -= 1
            else:
                return False
        
        if pRight == 0:
            return sRight == 0
        
        sIndex, pIndex = 0, 0
        sRecord, pRecord = -1, -1
        while sIndex < sRight and pIndex < pRight:
            if p[pIndex] == '*':
                pIndex += 1
                sRecord, pRecord = sIndex, pIndex
            elif charMatch(s[sIndex], p[pIndex]):
                sIndex += 1
                pIndex += 1
            elif sRecord != -1 and sRecord + 1 < sRight:
                sRecord += 1
                sIndex, pIndex = sRecord, pRecord
            else:
                return False

        return allStars(p, pIndex, pRight)
```

对于每一个被星号分隔的、只包含小写字符和问号的子模式 ui，我们在原串中使用的是暴力匹配的方法。然而这里是可以继续进行优化的，即使用 AC 自动机 代替暴力方法进行匹配，AC自动机中的一个重要的组成部分就是 KMP 模式匹配算法

## 78. 子集（回溯dfs）

和<a href='#'>17</a>类似，都是使用了回溯算法，但是此题的回溯树是一颗二叉树

* 思路一：分支节点的左孩子表示选择当前元素，分支节点的右孩子表示不选择当前元素，<font color='red'>只有叶节点是答案</font>

> dfs(i)—>dfs(i+1)：表示子集中是否添加第`i`个元素—>子集中是否添加第`i+1`个元素

![image-20240301195109713](.\assets\image-20240301195109713.png)

```py
class Solution:
    def subsets(self, nums: list[int]) -> list[list[int]]:
        res, path = [], []
        length = len(nums)

        # 深度优先：先序遍历
        def dfs(i):
            if i==length:
                # 浅拷贝
                res.append(path.copy())
                return
            
            # 根 左 右
            else:
                # 左边的路径：添加当前元素
                path.append(nums[i])
                dfs(i + 1)
                # 回退回来时，需要把添加的当前元素弹出
                path.pop()

                # 右边的路径：不添加当前元素
                dfs(i + 1)

        dfs(0)

        return res
```

时间复杂度：二叉树的节点个数：`O( 2^(n+1) - 1 )`

空间复杂度：二叉树的高度：`O(n)`



* 思路二：依旧是回溯，每次都需要选一个数，<font color='red'>每个节点都是答案</font>

> dfs(i)—>dfs(i+1)：表示子集中`i`个元素—>子集中`i+1`个元素

![image-20240301195218322](.\assets\image-20240301195218322.png)

```py
class Solution:
    def subsets(self, nums: list[int]) -> list[list[int]]:
        res, path = [], []
        length = len(nums)

        # dfs(i)表示子集中元素的个数
        def dfs(i):
            if i == length + 1:
                return
            # i=0时，直接将长度为0的path数组作为结果
            res.append(path.copy())

            # i=0时，接下来需要dfs(1),任意将一个元素加入子集，但是后加入子集的元素必须在先加入子集的元素之后，防止出现[1,2]和[2,1]两个相同的子集，这里再次认识到，有序是去重的一个重要方式
            for index in range(i,length):
                path.append(nums[index])
                # 注意，这里只能是dfs(index + 1)而不能是dfs(i+1)，这样才能保证有序，不会出现重复子集
                dfs(index + 1)
                path.pop()

        dfs(0)

        return res
```

时间复杂度：`O(2^n)`，二叉树的总节点更少，时间复杂度更加优秀.

![image-20240301201927187](.\assets\image-20240301201927187.png)

空间复杂度：二叉树的高度：`O(n)`.



## 739. 每日温度（动态规划 / 单调栈）

* 法一：动态规划

  ```py
  class Solution:
      def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
          length = len(temperatures)
          res = [0] * length
          
          # res[length-1]=0，从后往前进行动态规划
          for i in range(length - 2, -1, -1):
              tmp = temperatures[i]
              next_pos = i + 1
              # 若i+1处直接大于i，那么res[i]=1
              if tmp < temperatures[next_pos]:
                  res[i] = 1
                  continue
  			# 否则需要不断往后寻找更大的，正好借助res数组的自身性质
              # i~next_pos之间的元素必定都比i处的值更小
              while tmp >= temperatures[next_pos]:
                  distance = res[next_pos]
                  if distance == 0:
                      res[i] = 0
                      break
                  next_pos += distance
              if distance != 0:
                  res[i] = next_pos - i
          return res
  ```

  ![image-20240414163309199](.\assets\image-20240414163309199.png)

* 法二：单调栈



























































































































