# :taco: VPN

速鹰666：https://suying666.net/auth/login

账号：1813560139@qq.com

密码：`dqcyz20081103`

记得打开`v2rayng` `http`代理全局模式

![image-20240107163847169](.assets\image-20240107163847169.png)

经典问题：

>500 Internal Privoxy Error
>Privoxy encountered an error while processing your request:
>Could not load template file no-server-data or one of its included components.
>Please contact your proxy administrator.
>If you are the proxy administrator, please put the required file(s)in the (confdir)/templates directory. The location of the (confdir) directory is specified in the main Privoxy config file. (It's typically the Privoxy install directory).

> 我最近也遇到了这样的问题，买了新电脑，v2ray不能用梯子，后来发现是新电脑的时间跟标准时间相差了几分钟，把时间校准了一下就好了，希望能帮到你。

# :alembic:  Python & VScode

## :baby_chick: Python环境

> python安装网址：https://www.python.org/downloads/
>
> ![image-20240105120750180](.\assets\image-20240105120750180.png)

#### 多环境python共存

##### 1. 将多版本的python安装到某个目录

![image-20240105123113463](.\assets\image-20240105123113463.png)

##### 2. 修改python.exe文件为具体版本

> 例如：python3.12.exe

![image-20240105123320749](.\assets\image-20240105123320749.png)

---

#### 配置环境变量

> 为每一个不同版本的python都需要配置两个环境变量

![image-20240105123425422](.\assets\image-20240105123425422.png)

* 第一个路径是python解释器的路径
* 第二个路径是python相关脚本工具的路径

---

#### 测试多版本python环境

* 命令1：```where python3.12```

  查看`python3.12`的安装路径

![image-20240105123544209](.\assets\image-20240105123544209.png)

![image-20240105162624704](.assets\image-20240105162624704.png)

* 命令2：```python3.12 --version```

  查看`python3.12`的版本

  ![image-20240105123618686](.\assets\image-20240105123618686.png)

* 命令3：`python3.11`

  使用`python3.11`解释器

![image-20240105124303272](.\assets\image-20240105124303272.png)



---

:smile:  通过以上步骤我们就为不同版本的python配置好了环境，之后我们使用`python`时只需要带上不同的版本号即可轻松切换`python`版本

---



## :cactus: VScode

#### 键盘快捷键

* `ctrl+p`：搜索文件
* `ctrl+shift+p`：输入命令
* `ctrl+,`：打开设置
* `alt+↑`：将某行往上移动
* `Ctrl+Shift+K `：删除一行
* `Ctrl+Enter `:向下插入一行
* `Ctrl+Shift+Enter `：向上插入一行
* `Ctrl+Shift+\`：跳转到对应的括号`{}`
* `Ctrl+] / [ `：前后缩进
* `Ctrl+↑ / ↓ `：滑动滚轮

#### 安装`python`插件

![image-20240105125214582](.assets\image-20240105125214582.png)

---

#### 运行`python`脚本

##### 1. 使用`code runner`运行

![image-20240105140312167](.assets\image-20240105140312167.png)

直接点击右上角的运行即可使用`code runner`。

以下方式可以配置`code runner`默认的python解释器版本：

![image-20240105140444569](.assets\image-20240105140444569.png)

##### 2. 自定义`python`解释器版本

* 默认`python`解释器设置方式：

![image-20240105140928516](.assets\image-20240105140928516.png)

* 安装`python`插件之后就可以按照如下方式自主选择解释器版本：

![image-20240105140617429](.assets\image-20240105140617429.png)

![image-20240105140605905](.assets\image-20240105140605905.png)

---

## :earth_africa: 虚拟环境的创建

> 在项目根目录下，使用如下命令：`python3.12 -m venv .venv`，就在当前目录下虚拟出了一个`.venv`文件夹，也就是一个`python 3.12`的虚拟环境

![image-20240105143317837](.assets\image-20240105143317837.png)

![image-20240105143340688](.assets\image-20240105143340688.png)

可以看到`Lib/Scripts/`文件夹下面生成了一个`python3.12`解释器：

![image-20240105161050496](.assets\image-20240105161050496.png)

创建完成后，你需要激活虚拟环境。在VSCode的集成终端中，输入以下命令来激活虚拟环境：

- 对于Windows系统：`.venv\Scripts\activate`
- 对于Mac和Linux系统：`source .venv/bin/activate`

我们将项目的解释器设置为这个生成的虚拟解释器即可：

> - 打开VSCode的命令面板（按下`Ctrl + Shift + P`），然后输入`Python: Select Interpreter`。
> - 在弹出的列表中选择你在步骤1中创建的虚拟环境路径。这将确保VSCode在运行和调试代码时使用正确的Python解释器。

![image-20240105161135988](.assets\image-20240105161135988.png)

---

#### 检查虚拟环境是否配置成功

任意打开一个命令行窗口，若前面含有`（.venv)`，则说明虚拟环境配置成功

![image-20240105161401066](.assets\image-20240105161401066.png)



## :baby_symbol: 终端如何输出中文

`python`解释器默认的编码方式是`utf-8`,如果你在控制台输出中文时出现乱码，可能是因为控制台的默认编码方式不是UTF-8。你可以尝试在控制台中执行以下命令来修改控制台的默认编码方式：

```cmd
chcp 65001
```

**`chcp 65001`的意思是改变当前活动代码页为`UTF-8`，让当前的批处理窗口支持`UTF-8`格式的文件**。

`chcp 65001`可以解决大部分的`win`系统下的终端中文输出的乱码问题。

---

#### utf-8

`vscode`中：**Python解释器默认的编码格式是UTF-8**。

在Python文件头部没有声明其他编码格式时，Python3默认的编码格式是utf-8。

自定义`python`解释器阶码文件的方式：

```py
# coding=utf-8
a = True
b = 1
print("你妈妈")
```

> 当 Python 解释器读取一个文件时，它会使用一种默认的编码方式（通常是 ASCII）来解码文件内容。如果文件中包含非 ASCII 字符（例如中文字符），那么解释器会抛出一个错误，因为它无法将这个字符解码为 ASCII。通过在文件开头添加 `# coding=utf-8`，你可以告诉解释器使用 UTF-8 编码来解码文件，从而避免这种错误。



## :japan: 动态语言

>动态编程语言是高级程序设计的一个类型，在计算机科学领域被广泛领域。它是一类在运行时可以改变其结构的语言。
>
>例如：新的函数、对象、甚至代码可以被引进，已经有的函数可以被删除或者是其他结构上的变化
>
>动态语言目前非常有活力，`python`就是一门动态语言。除此之外，例如`PHP`，`Ruby`，`Javascript`等都属于动态语言。
>
>而`c`，`c++`等则不属于动态语言而是静态语言。

但是注意，`js`和`py`的一个区别，有没有声明提前

```js
function a(){
    console.log(1)
}

a()
// 2

function a(){
    console.log(2)
}

a()
// 2 

console.log(b) // undefined
var b=10
// var会声明提前，let、const不会
```

```py
def f1():
    print(1)

f1()

def f2():
    print(2)

f2()

"""
1
2
"""

print(a)
# NameError: name 'a' is not defined
a=10
```

#### 运行过程中修改`python`代码

```py
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age


person = Person("dk", 18)
print(person.name)
print(person.age)

person.address = "hubei"
print(person.address)

"""
dk
18
hubei
"""
```



---

# :ice_cream: Python库函数

## 0. import

```py
# 以产生一个随机数字为例
import random

num = random.randint(1, 10)
print(num)
```

使用`import`关键字导入库函数

## 1. time

```py
import time
# sleep(time):程序睡眠time秒，注意这里单位是秒而不是毫秒
time.sleep(3)
```





# :taco: Python基础

## 1. 交互式命令行

![image-20240105163446157](.assets\image-20240105163446157.png)

* `win+R` + `cmd`唤醒命令提示符
* `python`唤醒解释器
* `print("hello world")`打印输出
  - 不需要`;`
  - 只能识别英文符号，例如：`""`
* `quit()`或者`ctrl+z`退出命令行



## 2. 批处理执行文件

创建`demo.py`文件，利用解释器程序来执行



## 3. python基础语法

### 1. 字面量

```py
a=10
print(666)
print(3.14)
print("dk")
print(None)
print(a)
# 除了 a 不是字面量，其余全部是字面量
```

#### None

`Python`中有一个特殊的字面量：`None`。其类型是`<class 'NoneType'>`，表示 空

`None`是类型`NoneType`的字面量，用于表示：空的、无意义的

在`if`判断中`None`等同于`False`

### 2. 注释

* 单行注释：`ctrl + /`

  ```py
  # a=10
  # print(666)
  print(3.14)
  print("dk")
  print(a)
  ```

* 多行注释：`ctrl+ shift + A`

  ```py
  """ 
  a = 10
  print(666)
  print(3.14)
  print("dk")
  print(a)
  """
  ```

### 3. 变量

```py
# 不需要说明变量类型，解释器自动识别类型
# 不需要分号
# 变量名 = 变量值
a = 10
a -= 20
print("a的值是", a)
# print可以输出多个不同类型的数据，使用逗号隔开
```

![image-20240105181524706](.assets\image-20240105181524706.png)

#### 变量的连续赋值

```py
cur = dummy = ListNode()
```



### 4. 6种数据类型

#### 堆空间 vs 栈空间

> 在`Python`中，所有的变量都是对象，对象在内存中存储的位置可以是堆空间或栈空间，具体取决于对象的类型和使用方式。一般来说，`Python`中的数字、字符串等基本类型的对象都存储在栈空间中，而复杂的对象如列表、字典、对象实例等则存储在堆空间中。当这些对象被作为参数传递给函数时，它们的引用会被压入栈空间中，函数返回时再从栈空间中弹出这些引用，但实际的对象并没有被复制，仍然存在于堆空间中

| 类型               | 描述                                                  | 说明                                                  |
| ------------------ | ----------------------------------------------------- | ----------------------------------------------------- |
| Number（数字）     | 四个子类型：int、float、complex（复数）、bool（布尔） | bool取值为：True/False（首字母大写）                  |
|                    |                                                       | 数字不能以0开头：012（×）                             |
| 五类数据容器       |                                                       |                                                       |
| String（字符串）   | 文本（使用双引号“ ”包围）                             | 属于【序列类型】，<font color='red'>不可变类型</font> |
|                    | 以上是两种基本数据类型                                |                                                       |
|                    | 以下是引用数据类型                                    |                                                       |
| List（列表）       | 有序可变                                              | 属于【序列类型】，<font color='red'>可变类型</font>   |
| Tuple（元组）      | 有序不可变                                            | 属于【序列类型】，<font color='red'>不可变类型</font> |
| Set（集合）        | 无序不重复                                            | 无序，<font color='red'>可变类型</font>               |
| Dictionary（字典） | key-value键值对                                       | 无序，<font color='red'>可变类型</font>               |

---

我们讨论一下浮点数类型：

在Python中，`-10.` 表示一个浮点数，其值为负十。这里的点（`.`）明确指定了这个数字是一个浮点数，尽管在这种情况下，因为没有小数部分，它实际上等同于整数`-10`。但在某些上下文中，明确使用浮点数可能是有意义的，例如当你期望后续会进行浮点运算时。

举个例子，如果你正在编写一个处理浮点数列表的函数，并且你想确保列表中所有的数字都是浮点数，那么即使数字是整数，你也会使用浮点数表示法。

---

<font color='red'>序列类型——其内容可以一个个一次取出</font>

#### `type()`查看数据类型  

> 不像c语言中会为变量指定一种类型
>
> python中**变量没有类型**，但是变量存储的数据有类型

```py
a = 10
b = "dk"
c = 10.1
print(type(a), type(b))
print(type(type(a)))
```

![image-20240105182503126](.assets\image-20240105182503126.png)

其实`type(c)`返回的是`c`所属的类对象

```py
class C:
    pass

c = C()

print(type(c) is C)
# True
```

---

#### `isinstance`判断数据类型

判断`a`是否是`b`或者其子类的实例

````py
isinstance(a,b)
````

#### 数据类型的转换

| 函数     | 说明                |
| -------- | ------------------- |
| int(x)   | 将x转化为一个整数   |
| float(x) | 将x转化为一个浮点数 |
| str(x)   | 将x转化为字符串     |

* any—>string: <font color='red'>**任何**类型都可以通过`str()`转化为字符串</font>

* string—>int：<font color='red'>但不是任何字符串都可以转数字，只有字符串中内容全部是数字时才可以转化</font>

* float—>int：<font color='red'>浮点数转整数，截断小数部分，而不是四舍五入</font>

```py
a = 10
b = "dk"
c = "10"
print(a, type(a)) # 10 <class 'int'>
print(b, type(b)) # dk <class 'str'>
print(c, type(c)) # 10 <class 'str'>
d = str(a)
e = int(c)
f = float(a)
print(d, type(d)) # 10 <class 'str'>
print(e, type(e)) # 10 <class 'int'>
print(f, type(f)) # 10.0 <class 'float'>

print(int("dk")) 
"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\1. day1\demo.py", line 1, in <module>
    print(int("dk"))
          ^^^^^^^^^
ValueError: invalid literal for int() with base 10: 'dk'
"""

g = int(11.53)
print(g, type(g)) # 11 <class 'int'>
```

#### 不同数据类型的运算

* 六种不同的数据类型之间不可以进行运算，这点和JavaScript不同

* 但是`Number`类型的四种子类型之间可以相互运算

  ```py
  a = True
  b = 1
  print(a + b)
  # 2
  ```

### 5. 标识符

> 标识符：对变量、类、方法等编写的名字，叫做标识符

#### 命名规则（必须遵守)

* 内容限定：只允许出现英文、中文（不推荐）、数字【不可以用在开头】、下划线这四类，其余特殊符号都不被允许

* 大小写敏感，可以区分

* 不允许使用关键字，除非后面跟一个下划线，例如：

  ```py
  class X class_ √
  ```

  

#### 变量命名规范（尽量遵守）

* 简洁

* 下划线命名法

  ```py
  first_name = "dk"
  ```

* 英文字母尽量全小写

  ```py
  A = 10; # 不合适
  a = 10; # √
  ```



### 6. 运算符

#### 基本运算符

| 运算符 | 描述   | 实例                 |
| ------ | ------ | -------------------- |
| +      | 加     | 2+10=12              |
| -      | 减     | 2-10=-8              |
| *      | 乘     | 2*10=20              |
| /      | 除     | 9/2=4.5              |
| //     | 取整除 | 9//2=4，9.0//2.0=4.5 |
| %      | 取余   | 5%5=0                |
| **     | 指数   | 5**2=25              |

```py
print(9 / 2) # 4.5
print(9 // 2) # 4
print(9.0 // 2.0) # 4.0
print(9.0 % 2.0) # 1.0
print(9**2) # 81
print(9**2.0) # 81.0
```

#### 复合运算符

---

| 复合赋值运算符 | 含义              |
| -------------- | ----------------- |
| +=             |                   |
| -=             |                   |
| *=             |                   |
| /=             |                   |
| %=             | c%=a 等价于 c=c%a |
| **=            |                   |
| //=            |                   |

#### 三元表达式

```py
num = 1 if True else 0

(i.val if i else 0) + (j.val if j else 0)
```

#### 运算结果的类型

运算结果的数据类型和操作数中更精确的数据类型保持一致

```py
print(9**2.0) # 81.0
```

### 7. 数据的输入、输出

#### input()

```py
print("What is your name")
name = input()
print("My name is %s" % name)
"""
What is your name
dk
My name is dk
"""

# 以上代码等价于
name = input("What is your name?\n")
print("My name is %s" % name)
"""
What is your name?
dk
My name is dk
"""
```

`input()`返回值的类型——string

```py
name = input("What is your name?\n")
print(type(name))
# <class 'str'>

name = input("What is your name?\n")
print(type(name))
num = int(name) # 对input输入数据进行类型转换
print(type(num))
"""
What is your name?
10
<class 'str'>
<class 'int'>
"""
```

#### print()

##### 不换行输出

```py
print("Hello")
print("world")

# 不换行输出
print("Hello", end="")
print("world")
"""
Hello
world
Helloworld
"""
```

##### 制表符——\t

```py
print("Hello world")
print("itheima best")

print("Hello\tworld")
print("itheima\tbest")
"""
Hello world
itheima best
Hello	world
itheima	best
"""
```

##### 打印元组

```py
print(a,b) # a,b 实际上是一个元组
```





## 4. 字符串类型

#### 字符串的定义方式

1. 单引号定义法

2. 双引号定义法

3. 三引号定义法

   其中，三引号定义法和多行注释的写法一样，**同样支持换行操作**

   使用变量接收它，它就是字符串

   不使用变量接受它，就可以作为多行注释使用

```py
name1 = 'dk' # 单引号
name2 = "dk" # 双引号
name3 = """dk124
""" # 三引号
```



如果定义的字符串本身含有单引号、双引号、三引号？

> 多种解决方式:
>
> 1. 单引号内含双引号
> 2. 双引号内含单引号
> 3. 转义字符（'\\'）

```py
name1 = '"dk"'
name2 = "'dk'"
name3 = "\"dk\""
print(name1,name2,name3) # "dk" 'dk' "dk"
```



#### 字符串拼接

* 参与拼接的变量必须全部是`string`类型

```py
name = "dk"
age = "10"
sign = "my name is:" + name + ";my age is:" + age
print(sign)
# my name is:dk;my age is:10
```

* 不能将`int`类型和`string`类型拼接

> 这一点和`JavaScript`不同，`js`中`Number`可以和`String`拼接

```py
name = "dk"
age = 10
sign = "my name is:" + name + ";my age is:" + age
print(sign)
"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\1. day1\demo.py", line 3, in <module>
    sign = "my name is:" + name + ";my age is:" + age
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~
TypeError: can only concatenate str (not "int") to str
"""

a = '1'
b = 1
print(a + b)
"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\1. day1\demo.py", line 3, in <module>
    print(a + b)
          ~~^~~
TypeError: can only concatenate str (not "int") to str
"""
```



#### 字符串格式化——%

> 使用占位的形式来拼接字符串

##### 占位符

`%s`表示字符串的占位符，以下代码将`age`进行拼接时，底层进行了数据类型的转化，将`int`类型转化为了`string`类型

```py
name = "dk"
age = 10
message = "my name is %s,my age is %s" % (name, age) # age类型转化：int——> string
# 多个变量占位，按顺序填写在 %（，，）中
print(message)
# my name is dk,my age is 10
```

###### %s 、 %d 、%f

| 格式符号 | 转化                                     |
| -------- | ---------------------------------------- |
| %s       | 任何类型都可以转化为字符串，插入占位位置 |
| %d       | 将内容转化为整数，插入占位位置           |
| %f       | 将内容转化为浮点数，放入占位位置         |

```py
name = "dk"
age = 10
message = "my name is %s,my age is %d" % (name, age)
print(message)
# my name is dk,my age is 10

message = "my name is %s,my age is %f" % (name, age)
print(message)
# my name is dk,my age is 10.000000
# int会默认转化为浮点型

age2 = 10.2
message = "my name is %s,my age is %d" % (name, age2)
print(message)
# my name is dk,my age is 10
# float也会默认转化为int类型

message = "my name is %s,my age is %f" % (name, age)
print(message)
# string类型不会转化为int类型
"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\1. day1\demo.py", line 5, in <module>
    message = "my name is %s,my age is %f" % (name, age)
              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~
TypeError: must be real number, not str
"""
```

##### 格式化的精度控制

```py
name = "dk"
age2 = 10.2
message = "my name is %s,my age is %f" % (name, age2)
print(message)
# my name is dk,my age is 10.200000
```

原本`age2=10.2`但是输出`%f`时值变为了`10.200000`，这是因为我们没有对其进行精度控制

* `m.n` ：`m`和`n`都可以省略
  - m，控制宽度，设置的宽度小于数字的宽度时，<font color='red'>【不生效】，因此m只能用于加宽度，不能减宽度</font>
  - n，控制小数部分精度，<font color='red'>会进行【四舍五入】</font>

| 精度控制 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| %5d      | 表示将整数的宽度控制在`5`位，如数字`11`，按`%5d`输出，就变为了`_ _ _ 11`（高三位用三个空格补齐） |
| %7.2f    | 表示将宽度控制为7，小数精度设置为2                           |
|          | 【小数点】和【小数部分】也算入宽度。例如：`11.345`按照 `%7.2f`输出，结果是`_ _ 11.35` |
|          | 小数精度为2，`0.345`将其四舍五入为`0.35`，算上小数点整体宽度为7，因此最高位补两个空格 |

```py
name = "dk"
age2 = 10.48
message = "my name is %s,my age is %1.1f" % (name, age2)
print(message)
# my name is dk,my age is 10.5
# 1.1，m=1小于10.2本身的宽度4，因此不生效，n=1小数部分保留一位四舍五入后为5

message = "my name is %s,my age is %7.1f" % (name, age2)
print(message)
# my name is dk,my age is    10.5
# 小数部分四舍五入，整体宽度补足到7位

name = "dk"
age2 = 10
message = "my name is %s,my age is %1d" % (name, age2)
print(message)
# m=1比数字本身宽度更小不生效
```



#### 字符串快速格式化——f"{}"

此方式和`JavaScript`中``类似

* 字符串前面用`f`标记，即`format`。表示接下来的字符串中会用`{}`进行占位，填入变量
* 快速格式化的特点
  * 不限制数据类型，直接将`{}`中的变量放入即可
  * 不做精度控制，直接输出原数据（适用于对精度没有要求时快速格式化）

```py
name = "dk"
age2 = 10
message = f"my name is {name},my age is {age2}"
print(message)
# my name is dk,my age is 10
```

#### 对表达式进行格式化

##### 表达式

>  `1+1`、`5+2`都是表达式，它们具有明确的执行结果，执行结果是一个数字
>
> `name = 'dk'`、`age = 1+1`也都是表达式

```py
print("The result of 1+1 is %s" % (1 + 1)) # 用小括号
print(f"The result of 1+1 is {1+1}") # 快速格式化，用大括号
print("The type of string in python is %s" % type("string"))
# The result of 1+1 is 2
# The result of 1+1 is 2
# The type of string in python is <class 'str'>
```



## 5. 布尔类型

#### bool

> `bool` 类型是属于 `Number`（数字）类型的子类型，只有`True`和`False`两种取值
>
> 之所以将`bool`划归为`Number`,是因为`True`底层就是二进制`1`,`False`底层就是二进制`0`

```py
bool_1 = True
bool_2 = False
print(bool_1, type(bool_1))
print(bool_2, type(bool_2))
"""
True <class 'bool'>
False <class 'bool'>
"""
```

#### 比较运算

```py
result = 10 > 5
print(type(result))
# <class 'bool'>
```

#### 比较运算符

| 运算符 |
| ------ |
| ==     |
| !=     |
| >      |
| <      |
| >=     |
| <=     |

```py
print(f"The result of 10==10 is {10==10}")
# The result of 10==10 is True
```

#### or & not & and

`python` 中没有 `&&  ，!, ||`3个会出现逻辑错误的。要实现同样的功能，要写成` and，not，or`

| 逻辑运算符 | python | 例子                     | 说明                                               |
| ---------- | ------ | ------------------------ | -------------------------------------------------- |
| &&         | and    | 2 and 3 返回3            | 若多个表达式全为真，返回最后一个表达式             |
| II         | or     | 2 or 3 返回2             | 返回第一个为真的表达式，若全为假，则返回`False`    |
|            |        | False or False 返回False |                                                    |
|            |        | 0 or 0 返回 0            |                                                    |
| !          | not    | not 2 and 3 返回 False   | `not i`的返回值为布尔类型，只能为`True`或者`False` |

```python
if (
    int(input("First try:")) == 10
    or int(input("Second try:")) == 10
    or int(input("Third try:")) == 10
):
    print("Bingo!")
else:
    print("Lose! The number is 10.")
```



## 6. if语句

```py
if 10 > 5:
    print("10>5")
else:
    print("10<5")
```

* 注意冒号`:`，和缩进的配合使用
* `if`单个条件判断不需要小括号，多个条件组合需要小括号
* `if`内语句不需要大括号包裹，合理缩进即可，缩进在一起的相当于在同一个大括号里

#### if elif else 组合使用

<font color='red'>多个条件分支语句只会执行一次，从上到下判断，只要有一个分支执行，其余分支都不会再执行</font>

```py
if 10 < 5:
    print(1)
elif 8 > 5:
    print(2)
else:
    print(3)
```

#### 数据容器作为判断条件

```py
if list() or dict() or tuple() or set() or str():
    print(True)
else:
    print(False)
# False

if [1] and (1,) and {1} and {"a": 1} and "12":
    print(True)
# True
```

由上述结果可知，空的数据容器在作为判断条件时，会被当作`False`

非空的数据容器在作为判断条件时，会被当作`True`

## 8. while语句

```py
i = 0
while i < 10:
    print(i)
    i += 1
```



#### 自增 i++ & ++i

> `python` 中的没有 `i++ `，如果写了会报语法错误。这是因为Python中的数字变量都被视为不可修改的对象，不能像C/C++等语言一样直接进行自增/自减操作。
>
> 但是python 中有 `--i`,`++i`,`+-i`,`-+i`,<font color='red'>他们不是实现-1操作的</font>，仅仅是作为判断运算符号,类似数学中的负负得正。

当然，我们可以借助其他方式实现自增操作，如使用i = i + 1或i += 1来完成自增。



#### 猜数字案例

```py
import random

num = random.randint(1, 100)
cnt = 0

while True:
    a = int(input("Have a try:"))
    cnt += 1
    if a < num:
        print("Lower!")

    elif a > num:
        print("Higher!")

    else:
        print(f"Bingo after {cnt} times!The number is {num}")
        break
```



#### while嵌套

##### <font id='quickSort'>快速排序</font>

```py
import random


def swap(arr, i: int, j: int):
    tmp = arr[i]
    arr[i] = arr[j]
    arr[j] = tmp


def quick_sort(arr, low: int, high: int) -> None:
    if low >= high:
        return
    i = low
    j = high
    pivot = arr[i]
    while i < j:
        while i < j and arr[j] >= pivot:
            j -= 1
        swap(arr, i, j)

        while i < j and arr[i] <= pivot:
            i += 1
        swap(arr, i, j)

    # 这里不需要swap(arr,low,i)
    quick_sort(arr, low, i - 1)
    quick_sort(arr, i + 1, high)


a = list()
i = 0
while i < 10:
    a.append(random.randint(0, 100))
    i += 1
print(a)

quick_sort(a, 0, 9)
print(a)
```



##### 九九乘法表

> 使用`print()`函数的`end`参数和制表符`\t`来对齐

```py
i = 1

while i <= 9:
    j = 1
    while j <= i:
        print(f"{j}*{i}={i*j}", end="\t")
        j += 1
    print("\n")
    i += 1
"""
1*1=1	

1*2=2	2*2=4	

1*3=3	2*3=6	3*3=9	

1*4=4	2*4=8	3*4=12	4*4=16	

1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	

1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	

1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	

1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	

1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81	

"""
```

```py
i = 1
while i <= 9:
    j = 1
    while j <= i:
        print(f"{j}*{i}={i*j}", end="\t")
        j += 1
    print()
    i += 1
"""
1*1=1	
1*2=2	2*2=4	
1*3=3	2*3=6	3*3=9	
1*4=4	2*4=8	3*4=12	4*4=16	
1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	
1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	
1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	
1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	
1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81
"""
```



## 9. for语句

> 和`while`以及其他语言的`for`循环不同，`python`的`for`是直接取出目标序列的<font color='red'>元素</font>，无法自定义循环条件

#### StopIteration

> 执行`for...in...`循环，遇到`stopIteration`时，表示可迭代对象已经被迭代完毕，for循环会结束

```py
# 轮询字符串
for item in "heimacxy":
    print(item, end=" ")
# h e i m a c x y

# 轮询列表
for item in [1, 2, 3, 4, 5]:
    print(item, end=" ")
# 1 2 3 4 5 

# 统计个数
cnt = 0
for item in "abcdandavacsdanva":
    if item == "a":
        cnt += 1
print(cnt)
# 6
```



#### range()

```py
range(num)
# 获取一个从0开始，到num结束的数字序列【不包含num本身】
# 如range(5)取得的序列是[0,1,2,3,4,5]

range(num1,num2)
# 从num1开始，num2结束，包含num1，不包含num2
# 如range(3,6)取得的序列是[3,4,5]

range(num1,num2,step)
# 从num1开始，num2结束，包含num1，不包含num2
# 数字之间的步长为step，默认是1
# 如range(1,10,2)取得的序列是[1,3,5,7,9]

for item in range(1, 10, 2):
    print(item, end=" ")
# 1 3 5 7 9
```



#### 变量作用域

> 临时变量`item`，在编程规范上，作用域限定在`for`循环内部

```py
for item in range(5):
    print(i, end=" ")
    
print(i)
#0 1 2 3 4 4
```

但是在以上代码中，在`for`外部访问临时变量`item`：

* 实际上是可以访问到的
* 但是在编程规范上是不允许、不建议这么做的

规范的写法如下：

```py
i = 0
# 在for循环外面将i定义好
for i in range(5):
    print(i, end=" ")

print(i)
```



#### 九九乘法表

```py
i = 0
for i in range(1, 10):
    for j in range(1, i+1):
        print(f"{j}*{i}={i*j}", end="\t")
    print()
"""
1*1=1	
1*2=2	2*2=4	
1*3=3	2*3=6	3*3=9	
1*4=4	2*4=8	3*4=12	4*4=16	
1*5=5	2*5=10	3*5=15	4*5=20	5*5=25	
1*6=6	2*6=12	3*6=18	4*6=24	5*6=30	6*6=36	
1*7=7	2*7=14	3*7=21	4*7=28	5*7=35	6*7=42	7*7=49	
1*8=8	2*8=16	3*8=24	4*8=32	5*8=40	6*8=48	7*8=56	8*8=64	
1*9=9	2*9=18	3*9=27	4*9=36	5*9=45	6*9=54	7*9=63	8*9=72	9*9=81
"""
```



## 10. continue & break

#### continue

```py
i = 0
for i in range(1, 10):
    if i == 5:
        continue
        # 临时跳过本次循环
    print(i, end=" ")
# 1 2 3 4 6 7 8 9 
```

#### break

```py
i = 0
for i in range(1, 10):
    if i == 5:
        break
        # 直接中断循环
    print(i, end=" ")
# 1 2 3 4
```

<font color='red'>无论是`continue`还是`break`，都只会对其所在循环起作用</font>



# :pager: Python函数

#### 引入——len

> 内置函数—len

```py
length = len("itheima")
print(length)
# 7
```

```py
# 注意形参和实参的区别
def get_length(str: str) -> int:
    cnt = 0
    for item in str:
        cnt += 1
    return cnt

print(get_length('heimacxy'))
# 7
```

#### 函数返回值——None

> 思考：如果函数没有使用`return`语句返回数据，那么函数有返回值吗？
>
> 答案是有的。无返回值的函数，实际上就是返回了`None`这个字面量

`Python`中有一个特殊的字面量：`None`。其类型是`<class 'NoneType'>`，表示 空

`None`是类型`NoneType`的字面量，用于表示：空的、无意义的

```py
def test(str):
    return

print(test("heimacxy"))
print(type(None))

"""
None
<class 'NoneType'>
"""
```

`None`的使用场景：

* 用于函数无返回值

* 在`if`判断中`None`等同于`False`

* <font color='red'>用于声明一些无内容的变量，作为其初始值</font>

  ```py
  name = None
  name = "dk"
  ```

#### 函数的说明

函数的说明以多行注释的形式写在函数内部的开头

```py
def name(args):
    """
    param arg:参数1
    """
    return

name(1)
```

![image-20240106202810145](.assets\image-20240106202810145.png)



#### 函数的嵌套调用

<a href="#quickSort">快速排序</a>

#### 变量的作用域

> Python中没有块级作用域，只有函数作用域

##### 局部变量

> 所谓局部变量，是指定义在函数体内部的变量，只在<font color='red'>函数体内部</font>生效。
>
> 局部变量的作用：在函数体内部，临时保存数据，当函数调用完毕之后立即销毁局部变量

##### 全局变量

> 所谓全局变量，指的是定义在函数体外，在函数体内、外都能生效的变量

##### global

```py
# 函数内访问全局变量
num = 100

def modify():
    print(num)

modify()
# 100
```

```py
num = 100

def modify():
    print(num)
    num = 200

modify()
# 以上代码会报错
"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\1. day1\quickSort.py", line 9, in <module>
    modify()
  File "d:\WEB-front-end\python_study\study\1. day1\quickSort.py", line 5, in modify
    print(num)
          ^^^
UnboundLocalError: cannot access local variable 'num' where it is not associated with a value
"""
# 这是因为在函数内部声明了一个局部变量num，类似于JavaScript里的声明提前，print(num)打印的是局部变量num，但是执行print(num)时num还未被赋值，因此会出错
```

```py
num = 100

def modify():
    print(num)

modify()
# 100

# 以上代码不会报错，因为此时print(num)打印的是全局变量num，已经被正常赋值
```

```py
num = 100

def modify():
    num = 200

modify()
print(num)
# 100
# 以上代码并不能修改全局变量num的值，因为函数内部的 num = 200，相对于声明了一个新的值为200的局部变量 num
```

```py
num = 100

def modify():
    global num
    num = 200

modify()

print(num)
# 200
# 在函数内部使用 global num，表目函数内部使用到的num都是全局变量，而不是新生成一个局部变量
```

#### 函数的多返回值

```py
def test():
    return 1, [1, 2]

x, y = test()
print(x, y)
## 1 [1, 2]

def test():
    return 1, [1, 2]

x = test()
print(x,type(x))
# (1, [1, 2]) <class 'tuple'>
```

通过以上实例可知，函数的多返回值实际上是元组类型。

可以用类似`JavaScript`中解构赋值的方式，用`x,y`一次性取出元组内的元素

#### 函数的多种传参方式

##### 位置参数

```py
def info(name, age, gender):
    print(f"Your name is {name},age is {age},gender is {gender}")


info("dk", 18, "男")
# Your name is dk,age is 18,gender is 男
```

传递的实参和定义的形参的顺序和个数必须保持一致

---

##### 关键字参数

```py
def info(name, age, gender):
    print(f"Your name is {name},age is {age},gender is {gender}")

info("dk", gender="男", age=18)
# Your name is dk,age is 18,gender is 男
```

函数调用时通过<font color='red'>`key = value`</font>的形式传递参数

函数调用时，如果有位置参数时，<font color="#008c8c">位置参数必须在关键字参数的前面</font>，但关键字参数之间不存在先后顺序

---

##### 不定长（可变）参数

###### 展开运算符

> 可以看出元组和列表等用一个`*`进行展开
>
> 字典用两个`*`进行展开
>
> 展开运算符之后必须是一个可迭代对象

```py
a = [2, 3]
b= [1, *a, 4]
print(a,b)
# [2, 3] [1, 2, 3, 4]

a = {"a": 1}
b = {**a, "b": 2}
print(b)
```

> 不定长参数也叫可变参数，用于不确定调用的时候会传递多少个参数（不传参）也可以的场景
>
> 作用：当调用函数时不确定参数的个数时，可以使用不定长参数

* 位置传递的不定长：

  - 参数前是一个`*`
  - `args`是元组类型

  ```py
  def info(*args):
      print(args)
  
  info("dk")
  info("Tom", 18)
  """
  ('dk',)
  ('Tom', 18)
  """
  ```

* 关键字传递的不定长：

  - 参数前是两个`*`
  - `kwargs`是字典类型

  ```py
  # key-word args
  def info(**kwargs):
      print(kwargs)
  
  info(name="dk", age=18, gender="男")
  # {'name': 'dk', 'age': 18, 'gender': '男'}
  ```

---

##### 默认（缺省）参数

```py
def info(name, age, gender="男"):
    print(f"Your name is {name},age is {age},gender is {gender}")

info("dk", age=18)
# Your name is dk,age is 18,gender is 男
```

<font color='red'>设置默认值的形参必须在参数列表最后</font>

```py
def info(name="dk", age, gender="男"):
    print(f"Your name is {name},age is {age},gender is {gender}")
# 报错
```



#### 匿名函数

##### 函数作为参数传递

```py
def forEach(arr, callback):
    print(type(callback))
    for item in arr:
        callback(item, end=" ")

forEach([1, 2, 3], print)
"""
<class 'builtin_function_or_method'>
1 2 3 
"""
```

##### lambda匿名函数

> `def` 关键字，可以定义带有名称的函数。
>
> ​	有名称的函数，可以基于名称重复使用
>
> `lambda`关键字，可以定义匿名函数
>
> ​	匿名函数，只可以临时使用一次

* 匿名函数定义语法：

  `lambda 传入参数：函数体（一行代码）`

  - `lambda`是关键字，表示定义匿名函数
  - 传入参数：表示匿名函数的形式参数，如 `x,y`表示接收`2`个形式参数
  - 函数体：就是函数的执行逻辑，要注意：<font color='red'>只能写一行，无法写多行代码</font>

```py
def forEach(arr, callback):
    print(type(callback))
    for item in arr:
        callback(item,item+1)

forEach([1, 2, 3], lambda i, j: print(i, j))
"""
<class 'function'>
1 2
2 3
3 4
"""
```

<font color='red'>这行代码若是一个表达式，这个表达式的值就是该匿名函数的返回值</font>

```py
def forEach(arr, callback):
    print(type(callback))
    for item in arr:
        value = callback(item, item + 1)
        print(value)

forEach([1, 2, 3], lambda i, j: i + j)
"""
3
5
7
"""
```



# :egg: 面向对象

> 面向对象 & 面向过程
>
> 面向对象适用于较大的过程项目，如果代码只是一个小案例，直接面向过程即可

新式类：`Python3`中定义的类都是新式类，无论是否写明一个类继承`object`，都会间接或者直接继承`object`

经典类：如果在`python2`中没有写明继承于`object`类，那么它就是一个经典类

新式类中自带了很多的功能，而经典类就是一个很老的类，它里面自带的功能很少

### :icecream: `class`定义类

当`python`解释器解析到`class`定义一个类时，会解析这个代码块并且利用`type(class_name, class_parents, class_attr)`元类创建一个类对象，并且将代码块的内容解析为三个参数`class_name, class_parents, class_attr`传入`type`函数，最后返回一个类对象，就完成了一个类的定义。

```py
class NameDes(object):
    """可以实现描述符的类"""
    print(1)

    def __init__(self):
        self.__name = None

    def __get__(self, instance, owner):
        print("before get")
        return self.__name

    def __set__(self, instance, value):
        print("before set")
        if isinstance(value, str):
            self.__name = value
        else:
            raise TypeError("need a string")

    def __delete__(self, instance):
        del self.__name


class Person(object):
    print('2')
    # 描述符
    name = NameDes()

# 1
# 2
```

定义类的时候，内部代码就会执行。



### :keycap_ten: 实例属性 & 实例方法

> 实例属性存放在实例对象中
>
> 实例方法存放在类对象中

```py
# 定义类
# class 类名称:
class Student:
    def __init__(self):
    # 实例属性
    	self.name = None
    	self.gender = None
      	self.nationality = None
    	self.native = None
    	self.age = None  
        
    # 类的行为，又叫成员方法
    # 实例方法的 self 形参必须定义，否则调用该方法时会默认传入实参self，若没有定义该形参，否则会报错
    def sayName(self):
        print(f"My name is {self.name}")

# 创建类的对象
# 对象 = 类名称()
stu_1 = Student()

stu_1.name = "dk"
stu_1.gender = "男"
stu_1.nationality = "China"
stu_1.native = "Beijing"
stu_1.age = 18
```

#### 调用实例方法——self

##### 通过实例对象调用实例方法

<font color='red'>**实例方法**只能通过类实例对象进行调用，不可以通过类名进行调用</font>

```py
def func1(self,args):
    # ...
    print(f"My name is {self.name}")
```

可以看到，在方法定义的参数列表中，有一个`self`关键字，在定义类从成员方法时，<font color='red'>必须填写</font>：

* 表示类对象自身
* 当我们使用类对象调用方法时，`self`会被`python`自动传入
* 在方法内部，想要访问类的成员变量，必须使用`self`
* `self`关键字尽管在参数列表中，但是传参的时候可以忽略它

##### 通过类名调用实例方法

尽管上文说到不可以通过类名调用实例方法，但是通过一些方式主动传入`self`好像也可以以类名的形式调用，但是实际上函数通过传入的对象调用的。

> 通过类名调用实例方法要传入被调用对象
>
> 但是通过类名调用类方法直接传入参数即可，`cls`默认指向类对象

```py
class Test(object):
    def __init__(self, subject1):
        self.subject1 = subject1
        self.subject2 = "cpp"

    def __getattribute__(self, obj):
        if obj == "subject1":
            print("get subject1")
            return "redirect python"
        else:
            return object.__getattribute__(self, obj)

    def test(self, num):
        print(num)
        return num + 1


s = Test("python")
# 通过类名调用，主动传入self
print(Test.__getattribute__(s, "subject1"))
print(Test.test(s, 10))
```

#### 动态添加实例方法

```py
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age


person = Person("dk", 18)


def show_info(self):
    print("---show_info---")


person.show_info = show_info
person.show_info()
"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\demo.py", line 15, in <module>
    person.show_info()
TypeError: show_info() missing 1 required positional argument: 'self'
"""

# 需要主动传递参数
person.show_info(person)
# ---show_info---

Person.show_info = show_info
person.show_info()
# ---show_info---
```

> 通过以上代码可以知道，调用定义在对象本身的方法时，不会自动传入`self`参数
>
> 但是调用定义在类对象上的方法时，会自动传递`self`参数

##### `types.MethodType(run,p3)`

该方法可以实现一个方法与一个对象的绑定，可以类似于`JavaScript`中的`call`和`apply`、`bind`方法

```py
import types


class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age


person = Person("dk", 18)


def show_info(self):
    print("---show_info---")


person.show_info = types.MethodType(show_info, person)
person.show_info()
# ---show_info---
```

###### 函数柯里化

也可以用该函数来实现函数柯里化，但是有一个问题就是`types.MethodType`每次只能接收两个参数

1. 第一个参数是待柯里化的函数
2. 第二个参数是只已经确定的参数

```py
import types

def show_info(a, b, c, d, e):
    print("---show_info---")
    print(a, b, c, d, e)

test = types.MethodType(show_info, 1)
test1 = types.MethodType(test, 2)
test1(3, 4, 5)

"""
---show_info---
1 2 3 4 5
"""
```





### :kissing_cat: 静态方法

> 默认情况下`python`中定义的是<font color='red'>实例方法</font>，即这个方法有一个默认的形参`self`。这个`self`在被方法调用时会指向对象。
>
> 但是有的时候，我们并不需要对象的引用，即`self`没用，那应该如何处理呢？能不写`self`吗？答案是可以的

#### @staticmethod

> 如果一个方法不写`self`，即不需要实例对象的引用，此时在定义方法的时候可以用`@staticmethod`对函数进行修饰，被修饰的函数就可以不写`slef`。
>
> 一句话，被`@staticmethod`修饰的方法就是<font color='red'>静态方法</font>。

```py
class Student:
    name = None
    age = None
	
    # 如果是实例方法，那么参数列表中一定要定义 self 这个形参，在调用时可以不必传入实参，python自动传入
    def __init__(self, name, age):
        self.name = name
        self.age = age

    @staticmethod
    def sayHello():
        print("Hello world")
```

#### 调用静态方法

* 通过实例对象调用静态方法

  ```py
  student = Student("dk", 18)
  student.sayHello() # 不会默认传入self
  ```

* 通过类名调用静态方法

  ```py
  Student.sayHello() # 不会默认传入self
  ```

#### 动态添加静态方法

```py
import types


class Person(object):
    num = 0

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def eat(self):
        print("default")


# 定义一个实例方法
def run(self, speed):
    print(self.name, speed)


# 定义一个类方法，注意设置装饰器
@classmethod
def test_class(cls):
    print(cls.num)
    cls.num = 100
    print(cls.num)


# 定义一个静态方法，注意设置装饰器
@staticmethod
def test_static():
    print("static method")


p = Person("dk", 18)
p.eat()

# 给对象添加一个实例方法
p.run = types.MethodType(run, p)
# 调用添加的实例方法
p.run(100)

# 绑定类方法
# 只需要将其设置为类对象的属性即可，不需要其他修改
Person.test_class = test_class
# 调用类方法
Person.test_class()

# 绑定静态方法
# 只需要将其设置为类对象的属性即可，不需要其他修改
Person.test_static = test_static
# 调用静态方法
Person.test_static()
```

### :closed_lock_with_key: 类属性

> 默认情况下，当通过同一个类创建了多个实例对象之后，每个实例对象之间是相互隔离的，但是有的时候数据需要在多个对象之间共享，此时应该怎么办呢？
>
> 想要在多个对象之间共享数据，即一些属性需要在**多个对象**之间**共享**，这样的属性就是**类属性**。
>
> 类属性存放在类对象中，实例属性存放在实例对象中
>
> 比如希望记录，学生类中含有多少个学生对象

```py
class Student:
    # 在__init__函数外部定义的就是类属性
    num = 0

    def __init__(self, name, age):
        self.name = name
        self.age = age
        Student.num += 1

    @staticmethod
    def sayHello():
        print("Hello world")


student = Student("dk", 18)
student = Student("cy", 18)

print(Student.num) # 2
print(student.num) # 2
```

#### 类属性的存取

* 通过类名调用类属性

  ```py
  print(Student.num) # 2
  ```

* 通过实例对象调用类属性（若实例对象上没有同名类属性，则会沿着`__class__`找到类对象中的类属性）

  ```py
  print(student.num) # 2
  ```

```py
student = Student("dk", 18)
student = Student("cy", 18)

print(Student.num) # 2,访问类属性
print(student.num) # 2，无对应实例属性，访问类属性

student.num = 10	# 新建了实例属性
print(Student.num) # 2，访问类属性
print(student.num) # 10，访问实例属性
```

### :older_woman: 类方法

> 为了更好地对**类属性**进行操作，减少通过`类名.`来访问类属性，`python`通过了另外一种方法`类方法`，通过类方法来访问类属性

#### @classmethod

> 定义一个类方法，在方法前面添加`@classmethod`即可，与此同时，需要在方法的第一个形参位置添加`cls`
>
> `cls`一定指向当前类

```py
class Student:
    num = 0

    def __init__(self, name, age):
        self.name = name
        self.age = age
        # 通过实例对象也可以调用类方法
        self.add_1()

    @classmethod
    def getNum(cls):
        return cls.num

    @classmethod
    def add_1(cls):
        cls.num += 1

    @staticmethod
    def sayHello():
        print("Hello world")


student = Student("dk", 18)
student = Student("cy", 18)

print(Student.getNum())
print(student.getNum())

```

#### 调用类方法

* 通过实例对象调用类方法，<font color='red'>`cls`也是指向了类对象</font>

  ```py
  print(student.getNum())
  ```

* 通过类名调用类方法（推荐）

  ```py
  print(Student.getNum())
  ```

#### 动态添加类方法

<a href='#动态添加静态方法'>动态添加</a>

#### 装饰器 & 类方法

通过实例对象调用类方法时`student.getNum()`明明是`student`调用了`getNum`函数，那为什么`cls`还是指向类对象而不是实例对象吗，不是说好谁调用就指向谁吗？

> 因为这里的`getNum`不是之前定义的那个`getNum`，而是被装饰过后的`getNum`。实例对象调用被装饰过后的函数，被装饰过后的函数接收到的`self`确实是该实例对象。
>
> 但是在装饰器中，程序通过该实例对象的`__class__`属性寻找到了该实例对象所属的类对象，紧接着再用该类对象去调用初始定义的函数。因此`getNum`中的`cls`一直指向类对象

这里有一个注意点，无论是实例方法、静态方法、类方法都是存放在类对象中的，但是并不是存放在哪里`self`就指向谁，而是要看调用该方法的到底是哪一个对象

### :man_facepalming: 类对象

> 之前在学习类属性的时候，我们提到过：类属性是可以在多个实例对象之间共享的属性，那么问题来了，类属性到底存在哪里呢？
>
> 答：类对象。`python`中定义的类，实际上也是一个对象——类对象

* `dir()`

> 既然我们知道了实例对象中含有默认的`__class__`，那除了它之外还有哪些属性呢？
>
> 我们可以通过`dir(实例对象)`来查看对象中的所有属性

```py
print(dir(student))

"""
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'add_1', 'age', 'getNum', 'name', 'num', 'sayHello']
"""
```

### :leopard: 总结

1. 实例对象可以调用类方法、静态方法、实例方法，因为装饰器已经对方法进行了修饰
2. 可以通过类名调用静态方法、类方法
3. 类方法、静态方法、实例方法都存放于类对象中，减少内存的浪费

为什么要存在这三种方法？

1. 类方法修改类属性
2. 实例方法修改实例属性

那为什么要存在静态方法呢？

静态方法可以作为一种工具方法，不需要用到实例对象或者类对象的属性就可以完成特定的功能，不必传递`self`或者`cls`





### :oncoming_bus: 魔法属性：

> `__class__`，是`Python`类的内置属性之一
>
> 这些内置的类属性，各自有各自的特殊功能，这些内置方法被称为”魔术属性“

#### `__bases__`：父类构成的元组

```py
class Test:
	pass


print(Test.__bases__)
"""
(<class 'object'>,)
"""
```

#### `__module__`：当前对象在哪个模块

```py
# module_1.py
class Person(object):
    def __init__(self):
        self.name = "dk"
```

```py
from module.module_1 import Person

person = Person()
print(person.__module__)
# module.module_1

class Person2:
    pass

person2 = Person2()
print(person2.__module__)
# __main__：当前模块一定叫 __main__，而不是叫当前文件名

print(person2)
# <__main__.Person2 object at 0x0000019FB720AAB0>
```



#### `__class__`：实例所属的类对象

> 每个实例对象中都有一个`__class__`属性，这个属性指向了其类对象。
>
> 当调用`实例对象.xxx()`时，实际上进行了`实例对象.__class__.xxx()`

* 实例属性：多次存放在各个实例对象中
* 类属性：一次存放在类对象中
* <font color='red'>所有的方法：实例方法、静态方法、类方法都是在类对象中存储。</font>

```py
class Student:
    num = 0

    def __init__(self, name, age):women
        self.name = name
        self.age = age
        self.add_1()

    @classmethod
    def getNum(cls):
        return cls.num

    @classmethod
    def add_1(cls):
        cls.num += 1

    @staticmethod
    def sayHello():
        print("Hello world")

student = Student("dk", 18)
student2 = Student("dk", 18)

print(student.__class__.num) # 2
```

#### `__name__`：记录函数名

```py
from time import ctime, sleep

# 定义一个闭包
def timefun(func):
    def wrapped_func():
        print("%s called at %s" % (func.__name__, ctime()))
    return wrapped_func()

print(timefun.__name__) # timefun
```

#### `__mro__`：记录父类

<a href='#super'>super</a>

#### `__doc__`：说明文档

```py
class Test:
    """
        dic 
    """
    def __repr__(self):
        return "1"


t = Test()
print(t.__doc__)
print(Test.__doc__)
print(help(Test))
"""

        dic 
    

        dic 
    
Help on class Test in module __main__:

class Test(builtins.object)
 |  dic
 |
 |  Methods defined here:
 |
 |  __repr__(self)
 |      Return repr(self).
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables
 |
 |  __weakref__
 |      list of weak references to the object

None
"""
```

#### `__dict__`：对象的属性字典

`python`中对象的**所有属性以字典的方式进行存储**，<font color='red'>只包括对象自身的属性，不包括类对象中的属性</font>

```py
class Parent(object):
    x = 1

    def __init__(self):
        self.a = 10
        self.b = 20

class Child1(Parent):
    pass


print(Child1.__dict__)
print(Parent.__dict__)
print(Parent().__dict__)

"""
{'__module__': '__main__', '__doc__': None}
{'__module__': '__main__', 'x': 1, '__init__': <function Parent.__init__ at 0x000001C7E7A18F40>, '__dict__': <attribute '__dict__' of 'Parent' objects>, '__weakref__': <attribute '__weakref__' of 'Parent' objects>, '__doc__': None}
{'a': 10, 'b': 20}
"""
```

##### `__dict__` vs `dir()`

> `dir()`函数会自动寻找一个对象的所有属性，包括`__dict__`中的属性。
>
> `__dict__`是`dir()`的子集，`dir()`包含`__dict__`中的属性。
>
> `dir()`是`Python`提供的一个`API`函数，`dir()`函数会自动寻找一个对象的所有属性(包括从父类中继承的属性)。
>
>  一个实例的`__dict__`属性仅仅是那个实例的实例属性的集合，并不包含该实例的所有有效属性。

```py
class Parent(object):
    x = 1


class Child1(Parent):
    pass

# 仅仅包含了当前对象上的属性
print(Child1.__dict__)

# 不仅包含了当前对象上的属性，还包含了其父类和类对象上的属性
print(dir(Child1))

"""
{"__module__": "__main__", "__doc__": None}
[
    "__class__",
    "__delattr__",
    "__dict__",
    "__dir__",
    "__doc__",
    "__eq__",
    "__format__",
    "__ge__",
    "__getattribute__",
    "__getstate__",
    "__gt__",
    "__hash__",
    "__init__",
    "__init_subclass__",
    "__le__",
    "__lt__",
    "__module__",
    "__ne__",
    "__new__",
    "__reduce__",
    "__reduce_ex__",
    "__repr__",
    "__setattr__",
    "__sizeof__",
    "__str__",
    "__subclasshook__",
    "__weakref__",
    "x",
]
"""
```

##### vars()

> `__dict__`也可以用`vars`函数替代，功能完全相同，`a.__dict__`等价于`vars(c)`

##### `hasattr()`

> 判断一个对象是否有某个属性

```py
class ObjectCreator(object):  # ObjectCreator是一个类对象
    pass

print(hasattr(ObjectCreator, "new_attribute"))	# False
ObjectCreator.new_attribute = "new_attribute"
print(hasattr(ObjectCreator, "new_attribute"))	# True
```



#### `__slots__`：限制实例的属性

为了达到限制的目的，`python`允许在定义类的时候，定义一个特殊的`__slots__`魔术属性，来限制该类创建的实例对象可以添加的属性

```py
class Person(object):
    __slots__ = {"name", "age"}


p = Person()
p.name = "dk"
p.age = 18
p.address = "hubei"
# AttributeError: 'Person' object has no attribute 'address'
```

### :baggage_claim: 魔术方法

> `__init__`构造方法，是`Python`类的内置方法之一
>
> 这些内置的类方法，各自有各自的特殊功能，这些内置方法被称为”魔术方法“

#### `__new__`：生成实例对象

<a href='#meta'>元类</a>

#### `__init__ `：构造方法

> 使用`__new__`生成实例对象之后，紧接着就会调用`__init__`对齐进行初始化

```py
class Student:
    # 如果在构造方法中为属性赋值，可以不必提前声明属性
    # name = None
    gender = None
    nationality = None
    native = None
    age = None

    def __init__(self, name, gender, nationality, native, age):
        self.name = name
        self.age = age
        self.gender = gender
        self.nationality = nationality
        self.native = native


stu_1 = Student("dk", "男", "China", "Beijing", 18)
```

#### `__repr__`：获取变量的值

```py
a="111"
print(repr(a))
# '111'

class Test:
    def __repr__(self):
        return "1"


t = Test()
print(repr(t))
# 1
```

#### `__del__`：对象被删除前自动调用

> 对象被删除即引用计算为0

```py
class Test:
    def __del__(self):
        print("del")


t = Test()
del t # 或 t = None
# del
```



#### `__str__`：字符串方法

```py
class Student:
    name = None

    def __init__(self, name):
        self.name = name

stu_1 = Student("dk", )
print(stu_1)
print(str(stu_1))

# 直接输出内存地址
"""
<__main__.Student object at 0x0000022B2AF0AB10>
<__main__.Student object at 0x0000022B2AF0AB10>
"""
```

```py
class Student:
    name = None

    def __init__(self, name):
        self.name = name

    # __str__类似与JavaScript中的 toString 方法，当对象需要被转化为字符串时，会自动调用该方法
    def __str__(self):
        return f"Student类对象,name={self.name}"


stu_1 = Student("dk", )
print(stu_1)
print(str(stu_1))


"""
Student类对象,name=dk
Student类对象,name=dk
"""
```

#### `__lt__`：小于符号比较方法

```py
class Student:
    name = None

    def __init__(self, name, age):
        self.name = name
        self.age = age


stu_1 = Student("dk", 18)
stu_2 = Student("cy", 20)
print(stu_1 < stu_2)
"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\demo.py", line 11, in <module>
    print(stu_1 < stu_2)
          ^^^^^^^^^^^^^
TypeError: '<' not supported between instances of 'Student' and 'Student'
"""
```

```py
class Student:
    name = None

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __lt__(self, other):
        return self.age < other.age

stu_1 = Student("dk", 18)
stu_2 = Student("cy", 20)
print(stu_1 < stu_2)
# True
```

#### `__le__`：小于等于符号比较方法

```py
class Student:
    name = None

    def __init__(self, name, age):
        self.name = name
        self.age = age

    # 若不实现该方法，那就无法使用 <= 符号
    def __le__(self, other):
        return self.age <= other.age


stu_1 = Student("dk", 20)
stu_2 = Student("cy", 20)
print(stu_1 <= stu_2)
```

#### `__eq__`：小于等于符号比较方法

如果不实现该方法，那么`==`默认比较的是内存地址

若实现了该方法，那么会按照指定规则比较

```py
class Student:
    name = None

    def __init__(self, name, age):
        self.name = name
        self.age = age

stu_1 = Student("dk", 20)
stu_2 = Student("cy", 20)
print(stu_1 == stu_2)
# False
```

```py
class Student:
    name = None

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __eq__(self, other):
        return self.age == other.age


stu_1 = Student("dk", 20)
stu_2 = Student("cy", 20)
print(stu_1 == stu_2)
```

#### `__call__`：直接调用实例对象

> 直接将类的实例作为函数调用，会调用对象的`__call__`方法

```py
class Line5(object):
    def __init__(self, k, b):
        self.k = k
        self.b = b

    def __call__(self, x):
        print(self.k * x + self.b)


line_5_1 = Line5(1, 2)
line_5_1(0)
line_5_1(1)
line_5_1(2)

line_5_2 = Line5(11, 22)
line_5_2(0)
line_5_2(1)
line_5_2(2)

"""
2
3
4
22
33
44
"""
```

#### `__getattribute__`：属性访问拦截器

```py
class Test(object):
    def __init__(self, subject1):
        self.subject1 = subject1
        self.subject2 = "cpp"

    def __getattribute__(self, obj):
        if obj == "subject1":
            print("get subject1")
            return "redirect python"
        else:
            return object.__getattribute__(self, obj)


s = Test("python")
print(s.subject1)
print(s.subject2)

# 但是有个问题，这样通过object调用好像触发不了拦截器,而是绕开了
# 原因如下
print(object.__getattribute__(s, "subject1"))

"""
get subject1
redirect python
cpp
python
"""
```

##### 死循环问题

> 解析，`Test`类中的`__getattribute__`存放在`Test`类对象中，<font color='red'>重写</font>了`object`类中的`__getattribute__`方法，设置了拦截器。因此再次使用`self`调用该方法会循环触发拦截器
>
> 但是`object`中的`__getattribute__`存放在`object`类对象中，并没有设置拦截器。
>
> 两者并不是同一个方法。

```py
class Test(object):
    def __init__(self, subject1):
        self.subject1 = subject1
        self.subject2 = "cpp"

    def __getattribute__(self, obj):
        if obj == "subject1":
            print("get subject1")
            return "redirect python"
        else:
            # 将object.__getattribute__改成self.__getattribute__就出现了死循环
            return self.__getattribute__(self, obj)

s = Test("python")
print(Test.__getattribute__(s, "subject2"))
# print(s.subject2) 和上一句等价
"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\demo.py", line 19, in <module>
    print(Test.__getattribute__(s, "subject2"))
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "d:\WEB-front-end\python_study\study\demo.py", line 11, in __getattribute__
    return self.__getattribute__(self, obj)
           ^^^^^^^^^^^^^^^^^^^^^
  File "d:\WEB-front-end\python_study\study\demo.py", line 11, in __getattribute__
    return self.__getattribute__(self, obj)
           ^^^^^^^^^^^^^^^^^^^^^
  File "d:\WEB-front-end\python_study\study\demo.py", line 11, in __getattribute__
    return self.__getattribute__(self, obj)
           ^^^^^^^^^^^^^^^^^^^^^
  [Previous line repeated 996 more times]
RecursionError: maximum recursion depth exceeded
"""
```

#### `__getattr__` vs `__getattribute__`

* `__getattr__`：

  该魔术方法在当前的主流`python`版本中都可用。<font id='getattr'> </font>

  重写该方法对类及其实例**未定义的属性**有效

  也就是说，如果访问的属性不存在，会调用`__getattr__`方法。这里的属性存在包括了实例属性、类属性以及继承的属性。

  > 若子类重写了`__getattr__`方法，访问不存在的属性时就会调用子类的`__getattr__`方法。
  >
  > 若子类未重写`__getattr__`方法，就会调用父类的`__getattr__`方法，而默认的`__getattr__`的功能是产生一个异常。

  ```py
  class A:
      def __init__(self, name):
          self.name = name
  
      def __getattr__(self, item):
          print(item)
          return 18
  
  a = A("dk")
  print(a.name)
  print(a.age)
  """
  dk
  age
  18
  """
  ```

* `__getattribute__`：魔法方法，属性访问拦截器

​		无论访问的属性是否定义，都会统一触发该拦截器

若`__getattribute__`和`__getattr__`同时出现，会优先调用`__getattribute__`,实例如下：

```py
class A:
    def __init__(self, name):
        self.name = name

    def __getattr__(self, item):
        print(item,'1')
        return 18
    
    def __getattribute__(self, item) :
        print(item,'2')
        return 19
        

a = A("dk")
print(a.age)
"""
age 2
19
"""
```

#### `__enter__`

#### `__exit__`

<a href='#context'>上下文管理器</a>

#### `__iter__`

#### `__next__`

<a href='#迭代器'>迭代器</a>

#### `__getitem__`、`__setitem__`、`__delitem__`：用于索引操作

用于索引操作。如字典，以上分别表示获取、设置、删除数据

> `JavaScript`中，获取对象的属性一般有两种方法。
>
> 1. 通过`obj.key`直接调用
> 2. 通过`obj[key]`，以索引的形式调用
>
> 但是`python`中默认只有第一种使用属性的方法，因此我们使用以上三个魔术方法就可以实现通过索引的方式来访问对象属性

```py
class Foo(object):
    def __getitem__(self, key):
        print("__getitem__", key)

    def __setitem__(self, key, value):
        print("__setitem__", key, value)

    def __delitem__(self, key):
        print("__delitem__", key)


foo = Foo()

# 直接使用中括号，类似于索引的方式去操作对象
result = foo["k1"]  # 自动触发执行 __getitem__
foo["k2"] = "dk"    # 自动触发执行 __setitem__
del foo['k1']   # 自动触发执行 __delitem__

"""
__getitem__ k1
__setitem__ k2 dk
__delitem__ k1
"""
```

#### `__getslice__`、`__setslice__`、`__delslice__`：用于分片操作

这三个方法用于分片操作，如列表：

注意下面功能在`python2`中有效，`python3`已经被移除

使用`python2`时，在文件开头要指明文件编码方式

```py
# -*- coding:utf-8 -*-

class Foo(object):
    def __getslice__(self, i, j):
        print("__getslice__", i, j)

    def __setslice__(self, i, j, sequence):
        print("__setslice__", i, j)

    def __delslice__(self, i, j):
        print("__delslice__", i, j)


foo = Foo()

foo[-1:1]  # 自动触发执行 __getslice__
foo[0:1] = [11, 22, 33, 44]  # 自动触发执行 __setslice__
del foo[0:2]  # 自动触发执行 __delslice__
```

使用`python2.7`执行

```cmd
python2.7 d:/WEB-front-end/python_study/study/demo.py
```

执行结果：

```py
('__getslice__', -1, 1)
('__setslice__', 0, 1)
('__delslice__', 0, 2)
```

#### `__get__`、`__set__`、`__delete__`

<a href='#描述符对象'>描述符对象</a>

### :hankey: 面向对象三大特性

#### 封装

##### 私有成员 

> 私有成员变量和方法只能在**类内部**使用

* 私有成员变量：变量名以`__`开头（`2`个下划线）
* 私有成员方法：方法名以`__`开头（`2`个下划线）

```py
class Student:
    name = None
    # 私有成员变量
    __phone = None

    def __init__(self, name, phone):
        self.name = name
        self.__phone = phone

    # 私有成员方法
    def __getPhone(self):
        return self.__phone

    def getPhone(self):
        return self.__phone


student = Student("dk", 199)
print(student.__phone)
# AttributeError: 'Student' object has no attribute '__phone'

print(student.__getPhone())
# AttributeError: 'Student' object has no attribute '__getPhone'

# 可以看到，结果报了两个属性异常，也就是说外界无法直接访问私有属性和方法

# 使用非私有方法，可以访问私有变量 __phone
print(student.getPhone())
# 199
```

但是以下代码：

不仅仅对私有变量的赋值成功了，而且后续也可以正常打印

```py
class Student:
    name = None
    # 私有成员变量
    __phone = None

    def __init__(self, name, phone):
        self.name = name
        self.__phone = phone

    # 私有成员方法
    def __getPhone(self):
        return self.__phone


student = Student("dk", 199)

# 这里其实并不是在修改私有变量的值，而是为student设置了一个新属性 __phone
student.__phone = 111
print(student.__phone)
# 111
```

###### name mangling

> 默认情况下，`Python`中的成员函数和成员变量都是公开的`(public)`,在`python`中没有类似`public`,`private`等关键词来修饰成员函数和成员变量。
>
> 在`python`中定义私有变量只需要在变量名或函数名前加上两个下划线，那么这个函数或变量就是私有的了。
>
> 在内部，`python`使用一种 `name mangling` 技术，将 `__membername`替换成 `_classname__membername`，也就是说，类的内部定义中，所有以双下划线开始的名字都被"翻译"成前面加上 单下划线和类名的形式。
>
> 例如：为了保证不能在class之外访问私有变量，Python会在类的内部自动的把我们定义的`__spam`私有变量的名字替换成为`_classname__spam`(注意，classname前面是一个下划线，spam前是两个下划线)。因此，用户在外部访问`__spam`的时候就会提示找不到相应的变量。
>
>  `python`中的私有变量和私有方法仍然是可以访问的；访问方法如下：
>
> 私有变量：`实例._类名__变量名_`
>
> 私有方法：`实例._类名__方法名()`
>
> 其实，`Python`并没有真正的私有化支持，但可用下划线得到<font color='red'>伪私有</font>。   
>
> 尽量避免定义以下划线开头的变量！



#### 继承

##### 单继承

`class 类名(父类名):`

```py
class Phone:
    IMEI = None
    producer = None

    def call_by_4g(self):
        print("ok")

class Phone_new(Phone):
    face_id = True

    def call_by_5g(self):
        print("new")

```

##### 多继承

`class 类名(父类名1,父类名2,...):`

```py
class Phone:
    IMEI = None
    producer = None

    def call_by_4g(self):
        print("phone")


class NFC:
    nfc_type = 5
    producer = "HM"

    def read_card(self):
        print("read")


class Control:
    control_type = 2

    def control(self):
        print("control")


class My_Phone(Phone, NFC, Control):
    pass


phone = My_Phone()
phone.read_card()
phone.control()
phone.call_by_4g()
"""
read
control
phone
"""

print(phone.producer)
# none
# 当两个父类中有同名属性时，(Phone, NFC, Control)写在括号左边的属性优先
```

##### pass关键字

语法补全工具，表示一片空的代码块。使编译器不产生错误。

##### 复写 & 使用父类成员

* 复写：子类继承父类的成员属性和成员方法之后，如果对其”不满意",那么可以进行复写。即在子类中重新定义同名的属性或者方法即可

```py
class Phone:
    IMEI = None
    producer = None

    def call(self):
        print("phone")


class NFC:
    nfc_type = 5
    producer = "HM"

    def read_card(self):
        print("read")


class Control:
    control_type = 2

    def control(self):
        print("control")


class My_Phone(Phone, NFC, Control):
    producer = "DK"

    def call(self):
        print("My_phone")


phone = My_Phone()
print(phone.producer)
phone.call()
"""
DK
My_phone
"""
```

* 使用父类成员

  - 法一: 调用父类成员

    使用成员变量：`父类名.成员变量`

    使用成员方法：`父类名.成员方法(self)`【需要传递`self`】

  - 法二：使用`super()`调用父类成员

    使用成员变量：`super().成员变量`

    使用成员方法：`super().成员方法()`【不需要传递`self`】，如果传递`self`，那么它会被当作一个普通参数

  - 是否传递`self`的差别在于是以类的形式调用方法，还是以父类对象的形式调用方法。

    以父类形式调用时，自动传入的`self`不是想要的对象，因此需要手动传递

```py
class Phone:
    IMEI = None
    producer = None

    def call(self):
        print("phone")


class NFC:
    nfc_type = 5
    producer = "HM"

    def read_card(self):
        print("read")


class Control:
    control_type = 2

    def control(self):
        print("control")


class My_Phone(Phone, NFC, Control):
    # 重写父类的 producer 属性
    producer = "DK"

    # 重写 Phone 中的 call 方法
    def call(self):
        # 调用父类的 producer 属性
        print(Phone.producer)  # None
        print(NFC.producer)  # HM
        print(self.producer)  # DK

        # 调用父类的 call 方法

        # 方式1：self表示子类的self
        Phone.call(self)  # phone
        print("My_phone")  # My_phone


phone = My_Phone()
phone.call()
```

##### super & 多继承

> 首先看，如使用父类的方法时，如果使用方法1：
>
> 使用成员变量：`父类名.成员变量`
>
> 使用成员方法：`父类名.成员方法(self)`【需要传递`self`】
>
> 就会导致一个问题：如下代码中，`Parent`的`__init__`代码被调用了两次，可能导致`name`属性被赋值两次，进而导致覆盖问题

```py
class Parent(object):
    def __init__(self, name):
        print("parent的init开始被调用")
        self.name = name
        print("parent的init结束被调用")


class Son1(Parent):
    def __init__(self, name, age):
        print("son1的init开始被调用")
        self.age = age
        Parent.__init__(self, name)
        print("son1的init结束被调用")


class Son2(Parent):
    def __init__(self, name, gender):
        print("son2的init开始被调用")
        self.gender = gender
        Parent.__init__(self, name)
        print("son2的init结束被调用")


class Grandson(Son1, Son2):
    def __init__(self, name, age, gender):
        print("grandSon的init开始被调用")
        Son1.__init__(self, name, age)  # 调用父类被覆盖的初始化方法
        Son2.__init__(self, name, gender)
        print("grandson的init结束被调用")

gs=Grandson('dk',12,"男")
print("name:",gs.name)
print("age:",gs.age)
print("gender:",gs.gender)
"""
grandSon的init开始被调用
son1的init开始被调用
parent的init开始被调用
parent的init结束被调用
son1的init结束被调用
son2的init开始被调用
parent的init开始被调用
parent的init结束被调用
son2的init结束被调用
grandson的init结束被调用
name: dk
age: 12
gender: 男
"""
```

###### super & mro

使用`super()`就可以解决上述问题：

> 如果一个类中调用`super()`，那么到底调用的是它哪一个父类呢？
>
> 调用规则：`super()`在调用父类的时候，他需要计算出当前到底调用哪一个父类，在`python`中使用`C3`算法来实现这个功能
>
> 打印`Grandson.__mro__`得到一个元组：`(<class '__main__.Grandson'>, <class '__main__.Son1'>, <class '__main__.Son2'>, <class '__main__.Parent'>, <class 'object'>)`
>
> 在`grandson`调用`super`的时候，就会找到元组中`grandson`的下一个`son1`调用`super()`，`son1`中调用`super`时，又会在元组中找到`son1`的下一个`son2`，再用`son2`调用`super()`，同样`son2`中调用`super`时，会沿着元组链依次用`parent`和`object`调用`super`
>
> 这里存在一个问题，在`son1`中调用`__init__`的时候，为什么不调`son1`直接继承的`Parent`的`__init__`而是调用`son2`的`__init__`?
>
> 上面已经说过，按照`__mro__`进行调用，而且是严格按照`grandson`的链进行调用，就算当前调用到了`son`1，也依旧是按照`grandson`的`__mro__`链而不是`son1`的链进行调用.
>
> 综上，谁先调用`super()`就按照谁的`__mro__`链进行调用

```py
class Parent(object):
    # 注意参数的接收与使用
    def __init__(self, name, *args, **kwargs):
        print("parent的init开始被调用")
        self.name = name
        print("parent的init结束被调用")


class Son1(Parent):
    # 注意参数的接收与使用
    def __init__(self, name, age, *args, **kwargs):
        print("son1的init开始被调用")
        self.age = age
        # 调用son2的super
        super().__init__(name, *args, **kwargs)
        print("son1的init结束被调用")


class Son2(Parent):
    # 注意参数的接收与使用
    def __init__(self, name, gender, *args, **kwargs):
        print("son2的init开始被调用")
        self.gender = gender
        # 调用parent的super
        super().__init__(name, *args, **kwargs)
        print("son2的init结束被调用")


class Grandson(Son1, Son2):
    def __init__(self, name, age, gender):
        print("grandSon的init开始被调用")
        # 调用Son1的super
        super().__init__(name, age, gender)  # 调用父类被覆盖的初始化方法
        print("grandson的init结束被调用")


print(Grandson.__mro__)
gs = Grandson("dk", 12, "男")
print("name:", gs.name)
print("age:", gs.age)
print("gender:", gs.gender)
"""
(<class '__main__.Grandson'>, <class '__main__.Son1'>, <class '__main__.Son2'>, <class '__main__.Parent'>, <class 'object'>)
grandSon的init开始被调用
son1的init开始被调用
son2的init开始被调用
parent的init开始被调用
parent的init结束被调用
son2的init结束被调用
son1的init结束被调用
grandson的init结束被调用
name: dk
age: 12
gender: 男
"""
```

<font color='red'>但是使用多继承时，要注意`__init__`中接收的参数问题</font>

#### 多态

> 多态，指的是：多种状态，即完成某个行为，使用不同的对象会得到不同的状态
>
> 调用相同的对象方法的时候，要看这个对象是父类创建的对象还是子类创建的对象，而不一定非得调用父类或者非得调用子类
>
> 如果是父类的对象，那么直接调用父类的方法。
>
> 如果是子类的对象，先查找子类的对应方法，如果子类进行了重写，那么优先调用子类的方法；如果子类没有重写，那么仍然会调用父类的方法。

* 抽象类：含有抽象方法的类称之为抽象类
* 抽象方法：方法体是由`pass`实现的

```py
# 父类来确定有哪些方法，但是并不实现
# 具体方法的实现，由子类自行决定
# 这种写法就叫做抽象类，也称之为接口

# 抽象类
class Animal:
    # 抽象方法
    def speak(self):
        pass
    
class Dog(Animal):
    # 复写抽象类的抽象方法
    def speak(self):
        print("wang")

class Cat(Animal):
    # 复写抽象类的抽象方法
    def speak(self):
        print("miao")

# 类型注解声明参数需要父类对象，但实际传入子类对象进行
def speak(animal: Animal):
    animal.speak()

dog = Dog()
cat = Cat()
speak(dog)
speak(cat)
"""
wang
miao
"""
```

### :card_index: 属性的查找流程

首先明确在一个对象自身查找属性，都是在其`__dict__`中进行查找，该魔术属性中只包含了该对象自身的属性，不包含其父类的属性

实例属性和类属性有两种不同的查找方式

#### 类实例属性的查找方式

> 当编译器要读取`obj.field`时, 发生了什么? 
>
> 看似简单的属性访问，其过程还蛮曲折的。总共有以下几步（<font color='red'>不考虑描述符</font>）：
>
> `step: 1.` 如果`obj`实例本身的`__dict__`有这个属性，返回。如果没有，执行 `step 2`。
>
> `step：2.`如果`obj.__class__`(类对象) 的`__dict__`有这个属性，返回。 如果没有, 执行`step 3`. 
>
> `step：3.` 如果在`obj.__class__` 的父类的`__dict__`有这个属性，返回。 如果没有, 继续执行`3`， 直到访问完所有的父类。如果还是没有, 执行`step 4.`
>
> `step：4.` 执行`obj.__getattr__`方法.

```python
class A:
    def foo(self):
        print("A's foo")

class B(A):
    def foo(self):
        print("B's foo")

class C(A):
    def foo(self):
        print("C's foo")

class D(B, C):
    pass

d = D()
d.foo()
```

输出结果为：

```
B's foo
```

在上述代码中，我们定义了类 `A、B、C `和 `D`。类 `D `继承自类` B `和类` C`，类 `B` 和类 `C `都继承自类` A`。

当我们创建一个类 D 的实例并调用它的 `foo()` 方法时，`Python `会按照如下顺序进行属性查找：

1. 查找实例 `d` 中是否有 `foo` 属性。如果有，则直接调用实例 `d` 中的 `foo()` 方法。
2. 如果实例 `d` 中没有 `foo` 属性，则查找类 `D` 中是否有 `foo` 属性。如果有，则调用类 `D` 中的 `foo()` 方法。
3. 如果类 `D` 中没有 `foo` 属性，则按照` MRO `的顺序查找类 `B` 中是否有 `foo` 属性。
4. 如果类 `B` 中没有 `foo` 属性，则按照 `MRO` 的顺序查找类 `C` 中是否有 `foo` 属性。
5. 如果类 `C` 中也没有 `foo` 属性，则按照 `MRO` 的顺序查找类 `A` 中是否有 `foo` 属性。
6. 如果类 `A` 中仍然没有找到 `foo` 属性，则会执行`obj.__getattr__`方法，抛出 `AttributeError` 异常。

在上述示例中，实例 `d` 中没有 `foo` 属性，因此 `Python` 按照 `MRO` 的顺序查找类 `D`、类 `B`、类 `C` 和类 `A` 中的 `foo` 属性。由于类 `B` 在 `MRO` 中的顺序先于类 `C`，因此 `Python` 会选择类 `B` 中的 `foo()` 方法进行调用。

#### 类的属性的查找方式

> 首先会在类属性`__dict__`中查找，当在那里找不到属性名称时，属性搜索在基类中继续。对基类的搜索使用`C3`方法解析顺序 

接下来再看一个例子：

```py
class Parent(object):
    x = 1


class Child1(Parent):
    pass


class Child2(Parent):
    pass

# 不存在类属性Child.x，因此会到其基类Parent中搜索属性x，查找成功
print(Parent.x, Child1.x, Child2.x)

# 不是修改而是创建
Child1.x = 2
print(Parent.x, Child1.x, Child2.x)

# 修改类属性
Parent.x = 3
print(Parent.x, Child1.x, Child2.x)

"""
1 1 1
1 2 1
3 2 3
"""
```

#### 综合案例（结合描述符）

```py
class M:
    def __init__(self):
        self.x = 1
        
    def __get__(self, instance, owner):
        return self.x
    
    def __set__(self, instance, value):
        self.x = value
        
# 调用描述符的类
class AA:
    m = M()  # m就是一个描述符
    n = 2  # n是一个普通的属性
    def __init__(self, score):
        self.score = score  # self.score是一个普通的类属性
    
        
aa = AA(3)
print(aa.__dict__)  # {'score': 3}
print(aa.score)  # 3, 在 aa.__dict__ 中寻找，找到了score直接返回
print(aa.__dict__['score'])  # 3, 上面的调用机制实际上是这样的

print(type(aa).__dict__)  # 里面有n和m
print(aa.n)  # 2, 在aa.__dict__中找不到n，于是到type(aa).__dict__中找到了n，并返回其值
print(type(aa).__dict__['n'])  # 2, 其实是上面一条的调用机制

print(aa.m)  # 1, 在aa.__dict__中找不到m，于是到type(aa).__dict__中找到了m
# 因为m是一个描述符对象，于是调用__get__方法，将self.x的值返回，即1

# 下面这种方法可以直接获取到描述符对象，不会自动触发__get__方法
print(type(aa).__dict__['m'].__get__(aa, AA))  # 1, 上面一条的调用方式是这样的
# __get__的定义中，除了self，还有instance和owner，其实分别表示的就是描述符所在的实例和类

print('-'*20)
print(AA.m)  # 1, 也是一样调用了描述符
print(AA.__dict__['m'].__get__(None, AA))  #1, 类相当于调用这个
```





### :woman_juggling: property属性

首先看如下代码：

```py
class Game(object):
    def __init__(self):
        self.sun_num = 0


# 创建游戏对象
game = Game()
# 阳光数量+50
game.sun_num += 50
```

问题：给一个实例对象的属性赋值时，容易出现错误或者数据类型不对的情况，那我们如何对`sun_num`这个属性进行防护呢？

只要学习了`property`属性，那么最后就可以通过【实例对象.属性】访问属性的时候，会自动调用某个方法，可以在这个方法中对数据进行校验，从而保证属性的合法性。

<font color='red'>这一点其实和`JavaScript`中的`getter/setter`类似。即计算属性</font>

#### 初探`property`属性

```py
class Foo:
    def func(self):
        print("func被调用")

    # 定义property属性
    @property
    def prop(self):
        print("props被调用")


foo = Foo()
foo.func()  # 调用实例方法
foo.prop  # 获取property属性
"""
func被调用
props被调用
"""
```

`property`属性的访问会导致同名`property`方法的调用，该方法的返回值作为属性的值。

#### 两种使用方式

##### 装饰器方式

在类的实例方法上应用`@property`装饰器

`python`中的类有**经典类**和**新式类**，**新式类**的属性比**经典类**丰富。如果一个类继承于**object**，那么该类是新式类。

###### 经典类

<font color='red'>`python2`中经典类**只能**使用如下一种装饰器的方式来使用`property`属性</font>

```py
# coding=utf-8
class Goods(object):
    @property
    def size(self):
        return 100


obj = Goods()
ret = obj.size
print(ret)
# 100
```

###### 新式类

<font color='red'>`python3`新式类可以使用如下三种装饰器方式来使用`property`属性</font>

`settet/deleter`只在新式类中有效

```py
class Goods(object):
    @property
    def size(self):
        print("@size.getter")
        return 100

    @size.setter
    def size(self, value):
        print("@size.setter")

    @size.deleter
    def size(self):
        print("@price.deleter")

obj = Goods()
ret = obj.size
obj.size = 100
del obj.size
"""
@size.getter
@size.setter
@price.deleter
"""
```

注意点：

* 在`Goods`类中，使用`@property`装饰得到一个`property`属性的话，我们需要将`@property`装饰器放在`@xxx.setter`和`@xxx.deleter`的前面.
* 如果`@property`下面的方法是`size`，那么接下来可以使用`@property.setter`或者`@property.deleter`装饰器对另外的方法进行装饰，此时另外的方法名称必须与 `@property`装饰的那个方法名称相同，都是`size`
* 可以只有`@property`，而没有剩下的`setter/deleter`进行装饰。但是必须得先有`@property`

##### 类属性方式

此方式简单的说，创建值为`property`对象的类属性

> 当使用类属性的方式创建`property`属性时，<font color='red'>**经典类**和**新式类**无区别</font>

```py
class Foo:
    def get_bar(self):
        return "teacher"
	
    # BAR是一个类属性
    BAR = property(get_bar)

foo = Foo()
result = foo.BAR
print(result)
# teacher
```

将`property`放到类属性的位置时，依然可以完成一个`property`属性的创建，此属性的名称就是类属性的名称。

若想要为`BAR`设置新的数据，那么就要用到以下方式：

<font color='red'>property()函数实际上可以接受四个参数</font>：

1. 方法名称，调用**对象.属性**时自动触发该方法
2. 方法名称，调用**对象.属性=xxx**时自动触发该方法
3. 方法名称，调用**del 对象.属性**时自动触发该方法
4. 字符串，调用**对象.属性.__doc__**时，返回该属性的描述信息

```py
class Foo:
    test = [1]
    def get_bar(self):
        print("getter")
        return "teacher"

    def set_bar(self, value):
        print("setter")
        return value

    def del_bar(self):
        print("deleter")
        return "teacher"

    # 创建一个property类属性
    BAR = property(get_bar, set_bar, del_bar, "des")


foo = Foo()
result = foo.BAR
foo.BAR = "dk"
desc = Foo.BAR.__doc__
del foo.BAR
print(desc)
"""
getter
setter
deleter
des
"""

print(Foo.test is foo.test)	# True
print(Foo.BAR is foo.BAR)	# False
```



### :do_not_litter: 描述器（描述符）

通过学习描述符，我们可以：

1. 知道`property`的实现原理
2. 可以写出`@classmethod`，`staticmethod`等装饰器的实现方式
3. 还可以实现更巧妙的，类似于`property`的操作

#### `Descriptor`

其实描述符我们之前已经见过了，来看下面的例子：

```py
class Foo:
    @property
    def attr(self):
        print("获取属性attr的值")
        return "attr的值"

    def bar(self):
        pass

foo=Foo()
print(foo.attr)
"""
获取属性attr的值
attr的值
"""
```

上面这个例子中，`attr`是类`Foo`的一个实例方法，可以通过语句`foo.attr()`被调用。但是它被`@property`装饰之后，这个方法变成了一个`property`属性。`bar`是一个未被装饰的实例方法。我们查看一下类型`type(Foo.attr)`与`type(Foo.bar)`的结果分别为

```py
print(type(Foo.attr)) # <class 'property'>
print(type(Foo.bar)) # <class 'function'>
```

发现`Foo.attr`的类型变成了`property`，其实`@property`的作用相当于如下：

```py
attr = property(attr)
```

可以看出，`attr`被装饰过后，其实是指向了一个`property`类的实例对象。

那我们执行`foo.attr`之后，为什么最后会执行`attr`方法呢？原理是什么？

其实`property`类就是一个描述符，下面我们学习完描述符之后，我们就明白`property`属性的原理了.



##### 描述符

严格来说，如果一个类中有如下三个方法中的**任意一个**，那么这个类称为**描述符类**，用这个类创建的对象，可以成为**描述符对象**

1. `__get__`
2. `__set__`
3. `__delete__`

如果有另外一个类，这个类中有一个类属性，这个类属性对应的是上述类创建的描述符对象，我们称此时的这个类属性为**描述符**

例子如下：

```py
# 定义一个描述符类，让其创建的对象是描述符对象
class A(object):
    def __get__(self, instance, owner):
        print("get")

    def __set__(self, instance, value):
        print("set")

    def __delete__(self, instance):
        print("delete")


class B(object):
    # 定义了一个指向A()这个描述符对象的类属性，这个类属性a就是描述符
    a = A()


b = B()
b.a
# 注意属性赋值操作不会改变 b.a 的指向
b.a = 100
del b.a
"""
get
set
delete
"""
```

通过上述代码我们可以发现：

1. 在获取这个`a`描述符的时候，会自动变成调用`A()`这个描述符对象的`__get__`方法
2. 在设置这个类属性的时候，会自动变成调用`__set__`方法
3. 在删除这个类属性的时候，会自动变成调用`__delete__`方法

实际上`property`就是通过如上所述的方式来实现的

通过以上案例，我们可以为描述符下一个定义了：

> 通常，描述符是具有“绑定行为”的对象属性，其属性访问过程已被描述符协议中的方法覆盖。
>
> <font color='red'>注意，这个对象属性必须是类属性，不能写成实例属性</font>
>
> 这些方法是`__get__`、`__set__`、`__delete__`。

描述符的作用：当访问一个属性的时候，我们可以不直接给一个值。而是接一个描述符，让访问和修改时自动调用`__get__`方法和`__set__`方法。然后在这两个方法中进行某种处理，就可以实现更改操作属性行为的目的。这就是描述器所作的事情。

#####  `__getattribute__`

当调用一个属性，而属性指向一个描述符时，为什么就会去调用这个描述符呢？

其实这是由`__getattribute__()`方法控制的，其中`obj`是新式类的实例对象，因为新式类中继承了`__getattribute__`方法，当访问一个属性比如`b.x`时，会自动调用这个方法`__getattribute__`。如果调用该方法之后未找到属性，那么会调用`__getattr__`方法来处理，一般会抛出一个异常

定义如下：

```py
def __getattribute__(self, key):
    "Emulate type_getattro() in Objects/typeobject.c"
    v = object.__getattribute__(self, key)
    if hasattr(v, '__get__'):	# 如果是描述符
        return v.__get__(None, self)
    return v
```

<font color='red'>**若自己重写了类的`__getattribute__`方法，会导致描述符使用失效**</font>



##### 数据描述符 vs 非数据描述符

> 同时定义了`__get__`和`__set__`方法的描述符称为数据描述符，也叫资料描述符
>
> 只定义了`__get__`方法的描述符称为非资料描述符，也叫非数据描述符
>
> 二者的区别是：当属性名和描述符同名时，在访问这个同名属性时，如果是资料描述符就会优先访问描述符，如果是非资料描述符就会优先访问属性。
>
> <font color='red'>优先级：数据描述符>实例属性>非数据描述符</font>

* 数据描述符

```py
# 同时定义了__get__和__set__方法，是数据描述符
class M:
    def __init__(self):
        self.x = 1

    def __get__(self, instance, owner):
        return self.x

    def __set__(self, instance, value):
        self.x = value


# 调用描述符的类
class AA:
    m = M()  # m就是一个描述符
    n = 2  # n是一个普通的属性

    def __init__(self, score):
        self.score = score  # self.score是一个普通的类属性


aa = AA(100)
aa.__dict__["m"] = 2
print(aa.m)
# 1，资料描述符，优先访问描述符
```

* 非数据描述符

```py
class M:
    def __init__(self):
        self.x = 1

    def __get__(self, instance, owner):
        return self.x


# 调用描述符的类
class AA:
    m = M()  # m就是一个描述符
    n = 2  # n是一个普通的属性

    def __init__(self, score):
        self.score = score  # self.score是一个普通的类属性


aa = AA(100)
aa.__dict__["m"] = 2
print(aa.m)
# 2，非数据描述符，优先访问本身属性
```

###### 综合案例

```py
# 既有__get__又有__set__，是一个资料描述符
class M:
    def __init__(self):
        self.x = 1

    def __get__(self, instance, owner):
        print('get m here')  # 打印一些信息，看这个方法何时被调用
        return self.x

    def __set__(self, instance, value):
        print('set m here')  # 打印一些信息，看这个方法何时被调用
        self.x = value + 1  # 这里设置一个+1来更清楚了解调用机制


# 只有__get__是一个非资料描述符
class N:
    def __init__(self):
        self.x = 1

    def __get__(self, instance, owner):
        print('get n here')  # 打印一些信息，看这个方法何时被调用
        return self.x


# 调用描述符的类
class AA:
    m = M()  # m就是一个资料描述符
    n = N()  # n就是一个非资料描述符

    def __init__(self, m, n):
        self.m = m  # 属性m和描述符m名字相同，调用时发生一些冲突，优先访问资料描述符的__set__方法
        self.n = n  # 非资料描述符的情况，与m对比，直接赋值实例属性


aa = AA(2, 5)
print(aa.__dict__)  # 只有n没有m, 因为资料描述符同名时，不会访问到属性，会直接访问描述符，所以属性里就查不到m这个属性了
print(AA.__dict__)  # m和n都有
print(aa.n)  # 5, 非资料描述符同名时调用的是属性，为传入的5
print(AA.n)  # 1, 如果是类来访问，就调用的是描述符，返回self.x的值

print(aa.m)  # 3, 其实在aa=AA(2,5)创建实例时，进行了属性赋值，其中相当于进行了aa.m=2
# 但是aa调用m时却不是常规地调用属性m，而是资料描述符m
# 所以定义实例aa时，其实触发了m的__set__方法，将2传给value，self.x变成3
# aa.m调用时也访问的是描述符，返回self.x即3的结果
# 其实看打印信息也能看出什么时候调用了__get__和__set__

aa.m = 6  # 另外对属性赋值也是调用了m的__set__方法
print(aa.m)  # 7，调用__get__方法

print('-' * 20)
# 在代码中显式调用__get__方法
print(AA.__dict__['n'].__get__(None, AA))  # 1
print(AA.__dict__['n'].__get__(aa, AA))  # 1
```



##### 描述符 vs property

###### 使用`property`

`property`：把函数调用伪装成对属性的访问

想象一下你正在编写管理电影信息的代码

最后写好的`Movie`类可能看上去是这样的：

```py
class Movie(object):
    def __init__(self, title, rating, budget, gross):
        self.title = title  # 电影名字
        self.rating = rating  # 电影评分
        self.budget = budget  # 预算
        self.gross = gross  # 总利润
 
    def profit(self):
        """计算利润"""
        return self.gross - self.budget
```

你开始在项目的其他地方使用这个类，但是之后你意识到：如果不小心给电影打了负分怎么办？你觉得这是错误的行为，希望`Movie`类可以阻止这个错误。

你首先想到的办法是将`Movie`类修改为这样：

```py
class Movie(object):
    def __init__(self, title, rating, budget, gross):
        self.title = title  # 电影名字
        if rating < 0:
            raise ValueError("分数设置有误: %s" % rating)
        self.rating = rating  # 电影评分
        self.budget = budget  # 预算
        self.gross = gross  # 总利润
 
    def profit(self):
        """计算利润"""
        return self.gross - self.budget
```

但这行不通。

因为其他部分的代码都是直接通过`Movie的实例对象.rating`来赋值的——这个新修改的类只会在`__init__`方法中捕获错误的数据，但对于已经存在的类实例就无能为力了

如果有人试着运行`Movie的实例对象.rating=-100`，那么谁也没法阻止

作为一个`Python`程序员同时也是电影迷，你该怎么办？

幸运的是`property`可以解决这个问题，代码如下:

```py
class Movie(object):
    def __init__(self, title, rating, budget, gross):
        self.title = title  # 电影名字
        self.__rating = rating  # 电影评分
        self.budget = budget  # 预算
        self.gross = gross  # 总利润

    @property
    def rating(self):
        return self.__rating

    @rating.setter
    def rating(self, value):
        if value < 0:
            raise ValueError("分数设置有误: %s" % value)
        self.__rating = value

    def profit(self):
        return self.gross - self.budget


m = Movie('三傻大闹宝莱坞', 97, 964000, 1300000)
print("电影评分：", m.rating)
try:
    m.rating = -100
except ValueError as ret:
    print(ret)
```

通过`property`属性，能够实现对评分的`rating`属性的特殊操作，最终实现对属性的操作变为了调用方法，从而完成一些更复杂的工作。

花点时间来欣赏一下Python这么做是多么的优雅：

如果没有`property`，我们将不得不把所有的实例属性隐藏起来，提供大量显式的类似`get_rating`和`set_ratingt`方法。像这样编写类的话，使用起来就会不断的去调用这些`getter/setter`方法，看起来就很臃肿。更糟的是，我们需要点名中的所有`Movie的实例对象.rating=xxx`这样的代码替换为`Movie的实例对象.set_rating(value)`。

因此，`property`让我们将自定义的代码同变量的访问/设定联系在了一起，同时为你的类保持一个简单的访问属性的接口

###### `property`的不足

对`property`来说，最大的缺点就是它们不能重复使用。

举个例子，假设你想为`budget`和`gross`这些字段也添加非负检查。

下面是修改过的新类：

```py
class Movie(object):
    def __init__(self, title, rating, budget, gross):
        self.title = title  # 电影名字
        self.__rating = rating  # 电影评分
        self.__budget = budget  # 预算
        self.__gross = gross  # 总利润

    @property
    def rating(self):
        return self.__rating

    @rating.setter
    def rating(self, value):
        if value < 0:
            raise ValueError("分数设置有误: %s" % value)
        self.__rating = value

    def profit(self):
        return self.gross - self.budget

    @property
    def budget(self):
        return self.__budget

    @budget.setter
    def budget(self, value):
        if value < 0:
            raise ValueError("预算设置有误: %s" % value)
        self.__budget = value

    @property
    def gross(self):
        return self.__gross

    @gross.setter
    def gross(self, value):
        if value < 0:
            raise ValueError("总利润设置有误: %s" % value)
        self.__gross = value



m = Movie('三傻大闹宝莱坞', 97, 964000, 1300000)
print("电影评分：", m.rating)
try:
    m.rating = -100
except ValueError as ret:
    print(ret)
```

可以看到代码增加了不少，但重复的逻辑也出现了不少。虽然`property`可以让类从外部看起来接口整洁漂亮，但是却做不到内部同样整洁漂亮。

###### 描述符的优势

这就是描述符所解决的问题

描述符是`property`的升级版，允许你为重复的`property`逻辑编写单独的类来处理

下面的示例展示了描述符是如何工作的：

```py
class NonNegative(object):
    """一个可以屏蔽负数的描述符"""
    def __init__(self, default):
        self.default = default
        self.data = dict()

    def __get__(self, instance, owner):
        # 当调用描述符时 即：x.d
        # instance 就是调用的那个实例对象 x，如果是类对象则为None
        # owner 就是 type(x)
        return self.data.get(instance, self.default)

    def __set__(self, instance, value):
        # 当调用描述符时 即：x.d = val
        # instance 就是调用的那个实例对象 x
        # owner 就是 type(x)
        if value < 0:
            raise ValueError("设置有误: %s（请使用非负数）" % value)
        # 属于Movie类的一个描述符对象中存放了Moive类所有实例的该属性的值
        self.data[instance] = value
        
class Movie(object):
    # 定义描述符
    # 注意以下三个属性都是类属性，对于一个Movie类，这三个属性都只存储一份
    # 无论通过Movie类创建多少个movie实例对象，都会共享这三个类对象里的描述符
    # 因此每个movie对象在通过self.rating来访问类属性的时候，访问的都是同一个描述符对象
    rating = NonNegative(0)
    budget = NonNegative(0)
    gross = NonNegative(0)

    def __init__(self, title, rating, budget, gross):
        self.title = title
         # 注意，这里貌似是在设置实例属性，但实际最后找到了类属性，发现它是一个非数据描述符，优先触发了描述符的setter方法
        self.rating = rating
        self.budget = budget
        self.gross = gross

    def profit(self):
        return self.gross - self.budget
    
m = Movie('三傻大闹宝莱坞', 97, 964000, 1300000)
print("电影评分：", m.rating)
try:
    m.rating = -100
except ValueError as ret:
    print(ret)

print("电影预算：", m.budget)
try:
    m.budget = -4567
except ValueError as ret:
    print(ret)
```

<a href='#数据描述符 vs 非数据描述符'>**注意点：设置实例属性触发类属性数据描述符**</a>

一图搞懂逻辑关系：

![image-20240123230531842](.assets\image-20240123230531842.png)





##### `__get__` & `__set__`参数

###### 通过实例对象调用描述符

> 定义一个类叫`Person`，有一个属性`name`，可以获取、赋值。
>
> 要求赋值的时候，必须是字符串，否则报异常。

```py
class NameDes(object):
    """可以实现描述符的类"""

    def __init__(self):
        self.__name = None

    def __get__(self, instance, owner):
        print('before get')        
        return self.__name

    def __set__(self, instance, value):
        print('before set')
        
        # 如果value的值是str类型，则if成立
        if isinstance(value, str):
            self.__name = value
        else:
            raise TypeError("need a string")

    def __delete__(self, instance):
        del self.__name


class Person(object):
    # 描述符
    name = NameDes()

# 开始分析
p = Person()
p.name = "dk"	# before set

print(p.name)	# before get

p.name = 123
"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\demo.py", line 28, in <module>
    p.name = 123
    ^^^^^^
  File "d:\WEB-front-end\python_study\study\demo.py", line 16, in __set__
    raise TypeError("need a string")
TypeError: need a string
"""
```

分析过程：

1. `p.name = "dk"`，实例找不到找到类对象，检查`name`是否是描述符，结果是，则执行描述符对象中的`__set__`方法

   > <font color='red' id='access'>这一步貌似有一点和之前学过的不一样，既然`name`是一个类属性，那么使用`p.name='dk'`应该是新建了一个实例属性而不是去修改类属性，但是这里找到了类属性并且触发了修改方法。这是因为name是一个数据描述符，优先访问数据描述符而不是实例属性</font>

2. 接下来执行`__set__`方法，需要传递三个实参：

   1. `self`：表示描述符对象
   2. `instance`：表示`Person`类创建的实例`p`
   3. `value`：表示新设置的`'dk'`值

3. `p.name`，实例找不到找到类对象，检查`name`是否是描述符，结果是，则执行描述符对象中的`__get__`方法

4. 接下来执行`__get__`方法，需要传递三个实参：

   1. `self`：表示描述符对象
   2. `instance`：表示`Person`类创建的实例`p`
   3. `owner`：表示`Person`这个类对象，即`instance`的父类

**两图搞懂——创建流程**

![image-20240123193144384](.assets\image-20240123193144384.png)

![image-20240123195312637](.assets\image-20240123195312637.png)



###### 通过类对象调用描述符

```py
class M:
    def __init__(self):
        self.x = 1

    def __get__(self, instance, owner):
        print(instance, owner)
        return self.x

    def __set__(self, instance, value):
        self.x = value


# 调用描述符的类
class AA:
    m = M()  # m就是一个描述符
    n = 2  # n是一个普通的属性

    def __init__(self, score):
        self.score = score  # self.score是一个普通的类属性

print(AA.m)
"""
None <class '__main__.AA'>
1
"""
```

可以看出通过类对象访问描述符时，`__get__`方法传递的参数变了，`instance`为`None`，`owner`为类对象

#### 注意事项

* 不可以使用实例属性定义描述符

  > 官方有明确定义，可以看下面示例代码

  ```py
  class NameDes(object):
      def __init__(self):
          self.__name = None
  
      def __get__(self, instance, owner):
          print('__get__被调用')
          return self.__name
  
      def __set__(self, instance, value):
          print('__set__被调用')
          if isinstance(value, str):
              self.__name = value
          else:
              raise TypeError("必须是字符串")
  
  
  class Person(object):
      def __init__(self):
          self.name = NameDes()
  
  
  p = Person()
  
  print(p.name)  # <__main__.name_des object at 0x0000011E4D568AC8>
  ```

  以上代码并没有触发描述符的`__get__`方法，而是直接打印了描述符对象的地址。

  结论：如果将描述符对象直接赋值给实例属性，此时相当于`name`指向了一个普通的对象，只不过这个对象中有`__get__`、`__set__`方法罢了，不会自动调用其`__get__`方法，而如果类属性是一个描述符，则会自动调用其`__get__`方法。

* `descriptor`的实例一定是一个类的类属性，因此<font color='red'>该类的多个实例会共享该类属性，一个实例对该描述符的修改，另外一个实例也可以感受到</font>

  <a href='#描述符的优势'>解决方式</a>



#### 应用场景

##### 类型检查

因为`python`是一个动态类型解释性语言，不像`c/c++`等静态编译型语言，数据在编译阶段即可进行验证。`python`中必须添加额外的类型检查逻辑代码才能做到这一点，这就是描述符的初衷。比如，有一个测试类`Test`，其具有一个类属性`name`

```py
class Test(object):
    name = None
```

正常情况下，`name`的值(其实应该是对象, `name`是引用)都应该是字符串，但是因为`Python`是动态类型语言，即使执行`Test.name = 3`，解释器也不会有任何异常。当然可以想到解决办法，就是提供一个`getter`，`setter`方法来统一读写`name`，读写前添加安全验证逻辑。

代码如下：

```py
class Test(object):
    name = None

    @classmethod
    def get_name(cls):
        return cls.name

    @classmethod
    def set_name(cls, val):
        if isinstance(val, str):
            cls.name = val
        else:
            raise TypeError("Must be an string")
```

虽然以上代码勉强可以实现对属性赋值的类型检查，但是会导致类型定义的臃肿和逻辑的混乱。

从`OOP`(面向对象编程)思想来看，只有属性自己最清楚自己的类型，而不是它所在的类，因此如果能将类型检查的逻辑根植于属性内部，那么就可以完美的解决这个问题，而描述符就是这样的利器。

为`name`属性定义一个(数据)描述符类，其实现了`__get__`和`__set__`方法，代码如下：

```py
class NameDes(object):
    def __init__(self):
        self.__name = None
    def  __get__(self, instance, owner):
        print('call __get__')
        return self.__name
    def  __set__(self, instance, value):
        print('call __set__')
        if  isinstance(value,str):
            self.__name = value
        else:
            raise TypeError("Must be an string")

class Test(object):
    name = NameDes()
```

从打印的输出信息可以看到，当使用实例访问`name`属性(即执行`t.name`)时，便会调用描述符的`__get__`方法(注意`__get__`中添加的打印语句)。当使用实例对`name`属性进行赋值操作时(即`t.name = '小小明明'`)，从打印出的`call set`可以看到描述符的`__set__`方法被调用

至此，可以发现描述符的作用和优势，以弥补Python动态类型的缺点。

##### 实现classmethod

```py
# 描述符类，含有__get__方法
class classmethod_new(object):
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        print(self.func, instance, owner)

        # return self.func 此方法不能实现
        # return self.func(owner) 这是不可以的，而是要用
        def call(*args):
            self.func(owner, *args)

        return call


class A(object):
    M = 100

    def a(self):
        print("实例方法")

    # 这里用一个类作为装饰器
    # b=classmethod_new(b)
    # 相当于设置了一个类属性 b,而且该类属性指向lassmethod_new(b)的返回值————一个描述符对象
    # 因此b是一个描述符
    @classmethod_new
    def b(cls):
        print("类方法1")
        print(cls.M)

    @classmethod_new
    def c(cls, num1, num2):
        print("类方法2")
        print(cls.M + num1 + num2)

    def d():
        print("静态方法")


obj = A()
# obj.b获取obj的属性b，找到了类对象，发现是一个描述符，因此触发描述符的__get__方法
# __get__方法的返回值是一个函数，因此obj.b=__get__()，返回值是一个新函数
# obj.b()将该返回的新函数进行调用
obj.b()
A.b()
obj.c(11, 22)

"""
<function A.b at 0x000002671B139120> <__main__.A object at 0x000002671B11AC90> <class '__main__.A'>
类方法1
100
<function A.b at 0x000002671B139120> None <class '__main__.A'>
类方法1
100
<function A.c at 0x000002671B1391C0> <__main__.A object at 0x000002671B11AC90> <class '__main__.A'>
类方法2
133
"""
```

###### 一图搞懂

![image-20240124003820609](.assets\image-20240124003820609.png)



##### 只读属性

想要制作一个只读的资料描述符，需要同时定义`__set__`和`__get__`，并且在`__set__`中抛出一个`AttributeError`异常。定义一个引发异常的`__set__`就足够让一个描述符成为资料描述符，而且是只读的。

具体例子见下面**惰性计算**，介绍了`Readonly`只读描述符

##### 惰性计算

惰性计算：第一次计算的时候才会真正的计算，以后都会直接使用第一次计算的值。

惰性计算：一开始不会真正的计算，什么时候需要就什么时候计算

```py
class LazyProperty(object):
    """
    实现惰性求值(访问时才计算，并将值缓存)
    利用了 obj.__dict__ 优先级高于 non-data descriptor 的特性
    第一次调用 __get__ 以同名属性存于实例字典中，之后就不再调用 __get__
    """
    def __init__(self, fun):
        self.fun = fun

    def __get__(self, instance, owner):
        print("---LazyProperty __get__---")
        if instance is None:
            return self
        value = self.fun(instance)
        
        # 实现惰性计算的关键步骤
        setattr(instance, self.fun.__name__, value)
        # 将计算出的面积直接设置到实例对象上 {area:value}
        # 这样下一次取面积的时候，实例属性的优先级比这个非数据描述符更高，因此会优先访问实例属性
        return value


class ReadonlyNumber(object):
    """
    实现只读属性(实例属性初始化后无法被修改)
    利用了 data descriptor 优先级高于 obj.__dict__ 的特性
    当试图对属性赋值时，总会先调用 __set__ 方法从而抛出异常
    """
    def __init__(self, value):
        self.value = value

    def __get__(self, instance, owner):
        return self.value

    def __set__(self, instance, value):
        raise AttributeError(
            "'%s' is not modifiable" % self.value
         )


class Circle(object):

    pi = ReadonlyNumber(3.14)

    def __init__(self, radius):
        self.radius = radius

    @LazyProperty
    def area(self):
        print('Computing area')
        return self.pi * self.radius ** 2


print("---1--")
a = Circle(4)
print("---2--")
print(a.area)
print("---3--")
print(a.area)
print("---4--")
```

###### `setattr`

`setattr(instance,key,value)`：在实例对象`instance`的`__dict__`增加一个键值对`key-value`

```py
class A:
    pass

a = A()
print(a.__dict__)
setattr(a, "a", 1)
print(a.__dict__)
"""
{}
{'a': 1}
"""
```

以上代码还有个缺陷，当⚪的半径改变之后，得到的面积依旧是之前设置的实例属性，不会重新计算。

解决方式：当半径改变之后，删除`area`这个实例属性，这样下一次访问面积的时候依旧会触发非数据描述符的`__get__`方法，将新得到的面积设置为实例属性



### :penguin: 元类（type)

元类：就是一个特殊的类，专门用来创建其他类的类。

> —...—>元类(`type`)——创建——>元类(`type`)——创建——>类——创建——>对象
>
> 普通类规定了实例对象的性质
>
> 元类规定了普通类的性质

```py
class ObjectCreator(object):  # ObjectCreator是一个类对象
    pass

a = ObjectCreator()  # a是一个实例对象
print(a)
# <__main__.ObjectCreator object at 0x000001C38827A450>
# 表示当前main模块下的 ObjectCreator 类创建的实例对象

b = a  # b也指向a指向的那个实例对象
A = ObjectCreator  # A也指向ObjectCreator指向的那个类对象
c = A() # A()也能创建实例对象
print(c)
# <__main__.ObjectCreator object at 0x000001C6F381A630>
<__main__.ObjectCreator object at 0x000001C6F381A450>
```



#### 动态创建类

一个动态创建类的示例代码如下：

```py
def choose_class(name):
    if name == "foo":
        class Foo(object):
            pass
        return Foo
    else:
        class Bar(object):
            pass

a = choose_class("foo")
a()
```

* 类的定义可以放在函数中
* 给函数传递的参数不一样，得到的类对象不一样，从而创建的实例对象就不一样

##### type创建类

在之前的学习中，我们已经知道，`type`可以测试一个数据的类型

```py
print(type([1,2,3]))
# <class 'list'>
```

实际上`type`还有第二个功能：以函数的方式创建一个类。

<font color='red'>这和`react`中使用`jsx`语法和`createElement`语法两种方式创建虚拟`dom`的方式相同</font>

> `type`会根据传入的参数不同，执行不同的任务。例如`type('a')`表示获取`'a'`的数据类型。
>
> 而根据传入的参数不同还可以表示创建一个类。这种语法现象叫做重载
>
> 但是开发的时候要尽量注意：尽量不要让一个函数具有两种完全不同的功能，`python`这样做的目的是为了保持向后兼容性。

`type()`创建类的方式如下：

> `type(类名，由父类名称组成的元组(对于无继承的情况，可以为空)，包含属性的字典)`

示例代码如下：

```py
class A:
    pass


print(help(A))

B = type("B", (A,), {})
print(help(B))
"""
Help on class A in module __main__:

class A(builtins.object)
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables
 |
 |  __weakref__
 |      list of weak references to the object

None
Help on class B in module __main__:

class B(A)
 |  Method resolution order:
 |      B
 |      A
 |      builtins.object
 |
 |  Data descriptors inherited from A:
 |
 |  __dict__
 |      dictionary for instance variables
 |
 |  __weakref__
 |      list of weak references to the object

None
"""
```

###### 添加类属性

同时使用`type()`创建类的同时，还可以为类赋予一些初始类属性。

```py
class Foo(object):
    bar = True  # 类属性


Foo2 = type("Foo2", (object,), {"bar": True})

a = Foo()
b = Foo2()

print(a.bar)	# True
print(b.bar)	# True
```

###### 添加实例方法

同时使用`type()`创建类的同时，还可以为类赋予一些初始实例方法。

```py
class Foo(object):
    bar = True  # 类属性

def echo_bar(self):
    # 实例对象中没有bar属性，类对象中也没有bar属性，但是从父类所继承的Foo中找到了bar属性
    print(self.bar)

# 让FooChild类中的echo_bar属性，指向了上面定义的函数
FooChild = type("FooChild", (Foo,), {"echo_bar": echo_bar})

b = FooChild()

b.echo_bar()
# true
```

###### 添加类方法 & 静态方法

同时使用`type()`创建类的同时，还可以为类赋予一些初始静态方法、类方法。

方法依然是使用装饰器

```py
class A(object):
    num = 100

def print_b(self):
    print(self.num)

@staticmethod
def print_static():
    print("---haha---")


@classmethod
def print_class(cls):
    print(cls.num)

B = type(
    "B",
    (A,),
    {"print_b": print_b, "print_static": print_static, "print_class": print_class},
)

b = B()
b.print_b()  # 调用实例方法
b.print_static()  # 调用静态方法
b.print_class()  # 调用类方法
"""
100
---haha---
100
"""
```

#### 深入理解元类

元类就是用来创建类对象的一个对象，可以将元类理解为类的类。

> 函数`type`就是一个元类，使用`type()`可以创建`python`中的所有类。
>
> 那为什么`type`采用小写而不是`Type`呢？可能是为了和`str/int`等保持一致。

关于`type`就是创建类对象的类，我们可以通过检查`__class__`属性来看到这一点。

```py
B = type(
    "B",
    (A,),
    {"print_b": print_b, "print_static": print_static, "print_class": print_class},
)

print(B.__class__)
# <class 'type'>

class A(object):
    num = 100
print(A.__class__)
# <class 'type'>

age = 35
print(age.__class__.__class__)
# <class 'type'>

print(age.__class__.__class__.__class__)
# <class 'type'>
```

一切对象最顶层都由`type`创建而来，包括`type`类本身都是由`type`类创建而来

##### 实例 vs 继承

`python`中一切皆对象。这包括整数、字符串、函数、模块、包以及类，它们全部都是对象，而且它们都是从`type`这个类创建而来。

> 注意，只能说它们是由`type`类创建而来的，是`type`类的实例对象。
>
> 但是不能说它们是继承于`type`类。
>
> 创建————是类对象与实例对象之间的关系。
>
> 继承————是父子类对象直接的关系。<font color='red'>具有继承关系的类对象创建出来的实例具有非常相近的性质
>
> </font>
>
> 类与实例的关系是一种抽象与具体的关系，即实现/创建
>
> 类与类之间的关系是一种抽象与抽象的关系，即继承。
>
> 我们寻找一个实例对象的属性的时候，先到其自身，再到其类对象（具体到抽象），再到类对象相似的继承对象（抽象到抽象）
>
> 我们这里讨论的元类是一种创建的关系而不是继承的关系。

#### 自定义元类

除了默认使用`type()`创建一个类，我们还可以自己指定创建类的方式，如下

##### `metaclass`

* 用法1：`metaclass=func`，传递一个函数

```py
# 如果在定义Foo类的时候没有指定metaclass，那么就用默认的type创建Foo类对象
# 如果指定了metaclass，那么metaclass是什么，就用什么来创建这个类对象
""" class Foo(object,metaclass):
    pass """


def upper_attr(class_name, class_parents, class_attr):
    # 遍历属性字典，把不是__开头的属性名字变为大写
    new_attr = {}
    for name, value in class_attr.items():
        if not name.startswith("__"):
            new_attr[name.upper()] = value

    return type(class_name, class_parents, new_attr)


# 创建Foo这个类的时候，后面的括号相当于在传递参数
# 这里的metaclass=upper_attr，相当于传递了一个关键字参数
# object相当于一个位置参数


# 当创建Foo这个类的时候，不再是由type()进行创建，而是通过metaclass指定的函数进行创建
# 因此metaclass这个关键字参数接受的函数的返回值应该是一个类，即upper_attr返回一个类，最终作为Foo的指向
# 在创建类的时候，upper_attr会接收到python解释器传递的三个参数：class_name, class_parents, class_attr
# class_name即类名————"Foo"
# class_parents即继承的类————(object,)
# class_attr即定义的类对象属性（包括类属性、类方法、实例方法、静态方法等存放于类对象的属性）————{"bar":"bip"}
class Foo(object, metaclass=upper_attr):
    bar = "bip"


print(hasattr(Foo, "bar"))  # 判断是否有类属性bar
# False
print(hasattr(Foo, "BAR"))  # 
# True

f=Foo()
print(f.BAR)	# bip
```

* 用法2：`metaclass=class`，<font id='meta'>传递一个类</font>

  > 提要：`object`这个类也是由`type()`创建而来的，也就是说`object`是`type`的一个实例对象
  >
  > 怎么理解：自定义元类不再是继承object，而是继承type
  >
  > 自定义的元类继承于`type`，表示自定义的这个类具有和`type`类非常相似的功能————都可以创建类
  >
  > 自定义元类继承于`type`，说明我们可以把自定义元类当作元类来使用。自定义元类创建的实例可以近似为`type`元类创建的实例。
  >
  > 二者创建出来的实例具有相似的实例

```py
# 注意，不再是继承object，而是继承type
class UpperAttrMetaClass(type):
    def __new__(cls, class_name, class_parents, class_attr):
        # 遍历属性字典，把不是__开头的属性名字变为大写
        new_attr = {}
        for name, value in class_attr.items():
            if not name.startswith("__"):
                new_attr[name.upper()] = value

        return type(class_name, class_parents, new_attr)


# python3的语法
""" 
    创建类对象的时候,会调用metaclass,其返回值作为Foo类对象
    此时metaclass=UpperAttrMetaClass,该位置参数传递的是一个类,而不是用法1里传递一个函数
    但是我们还是可以用1的方式去理解:Foo=UpperAttrMetaClass(cls,lass_name, class_parents, class_attr)
    调用UpperAttrMetaClass()时就相当于调用了该类的__new__方法,而__new__方法返回了一个type()创建的类对象
    因此Foo就是该类对象
"""
class Foo(object, metaclass=UpperAttrMetaClass):
    bar = "bip"

""" 
# python2的语法
class Foo_py2(object):
    __metaclass__ = UpperAttrMetaClass
    bar = "bip"
 """

print(hasattr(Foo, "bar"))  # 判断是否有类属性bar
print(hasattr(Foo, "BAR"))  # 判断是否有类属性bar

f = Foo()
print(f.BAR)
```















# :yin_yang: 数据容器

> `Python`中的数据容器是指一种可以容纳多份数据的数据类型
>
> 每一个元素，可以是<font color='red'>任意的数据类型</font>，例如字符串、数字、布尔等

数据容器根据特点不同，例如：

* 是否支持重复元素
* 是否可以修改
* 是否有序
* `...`

可以分为以下五类数据容器：

| 容器   | python |
| ------ | ------ |
| 列表   | list   |
| 元组   | tuple  |
| 字符串 | str    |
| 集合   | set    |
| 字典   | dict   |

### :face_with_thermometer: list——列表

#### 列表的特点

* 可以容纳多个元素
* 可以容纳不同类型的元素
* 数据有序存储
* 允许重复数据
* 可以修改列表元素

列表的定义方式：

```py
# 字面量
[1, 2, 3, 4, 5]

# 定义变量
arr = [1, 2, 3, 4, 5]

# 定义空列表
arr1 = []
arr2 = list()
```

```py
arr = [1, 2, 3]
print(arr, type(arr))
# [1, 2, 3] <class 'list'>

arr = [1, 'str', 3]
print(arr, type(arr))
# 列表中元素的数据类型不受限制
# [1, 'str', 3] <class 'list'>

arr = [1, [1, 2], 3]
print(arr, type(arr))
# 列表中还可以嵌套列表
# [1, [1, 2], 3] <class 'list'>
```

#### 指定初始长度的列表

```py
l1 = [None] * 10
tmp = [[]] * 3
# [[],[],[]]
# 注意，此方法生成的内部的三个列表其实是同一个

# 推导式
l2 = [None for i in range(10)]
print(l1)
print(l2)
"""
[None, None, None, None, None, None, None, None, None, None]
[None, None, None, None, None, None, None, None, None, None]
"""
```

#### 下标索引

```py
arr = [11, 22, 33, 44, 55, 66]
for index in range(0, len(arr)):
    print(arr[index], end=" ")
# 11 22 33 44 55 66
```

```py
arr = [11, 22, 33, 44, 55, 66]
for index in range(0, len(arr)):
    print(arr[-index - 1], end=" ")
# 66 55 44 33 22 11
# 下标 -1 表示最后一个元素，-2表示倒数第二个元素
```

#### 常用方法

* ` l = [none]*100`：声明一个大小为`100`，且元素全部为`none`的列表

* `arr.index(ele)`

  > 查找指定元素在列表的下标
  >
  > 如果找不到，会【报错】：`ValueError`

  ```py
  arr = [11, 22, 33, 44, 55, 66]
  print(arr.index(44))
  # 3
  
  print(arr.index(4))
  """
  Traceback (most recent call last):
    File "d:\WEB-front-end\python_study\study\1. day1\quickSort.py", line 2, in <module>
      print(arr.index(4))
            ^^^^^^^^^^^^
  ValueError: 4 is not in list
  """
  ```

* `arr[index]=value`

  > 修改特定位置的元素值

* `arr.insert(index,value)`

  > 在指定下标`index`处，插入指定的元素`value`

  ```py
  arr = [11, 22, 33, 44, 55, 66]
  arr.insert(1, 15)
  print(arr)
  # [11, 15, 22, 33, 44, 55, 66]
  ```

* `arr.append(value)`

  > 将指定的元素`value`追加到列表的尾部

  ```py
  arr = [11, 22, 33, 44, 55, 66]
  arr.append(77)
  print(arr)
  # [11, 22, 33, 44, 55, 66, 77]
  ```

* `arr.extend(list)`

  > 将一批元素追加到列表的末尾

  ```py
  arr = [11, 22, 33, 44, 55, 66]
  arr.extend([77, 88, 99])
  print(arr)
  # [11, 22, 33, 44, 55, 66, 77, 88, 99]
  ```

* `del arr[index]`

  > 删除指定位置的元素

  ```py
  arr = [11, 22, 33, 44, 55, 66]
  del arr[2]
  print(arr)
  # [11, 22, 44, 55, 66]
  ```

* `arr.pop(index)`

  > 取出并且删除删除指定位置的元素

  ```py
  arr = [11, 22, 33, 44, 55, 66]
  num = arr.pop(2)
  print(arr, num)
  # [11, 22, 44, 55, 66] 33
  ```

* `arr.remove(value)`

  > 删除`arr`中<font color='red'>第一个值为`value`的元素</font>

  ```py
  arr = [11, 22, 33, 44, 55, 66]
  arr.remove(33)
  print(arr)
  # [11, 22, 44, 55, 66]
  ```

* `arr.clear()`

  >清空列表内容

* `arr.count(value)`

  > 统计`value`元素在`arr`中出现的次数

  ```py
  arr = [11, 22, 33, 44, 55, 66, 33]
  
  print(arr.count(33))
  #2
  ```

* `length = len(arr)`

  > 返回列表长度
  
* `arr.sort(key=func,reverse=True|False)`

  > 对列表按照指定规则进行自定义排序
  >
  > key：排序函数
  >
  > reverse：是否反转

  ```py
  arr = [["a", 36], ["b", 44], ["c", 55]]
  
  arr.sort(key=lambda item: item[1], reverse=True)
  print(arr)
  
  # [['c', 55], ['b', 44], ['a', 36]]
  ```

* `arr.copy()`

  > 返回对`arr`的一个浅拷贝对象

#### 列表的遍历

##### while

```py
index = 0
arr = [1, 2, 3, 4, 5, 6]
while index < len(arr):
    print(arr[index], end=" ")
    index += 1
```

##### for

```py
index = 0
arr = [1, 2, 3, 4, 5, 6]

for item in arr:
    print(item, end=" ")
# 1 2 3 4 5 6

for index in range(0, len(arr)):
    print(arr[index], end=" ")
# 1 2 3 4 5 6
```



### :o: tuple——元组

> 列表中元素是可以被修改的。如果想要传递的信息不被修改，列表就不合适了

#### 元组的特点

* 可以封装多个、不同类型的元素
* <font color='red'>元组一旦定义完成，就不可以修改（元组内元素无法修改、增加、删除等）</font>
* 元组内部的元素类型没有限制，元组内部可以嵌套元组

#### <font color='red'>注意点</font>

若元组内部嵌套了列表`list`，列表`list`里的内容是可以修改的，这实际上是引用对象和基本数据的区别，只要`list`本身的地址不改变即可

#### 元组的定义

```py
# 极简定义
# 不写括号，也是定义了一个元组
a = 1, 2, 3, 4, 5

# 交换两个变量的值
# 右边定义元组，左边拆包
num1,num2 = num2,num1

# 定义元组字面量
(1, 2, 3, 4, 5, 6)

# 定义元组变量
tuple1 = (1, 2, 3, 4, 5, 6)

# 定义空元组
tuple2 = ()
tuple3 = tuple()

print(type(tuple1))
# <class 'tuple'>
```

**<font color='#008c8c'>如果元组里只有一个元素，这个元素后面需要加逗号</font>**

```py
t1 = (1,)
```

**<font color='#008c8c'>如果不加逗号，t1就直接被赋值为了该元素，t1不再是元组类型</font>**

```py
t1 = (1)
# <====>
t1 = 1
```

#### 元组的下标

元组的下标索引使用方式和列表完全相同

```py
t1 = (1, (1, 2, 3, 4), (5, 6, 7, 8))
print(t1[2][2])
# 7
```

#### 元组的操作

由于元组不可修改，因此没有`extend()`、`append()`等方法

* `index(value)`

  > 查找某个数据元素`value`，返回第一个`value`的下标，不存在`value`则报错

* `count(value)`

  > 统计某个数据元素`value`在当前元组出现的次数

* `len(元组)`

  > 统计元组内元素的个数

#### 元组的遍历

可以通过`while`和`for`遍历



### :first_quarter_moon: string——字符串

> 之前我们已经学习过字符串，这里我们站在容器的视角重新认识一下字符串。

字符串是字符的容器，一个字符串可以存放任意数量的字符。

#### 字符串的特点

* 和元组一样，字符串是一个不可修改的数据容器

  所以，修改、删除指定下标的字符，追加字符等操作都是无法进行的

  如果要修改，只能<font color='red'>重新定义一个新字符串</font>

#### 字符串的下标索引

```py
str = "itheima"
print(str[0])
# i
print(str[-1])
# a
```

#### 字符串的方法

* `str.index(value)`

  ```py
  str = "itheima"
  print(str.index("h"))
  # 2
  print(str.index("i"))
  # 0
  print(str.index("g"))
  """
  Traceback (most recent call last):
    File "d:\WEB-front-end\python_study\study\1. day1\quickSort.py", line 2, in <module>
      print(str.index("g"))
            ^^^^^^^^^^^^^^
  ValueError: substring not found
  """
  ```

* `str.replace(str1,str2)`

  > 将字符串内的全部：字符串1，替换为：字符串2
  >
  > 注意：不是修改字符串本身，而是得到了一个新的字符串，原来的字符串保持不变

  ```py
  str = "ithemaima"
  print(str.replace("ma", "iu"))
  # itheiuiiu
  ```

* `str.split(str1)`

  > 按照指定的分割字符串`str1`，将字符串划分为多个字符串，并且存入列表对象中
  >
  > 该函数的返回值是类型是——`list`

  ```py
  str = "ithemaima"
  print(str.split("m"))
  # ['ithe', 'ai', 'a']
  ```

* `str.strip()`:去除前后

  `str.lstrip()`：去除前面

  `str.rstrip()`：去除后面

  ```py
  str = "    ithemaima  "
  # 去除前后空格
  print(str.strip())
  # ithemaima
  
  str = "1234567821"
  # 去除前后指定字符
  print(str.strip("12"))
  # 345678
  
  str = "1234567812"
  print(str.strip("12"))
  # 345678
  ```

* `str.count(value)`

  ```py
  str = "1234567812"
  print(str.count("12"))
  # 2
  ```

* `len(str)`

  ```apl
  str = "1234567812"
  print(len(str))
  # 10
  ```

* `str1.startswith('str2')`

  ```py
  "__123".startswith("__")
  # True
  ```

* `str1.upper()`

  ```py
  print('abc'.upper())
  # ABC
  ```

* `str1.lower()`

#### 字符串比较大小

<a href='https://tool.oschina.net/commons?type=4'>对照表</a>

---

### :lantern: 序列

* 什么是序列？

  > 序列是指：内容连续、有序、可以用下标索引的一类数据容器
  >
  > 列表`list`，元组`tuple`，字符串`string`均可以视为序列

#### 序列的常用操作

##### 切片

> 从一个序列中，取出一个子序列
>
> 对序列的切片操作不会影响到序列本身，而是会得到一个新的序列

* 语法：序列 [起始下标：结束下标：步长]

> 起始下标：表示从何处开始。可以留空，表示从头开始切片
>
> 结束下标：（不含）表示在何处结束，可以留空，留空视作截取到结尾
>
> 步长：截取元素的间隔；步长为负数表示反向取，此时起始下标和结束下标也要反向标记

```py
str = "1234567812"
str1 = str[0:6:2]
print(str1)
# 135

str = "1234567812"
str1 = str[-1:0:-2]
print(str1)
# 28642

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
arr1 = arr[::2]
print(arr, arr1)
# [1, 2, 3, 4, 5, 6, 7, 8, 9] [1, 3, 5, 7, 9]

# 序列的反转
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(arr[::-1])
# [9, 8, 7, 6, 5, 4, 3, 2, 1]

# 列表切片的赋值
a = [1, 2, 3]
a[0:2] = [11, 22, 33, 44, 55]
print(a)
# [11, 22, 33, 44, 55, 3]
```

---

### :sailboat: set——集合

> 列表、元组、字符串，基本上满足了大多数的使用场景
>
> 为何要学习新的集合类型呢？
>
> 以上三种数据结构都：支持重复元素 而且 元素之间是有序的

#### 集合的特点

* 不支持重复的元素
* 而且内容之间是无序的
* 不支持下标索引，因为元素之间是无序的
* 集合是允许被修改的

#### 集合的定义

```py
# 定义集合字面量
{1, 2, 3, 4}

# 定义集合遍历
set1 = {1, 2, 3, 4, 5}

# 定义空集合
set1 = set()
```

<font color='#008c8c'>**不能直接用`{}`来定义一个空的集合**</font>

```py
set2 = {}
set2: dict = {}
```

#### 集合的方法

* `in`：判断集合中是否含有某个关键字

  ```py
  # 创建一个set  
  my_set = {1, 2, 3, 4, 5}  
    
  # 检查元素是否在set中  
  if 3 in my_set:  
      print("3在my_set中")  
  else:  
      print("3不在my_set中")
  ```

  >在`Python`中，`set` 类型并没有提供专门的函数来检查某个元素是否存在于集合中。通常，我们会使用 `in` 关键字来进行这种检查。`in` 关键字是Python中用于检查元素是否存在于序列类型（如列表、元组、字符串和集合）中的标准方式。

* `set1.add(value)`

  ```py
  set1 = {1, 2, 3}
  set1.add(4)
  set1.add(1)
  print(set1)
  # {1, 2, 3, 4}
  ```

* `set1.remove(value)`

  ```py
  set1 = {1, 2, 3}
  set1.remove(3)
  print(set1)
  # {1, 2}
  ```

* `set1.pop(value)`

  > 从集合中随机取出一个元素

  ```py
  set1 = {1, 2, 3}
  value = set1.pop()
  print(value, set1)
  # 1 {2, 3}
  ```

* `set1.clear()`

  > 清空集合

* `set1.difference(set2)`

  > 取得`set1`和`set2`的差集（`set1`有的而`set2`没有的)
  >
  > 返回一个新集合，而`set1`和`set2`保持不变

  ```py
  set1 = {1, 2, 3}
  set2 = {1, 5, 6}
  set3 = set1.difference(set2)
  print(set3, set1, set2)
  # {2, 3} {1, 2, 3} {1, 5, 6}
  ```

* `set1.difference_update(set2)`

  > 在`set1`内，删除和`set2`相同的元素
  >
  > `set1`被修改，而`set2`保持不变

  ```py
  set1 = {1, 2, 3}
  set2 = {1, 5, 6}
  set1.difference_update(set2)
  print(set1, set2)
  # {2, 3} {1, 5, 6}
  ```

* `set1.union(set2)`

  > 将`set1`和`set2`合并成一个新的集合
  >
  > 返回一个新集合，`set1`和`set2`保持不变

  ```py
  set1 = {1, 2, 3}
  set2 = {1, 5, 6}
  set3 = set1.union(set2)
  print(set3, set1, set2)
  # {1, 2, 3, 5, 6} {1, 2, 3} {1, 5, 6}
  ```

* `set1.intersection(set2)`：求交集

  ```py
  set1 = {1, 2, 3, 4, 5}  
  set2 = {4, 5, 6, 7, 8}  
    
  intersection_set = set1.intersection(set2)  
  print(intersection_set)  # 输出: {4, 5}
  ```
  
* `&`操作符求交集：

  ```py
  set1 = {1, 2, 3, 4, 5}  
  set2 = {4, 5, 6, 7, 8}  
    
  intersection_set = set1 & set2  
  print(intersection_set)  # 输出: {4, 5}
  ```
  
  
  
* `len(set1)`

  > 统计集合内元素数量

#### 集合的遍历

<font color='red'>集合不支持下标索引，不能使用`while`循环遍历，只能使用`for`循环遍历</font>

```py
set1 = {1, 2, 3}
for item in set1:
    print(item, end=" ")
# 1 2 3 
```



### :tada: dict——字典

> 记录一组`key`—`value`映射关系

#### 字典的特点

* 字典的`key`不可以重复

* `python3.5`之后字典中元素实际上是有序的，遍历时的顺序和定义时的顺序一致，在`python3.5`之前字典中的元素是无序的

* 不可变类型才可以当作`key`

  * `number`
  * `string`
  * `tuple`

  可以当作`key`

  * `list`
  * `dict`
  * `set`

  不可以当作`key`

#### 字典的定义

> 字典的定义，同样使用`{}`，不过存储的元素是一个个的：键值对

```py
# 定义字典字面量
{"a": 1, "b": 2, "c": 3}

# 定义字典变量
dict1 = {"a": 1, "b": 2, "c": 3}

# 定义空字典
dict1 = {}
dict1 = dict()

print(type(dict1))
# <class 'dict'>
```

```py
# 定义字典变量
dict1 = {"a": 1, "b": 2, "c": 3, "a": 4}

# 不允许重复的key，后者会将前者覆盖掉
print(dict1)
# {'a': 4, 'b': 2, 'c': 3}
```

#### 字典的嵌套

> <font color='red'>字典的`key`和`value`可以是任意数据类型，（但是`key`不能为可变类型)</font>
>
> 因此字典是可以嵌套的

```py
# 定义字典变量
dict1 = {"a": {"d": 1, "e": 2}, "b": 2, "c": 3}

print(dict1["a"])
# {'d': 1, 'e': 2}
```



#### 字典的操作

* `dict1[key]`：获取字典元素

  ```py
  # 定义字典变量
  dict1 = {"a": 1, "b": 2, "c": 3, "a": 4}
  
  print(dict1["a"])
  # 4
  ```

* `dict1[key]=value`：修改 / 新增字典元素

  ```py
  # 定义字典变量
  dict1 = {"a": {"d": 1, "e": 2}, "b": 2, "c": 3}
  
  print(dict1["a"])
  
  dict1["a"] = 1
  dict1["e"] = 5
  
  print(dict1)
  # {'d': 1, 'e': 2}
  # {'a': 1, 'b': 2, 'c': 3, 'e': 5}
  ```

* `dict1.pop(key)`：取出并且删除字典中指定的键值对

  ```py
  # 定义字典变量
  dict1 = {"a": {"d": 1, "e": 2}, "b": 2, "c": 3}
  
  value = dict1.pop("a")
  print(value)
  print(dict1)
  """
  {'d': 1, 'e': 2}
  {'b': 2, 'c': 3}
  """
  ```

* `dict1.clear()`：清空字典

  ```py
  # 定义字典变量
  dict1 = {"a": {"d": 1, "e": 2}, "b": 2, "c": 3}
  dict1.clear()
  print(dict1)
  # {}
  ```

* `dict1.keys()`：获取字典的全部`key`

  ```py
  # 定义字典变量
  dict1 = {"a": {"d": 1, "e": 2}, "b": 2, "c": 3}
  print(dict1.keys())
  # dict_keys(['a', 'b', 'c'])
  print(type(dict1.keys()))
  # <class 'dict_keys'>
  ```

* `dict1.items()`：返回包含`([key,value])`的可迭代对象

  ```py
  dict = {"a": 1, "b": 2, "c": 3}
  items = dict.items()
  print(items)
  
  for key, value in items:
      print(key, value)
      
  """
  dict_items([('a', 1), ('b', 2), ('c', 3)])
  a 1
  b 2
  c 3
  """
  ```

* `len(dict1)`：获取字典的元素个数

* `has_key(key)`：判断字典中是否含有某个`key`

* `if key in dict1:`判断字典中是否含有某个`key`

#### 字典的遍历

> 字典不支持下标索引，因此不能使用`while`循环遍历

```py
# 定义字典变量
dict1 = {"a": {"d": 1, "e": 2}, "b": 2, "c": 3}
keys = dict1.keys()
# keys实现了迭代器接口，可以通过 for...in遍历
for key in keys:
    print(dict1[key])
"""
{'d': 1, 'e': 2}
2
3
"""
```

#### 字典高级

* 字典底层实际上是用`hastTable`实现的

### :haircut: 容器的通用操作

* `len(容器)`

* `max(容器)`

  ```py
  # 定义字典变量
  dict1 = {"a": {"d": 1, "e": 2}, "b": 2, "c": 3}
  print(max(dict1))
  # 按照key比较大小
  # c
  
  str = "wbefc"
  print(max(str))
  # w
  ```

* `min(容器)`

* `list(容器)`：将给定容器转化为列表

  ```py
  print(list({1, 2, 3}))
  print(list("123"))
  print(list((1, 2, 3)))
  print(list({"a": 1, "b": 2}))
  """
  [1, 2, 3]
  ['1', '2', '3']
  [1, 2, 3]
  ['a', 'b'] 只包含keys
  """
  ```

* `str(容器)`：将给定容器转化为字符串

  ```py
  print(str({1, 2, 3}))
  print(str((1, 2, 3)))
  print(str([1, 2, 3]))
  print(str({"a": 1, "b": 2}))
  """
  {1, 2, 3}
  (1, 2, 3)
  [1, 2, 3]
  {'a': 1, 'b': 2}
  """
  ```

* `tuple(容器)`：将给定容器转化为元组

  ```py
  print(tuple({1, 2, 3}))
  print(tuple("123"))
  print(tuple([1, 2, 3]))
  print(tuple({"a": 1, "b": 2}))
  """
  (1, 2, 3)
  ('1', '2', '3')
  (1, 2, 3)
  ('a', 'b') 只包含key
  """
  ```

* `set(容器)`：将给定容器转换为集合

  ```py
  print(set("12341"))
  print(set((1, 2, 3)))
  print(set([1, 2, 3]))
  print(set({"a": 1, "b": 2}))
  """
  {'2', '1', '3', '4'}
  {1, 2, 3}
  {1, 2, 3}
  {'b', 'a'} 只包含key
  """
  ```

* `str、tuple、list、set`都无法通过`dict()`转化为字典，因为缺少键值对的结构

* `sorted(容器 , [reverse=True])`，无法指定排序规则

  > `sorted` 函数的返回值是 `list`

  ```py
  print(sorted([1, 4, 2, 8, 3, 5, 7]))
  print(sorted([1, 4, 2, 8, 3, 5, 7], reverse=True))
  """
  [1, 2, 3, 4, 5, 7, 8]
  [8, 7, 5, 4, 3, 2, 1]
  """
  
  print(sorted("fevyfibpfcjnbqwiv"))
  print(sorted("fevyfibpfcjnbqwiv", reverse=True))
  """
  ['b', 'b', 'c', 'e', 'f', 'f', 'f', 'i', 'i', 'j', 'n', 'p', 'q', 'v', 'v', 'w', 'y']
  ['y', 'w', 'v', 'v', 'q', 'p', 'n', 'j', 'i', 'i', 'f', 'f', 'f', 'e', 'c', 'b', 'b']
  """
  
  print(sorted((1, 34, 6, 2, 7, 8, 5)))
  print(sorted((1, 34, 6, 2, 7, 8, 5), reverse=True))
  """
  [1, 2, 5, 6, 7, 8, 34]
  [34, 8, 7, 6, 5, 2, 1]
  """
  ```

* `enumerate()`

  > `enumerate()` 函数用于将一个可遍历的数据对象(如列表、元组、字符串、集合、字典)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。
  >
  > 该函数返回一个可迭代对象，可以被`for in`迭代

  ```py
  v = enumerate({1, 2, 3})
  for item in v:
      print(item)
      # item是元组类型
  """
  (0, 1)
  (1, 2)
  (2, 3)
  """
  
  # 利用此方法快速遍历列表，同时获取 （index，item）
  for i, num in enumerate([1, 2, 3, 4]):
      print(i, num)
  """
  0 1
  1 2
  2 3
  3 4
  """
  ```

#### 内建函数

什么是内建函数？

> `python`解释器允许时，会自动地加载很多的变量、函数以及类等，这就是内建功能或者数据，我们把自动导入的函数称之为**内建函数**

* `dir(__builtins__)`

> `dir`函数会得到一个对象及其所属类的所有属性

使用该方法可以查看常用的内建函数

```py
print(dir(__builtins__))
"""
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BaseExceptionGroup', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EncodingWarning', 'EnvironmentError', 'Exception', 'ExceptionGroup', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'aiter', 'all', 'anext', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
"""
```

##### 常用内建函数

* `range(__start=1, __stop=3, __step=1)`

  > `python2`中，`range()`函数会得到一个列表
  >
  > `python3`中，`range()`函数会得到一个可迭代对象（但并不是迭代器）

* `res=map(func,container)`

  > `func`：映射方式函数
  >
  > `container`：被映射的可迭代数据容器，可以是列表元组等可迭代对象
  >
  > `res`：一个可迭代对象

  ```py
  # 一个容器映射到另外一个容器
  res = map(lambda x: x**2, [1, 2, 3])
  print(next(res))
  res=[*res]
  print(res)
  """
  1
  [4, 9]
  """
  
  # 两个容器映射到另外一个容器
  res = map(lambda x, y: x + y, [1, 2, 3], [4, 5, 6])
  print(next(res))
  
  res = [*res]
  print(res)
  """
  5
  [7, 9]
  """
  
  # 同样也能将三、四...个容器映射到另外一个容器
  ```

* `res=filter(func,container)`

  > `func`返回值是`False/0/None/空list()/空str()/空tuple()/空set()/空dict()`则除去，返回值是`True/1`则留下

  ```py
  res = filter(lambda x: x % 2, [1, 2, 3, 4])
  print([*res])
  print(list(res))
  """
  [1, 3]
  []
  """
  ```

  ```py
  if list() or dict() or tuple() or set() or str():
      print(True)
  else:
      print(False)
  # False
  
  if [1] and (1,) and {1} and {"a": 1} and "12":
      print(True)
  # True
  ```

* `res=reduce(func,container)`

  > 在`python2`中,`reduce`是内建函数。但是在`python3`中，就需要在`functools`模块中导入

  ```py
  from functools import reduce
  
  # 如果是第一次运行func，那么将container容器中的第一个数据赋予x，第二个数据赋予y，计算出x+y
  # 再将x+y作为第二次函数运行的参数x，container容器中的第三个数据赋予y
  # 以此类推
  res = reduce(lambda x, y: x + y, [1, 2, 3, 4, 5])
  print(res)
  # 15
  
  # 如果赋予第三个参数，那么第一次运行func时，就不需要从容器中取出两个数据作为参数x、y
  # 而是将第三个参数1作为x，将容器中的第一个数据作为y
  res = reduce(lambda x, y: x + y, [1, 2, 3, 4, 5], 1)
  print(res)
  # 16
  
  res = reduce(lambda x, y: x + y, ['aa','bb','cc'],'dd')
  print(res)
  # ddaabbcc
  ```

* `zip()`

  > 在Python中，`zip`函数用于将两个或多个可迭代对象（如列表、元组等）的元素打包成一个个元组，然后返回由这些元组组成的迭代器。如果各个可迭代对象的元素个数不一致，则返回结果长度与最短的对象相同，利用`*`号操作符，可以将元组解压为列表。
  >
  > 以下是`zip`函数的基本用法：

  ```py
  # 定义两个列表  
  list1 = [1, 2, 3]  
  list2 = ['a', 'b', 'c']  
    
  # 使用zip函数将两个列表组合  
  zipped = zip(list1, list2)  
    
  # 打印zip对象，它看起来像一个迭代器  
  print(zipped)  # 输出：<zip object at 0x7f02980684c0>  
    
  # 将zip对象转换为列表，以便查看其内容  
  zipped_list = list(zipped)  
  print(zipped_list)  # 输出：[(1, 'a'), (2, 'b'), (3, 'c')]  
    
  # 可以通过解包操作来访问zip中的元素  
  for num, char in zip(list1, list2):  
      print(num, char)  
    
  # 如果可迭代对象的长度不同，zip的长度将是最短的那个  
  list3 = [10, 20, 30, 40]  
  zipped_unequal = zip(list1, list3)  
  zipped_unequal_list = list(zipped_unequal)  
  print(zipped_unequal_list)  # 输出：[(1, 10), (2, 20), (3, 30)]  
    
  # 使用*操作符解压zip对象  
  nums, chars = zip(*zipped_list)  
  print(list(nums))  # 输出：[1, 2, 3]  
  print(list(chars))  # 输出：['a', 'b', 'c']
  ```

  `zip`函数还可以接受更多的可迭代对象作为参数，并将它们并行地组合在一起

  ```py
  list1 = [1, 2, 3]  
  list2 = ['a', 'b', 'c']  
  list3 = [10, 20, 30]  
    
  zipped_multi = zip(list1, list2, list3)  
  zipped_multi_list = list(zipped_multi)  
  print(zipped_multi_list)  # 输出：[(1, 'a', 10), (2, 'b', 20), (3, 'c', 30)]
  ```

  `zip`函数在处理不等长序列时非常有用，因为它允许你轻松地将<font color='red'>多个序列并行地处理，而无需担心它们的长度是否匹配</font>。



### :japanese_goblin: 推导式

**推导式基于迭代器**

> 推导式：就是一种可以快速生成数据的方式。类似于`JavaScript`中的展开运算符
>
> 例如，想要快速生成由`1-20`内所有奇数组成的列表，就可以使用如下推导式

```py
# 列表推导式
arr = [x for x in range(1, 21) if x % 2 == 0]
print(arr)
# [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

# <===>
arr = []
for i in range(1, 21):
    if i % 2 == 0:
        arr.append(i)
```

```py
# 集合推导式
set1= {x for x in range(1, 21) if x % 2 == 0}

# 字典推导式
dict1 = {x:1 for x in range(1, 21) if x % 2 == 0}
```

#### 列表推导式

* 格式：`[变量 for 变量 in 可迭代对象]`

* 实例：

  ```py
  arr = [x*2 for x in range(1, 21) if x % 2 == 0]
  # [4, 8, 12, 16, 20, 24, 28, 32, 36, 40]
  ```

  多层嵌套循环：

  ```py
  arr = [(x, y) for x in range(1, 3) for y in range(3)]
  # [(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
  
  # <==>
  
  arr = []
  for x in range(1, 3):
      for y in range(3):
          arr.append((x, y))
  print(arr)
  ```

* 案例：

  > `[1,2,3,...,100]`变成`[[1,2,3],[4,5,6],...]`

  ```py
  arr=[x for x in range(1,101)]
  print(arr)
  
  arr1=[arr[i:i+3:1] for i in range(0,len(arr),3)]
  print(arr1)
  
  """
  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
  [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24], [25, 26, 27], [28, 29, 30], [31, 32, 33], [34, 35, 36], [37, 38, 39], [40, 41, 42], [43, 44, 45], [46, 47, 48], [49, 50, 51], [52, 53, 54], [55, 56, 57], [58, 59, 60], [61, 62, 63], [64, 65, 66], [67, 68, 69], [70, 71, 72], [73, 74, 75], [76, 77, 78], [79, 80, 81], [82, 83, 84], [85, 86, 87], [88, 89, 90], [91, 92, 93], [94, 95, 96], [97, 98, 99], [100]]
  """
  ```

#### 集合推导式

* 格式：`{变量 for 变量 in 可迭代对象}`

* 实例：

  ```py
  set1 = {1 for x in range(1, 101)}
  print(set1)
  # {1}
  ```

  - 不能含有重复数据
  - 数据之间没有顺序关系，可能是乱序的

#### 字典推导式

* 实例

  ```py
  set1 = {x:1 for x in range(1, 11)}
  print(set1)
  # {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1}
  ```

* 案例

  ```py
  arr = [{x: x**2} for x in range(1, 11)]
  print(arr)
  # [{1: 1}, {2: 4}, {3: 9}, {4: 16}, {5: 25}, {6: 36}, {7: 49}, {8: 64}, {9: 81}, {10: 100}]
  ```

#### <font id='tuple'>元组推导式</font>

没有元组推导式，只有<a href='#generator'>生成器</a>



### :dart: 拆包（解包）

> 拆包：是一种快速提取数据的方式，类似于`JavaScript`中的解构赋值
>
> 例如：有一个元组`（11，22，33，44）`想快速地提取每个元素并且赋值给`num1,num2,num3,num4`这四个变量，代码如下

```py
num1, num2, num3, num4 = (11, 22, 33, 44)
```

* 拆包运算符，左边的变量个数一定要与右边的元素个数相同，<font color='red'>多了少了都不行</font>

* 列表的拆包：

  ```py
  a,b = [1, 2]
  print(a,b)
  # 1 2
  
  [a,b] = [1, 2]
  print(a,b)
  # 1 2
  
  # 以上两种拆包方式均正确
  ```

* 集合的拆包：

  ```py
  num1, num2, num3 = {11, 22, 33}
  print(num1,num2,num3)
  # 33 11 22
  ```

  <font color='red'>待拆的数据顺序和得到的变量顺序不一定对应</font>

* 字典的拆包：

  ```py
  num1, num2, num3 = {"a":1,"b":2,"c":3}
  print(num1,num2,num3)
  # a b c
  ```

  对字典拆包得到的是`keys`

* 交换两个变量的值:

  ```py
  a = 100
  b = 200
  
  # 等号右边的 a,b 相当于一个元组，回顾元组的定义方式
  # 等号的左边实际上是在进行拆包
  b, a = a, b
  print(a,b)
  # 200,100
  ```

  

# :name_badge: 文件系统

### 文件编码

> 将丰富的文本内容通过【编码】技术翻译为计算机可以识别的二进制`0、1`
>
> 编码技术即文本到二进制的翻译规则
>
> 常见的编码集：`UTF-8`（比较通用，包含多种语言）、`GBK`等，相当于一份字符串到二进制的密码本

如果编辑`python`文件时，利用`UTF-8`编码保存了`.py`文件中的中文到二进制，而在控制台执行输出时，控制台使用的是`GBK`编码将二进制解码成中文，编码和解码使用了不同的翻译系统，控制台就可能输出乱码

### 文件读取

* `f = open(path,mode,encoding)`

  > `path`：文件的路径，使用相对路径时，相对于终端的当前目录，而不是该`.py`文件所在的目录
  >
  > `mode`：
  >
  > | mode | 含义  |
  > | ---- | ----- |
  > | r    | 只读  |
  > | w    | 写入  |
  > | a    | 追加  |
  > | r+   | 读+写 |
  > | a+   | 读+写 |
  > | w+   | 读+写 |
  >
  > `encoding`：文件的编码方式
  >
  > `f`：返回的文件操作对象

  ```py
  f = open("./test.txt", mode="r", encoding="UTF-8")
  # <class '_io.TextIOWrapper'>
  
  # 位置参数："./test.txt"
  # 关键字参数：mode="r", encoding="UTF-8"
  # 之所以使用关键字参数，是因为 encoding 这个参数并不是第三位，直接使用 'key-value'的形式可以不按顺序传递实参
  ```

  ![image-20240107184958527](.assets\image-20240107184958527.png)

* `f.read(num)`

  > `num`：表示要读取文件数据的长度，单位是字节。若该参数为空，则默认读取文件所有数据

  ```py
  f = open("./test.txt", mode="r", encoding="UTF-8")
  
  print(f.read())
  """
  wefujbknldwefj
  cnscv
  bvcshjk
  kbjkl
  ckjbshvj
  """
  
  print(f.read(10))
  # wefujbknld
  # 一个字符占一个字节
  ```

* `f.readlines()`

  > 该方法按照行一次性读取文件的全部内容，并且返回一个以行为元素的列表

  ```py
  f = open("./test.txt", mode="r", encoding="UTF-8")
  
  print(f.readlines())
  """
  ['wefujbknldwefj\n', 'cnscv\n', 'bvcshjk\n', 'kbjkl\n', 'ckjbshvj']
  """
  ```

* `f.readline()`

  > 该方法读取文件的一行内容

  ```py
  f = open("./test.txt", mode="r", encoding="UTF-8")
  print(f.read(10))
  print(f.readline())
  """
  wefujbknld
  wefj
  """
  ```

  读取一行实际上就是读取到`\n`

* <font color='red'>`for line in f`</font>

  > 利用`for`循环读取文件内容

  ```py
  f = open("./test.txt", mode="r", encoding="UTF-8")
  for line in f:
      print(line, end="")
  # line的末尾本身就有一个'\n'
  
  """
  wefujbknldwefj
  cnscv
  bvcshjk
  kbjkl
  ckjbshvj
  """
  ```

<font color='red'>多次调用`read/readlines/readline`函数时，会接着上一次读取的结束的指针位置读取，该指针保存在`f`对象中</font>

* `f.close()`

  > 关闭文件：如果不关闭文件，`python`程序执行完毕之前会一直占用该文件

  ```py
  import time
  
  f = open("./test.txt", mode="r", encoding="UTF-8")
  time.sleep(500000)
  f.close()
  ```

* `with open() as f:`

  > 使用`with open()`语法，执行完毕内部的语句块之后会自动关闭文件，不需要手动`close`，避免遗忘关闭文件

  ```py
  with open("./test.txt", mode="r", encoding="UTF-8") as f:
      print(f.read())
  ```

  

### 文件写入

* `f=open(path,'w')`

  > `w`：写入模式
  >
  > 当文件不存在时，`w`模式会<font color='red'>创建文件</font>，`r`模式会报错

* `f.write('hello world')`

  > 将 `hello world`写入到`f`内存缓冲区
  >
  > `mode='w'`的情况下`write()`会直接<font color='red'>覆盖原文件内容</font>
  >
  > 同样，多次的`write`操作会<font color='red'>接着</font>上一次的写入指针写入

  ```py
  with open("./test.txt", mode="w", encoding="UTF-8") as f:
      f.write("hello world")
  ```

  ```py
  with open("./test.txt", mode="w", encoding="UTF-8") as f:
      f.write("hello world")
      f.write('\n123')
  """
  hello world
  123
  """
  ```

  

* `f.flush`

  > 将`f`内存缓冲区的内容立即写入磁盘
  >
  > `close()`函数是内置了`flush()`功能的，文件关闭时，会将内存写回磁盘

  ```py
  import time
  
  with open("./test.txt", mode="w", encoding="UTF-8") as f:
      f.write("hello world")
      time.sleep(500000)
      # 文件内容没有更新,内存没有写回磁盘
  ```

  ```py
  import time
  
  with open("./test.txt", mode="w", encoding="UTF-8") as f:
      f.write("hello world")
      f.flush()
      time.sleep(500000)
      # 内存已经写回磁盘
  ```

### 文件追加

* `f=open(path,'a')`

  > `mode='a'`，文件不存在时，会创建文件，文件存在时，写入内容时不会覆盖原文件，而是在文件末尾追加



# :kimono: Python异常

`python`以`r`模式读取一个并不存在的文件:

```
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\1. day1\quickSort.py", line 1, in <module>
    with open("./test.txt", mode="r", encoding="UTF-8") as f:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: './test.txt'
```

## 异常的捕获

### try except

```py
try:
    f = open("./test.md", "r", encoding="UTF-8")
except:
    print("找不到文件")
# 找不到文件
```

### 捕获指定类型的异常对象

```py
try:
    f = open("./test.md", "r", encoding="UTF-8")
except FileNotFoundError as e:
    print("找不到文件")

try:
    print(name)
except NameError as e:
    print("变量未定义")


try:
    1 / 0
except ZeroDivisionError as e:
    print("整数除0")

"""
找不到文件
变量未定义
整数除0
"""
```

* 如果捕获的指定异常类型和实际异常类型不同，依然会抛出异常

```py
try:
    f = open("./test.md", "r", encoding="UTF-8")
except NameError as e:
    print("找不到文件")

"""
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\test.py", line 2, in <module>
    f = open("./test.md", "r", encoding="UTF-8")
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: './test.md'
"""
```

* 异常别名

```py
try:
    f = open("./test.md", "r", encoding="UTF-8")
except FileNotFoundError as e:
    print(e, type(e))
    
# [Errno 2] No such file or directory: './test.md' <class 'FileNotFoundError'>
```

### 捕获多个异常对象

```py
try:
    f = open("./test.md", "r", encoding="UTF-8")
    1 / 0
except (FileNotFoundError, ZeroDivisionError) as e:
    print(e, type(e))
    
# 当代码中同时存在两处异常时，可以使用如上语法捕获多种类型的异常
# 但是实际上捕获的是第一次发生的异常
# 上述代码中，若打开文件出现异常，那么就捕获到FileNotFoundError异常，不会捕获到ZeroDivisionError异常
```

### 捕获全部异常对象

```py
# Exception是所有异常的父类

try:
    # f = open("./test.md", "r", encoding="UTF-8")
    1 / 0
except Exception as e:
    print(e, type(e))
# division by zero <class 'ZeroDivisionError'>
```

* `Exception`是所有异常的父类

### try except else finally

> 当未出现异常时，执行`else`代码块中的语句

```py
try:
    1 + 1
except Exception as e:
    print(e, type(e))
else:
    print("no Error")
```

> 无论是否出现异常，都执行`finally`中的代码块

```py
try:
    f = open("./test.md", "w", encoding="UTF-8")
except Exception as e:
    print(e, type(e))
else:
    print("no Error")
finally:
    print("finally")
    f.close()
"""
no Error
finally
"""
```



## 异常的传递

```py
def func01():
    print("This is func01 strat")
    num = 1 / 0
    print("This is funco1 end")


def func02():
    print("This is func02 start")
    func01()
    print("This is func02 end")


def main():
    func02()

main()

"""
This is func02 start
This is func01 strat
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\test.py", line 16, in <module>
    main()
  File "d:\WEB-front-end\python_study\study\test.py", line 14, in main
    func02()
  File "d:\WEB-front-end\python_study\study\test.py", line 9, in func02
    func01()
  File "d:\WEB-front-end\python_study\study\test.py", line 3, in func01
    num = 1 / 0
          ~~^~~
ZeroDivisionError: division by zero
"""
```

从以上报错可知，异常从`1/0`传递到`func01()`、再传递到`func02()`，最后传递到`main()`

在传递过程中的<font color='red'>每一个阶段</font>都可以捕获异常并且进行处理

```py
def func01():
    print("This is func01 strat")
    num = 1 / 0
    print("This is funco1 end")


def func02():
    print("This is func02 start")
    func01()
    print("This is func02 end")


def main():
    try:
        func02()
    except Exception as e:
        print(e)

main()

"""
This is func02 start
This is func01 strat
division by zero
"""
```

## raise抛出异常

<a href='#raise'>raise</a>

# :gem: Python模块

## 模块的导入

> 模块(`module`)，是一个`python`文件，以 `.py`结尾
>
> 模块内可以定义 函数、类、和可执行代码

* 导入语法

  ` [from moduleName] import [ module | class | function | variable | * ] [as 别名]` 

  ```py
  # 直接导入整个time模块
  import time
  
  time.sleep(30000)
  ```

  ```py
  # 仅仅从time模块中导入sleep方法
  from time import sleep
  
  sleep(30000)
  ```

  ```py
  # 导入time模块中的全部功能
  from time import *
  
  # 不需要time.sleep()
  sleep(3)
  ```

  ```py
  # time模块的别名是t
  import time as t
  t.sleep(2)
  
  # sleep函数的别名是 s
  from time import sleep as s
  s(3)
  ```

  

## 自定义模块

> `module1.py` 和`test.py`在<font color='red'>同一目录</font>下
>
> ![image-20240109135329278](.assets\image-20240109135329278.png)

* `module1.py`

  ```py
  def test(a, b):
      return a + b
  print(1)
  ```

* `test.py`

  ```py
  # 直接 from 模块文件名称 import 进行导入即可
  from module1 import test
  # 1
  # 在test.py中导入module1.py时，会执行module1.py中的代码
  
  print(test(1,2))
  ```

### \_\_name\_\_

```py
# 从两个模块中导入同名功能，后者会覆盖前者
from module1 import test # 不生效
from module2 import test # 生效
```

```py
# 在test.py中导入module1.py时，会执行module1.py中的代码，如何避免这种情况？

def test(a, b):
    return a + b

# 一个.py文件会有一个内置变量 __name__，该文件单独执行的时候，__name__就会被标记为__main__
if __name__ == "__main__":
    print("module1")
# 这样该文件被导入的时候 if 语句内的代码块不会被执行
# 只有当该文件单独运行时，才会进入 if代码块
```

### \_\_all\_\_

> 如果一个模块文件中有`__all__`变量，当使用`from X import *`导入时，只能导入这个列表中的元素

```py
def test(a, b):
    return a + b


def test1():
    return 1

# __all__是一个列表，而且列表中的元素必须是字符串，字符串就是函数名
__all__ = ['test1']

if __name__ == "__main__":
    print("module1")
```

```py
from module1 import *
test1()
```

![image-20240109170058673](.assets\image-20240109170058673.png)

此时若要使用`test`，则只能按照如下方式手动导入

```py
from module1 import test
test(1,2)
```



# :mailbox_closed: Python包

## 自定义Python包

> `Python`包，从物理上来看，包就是一个文件夹，在该文件夹下包含了一个`__init__.py`文件。该文件夹可用于包含多个模块文件。
>
> 从逻辑上来看，包的本质依然是模块。
>
> 当我们的模块文件越来越多时，包可以帮助我们管理这些模块，包的作用是包含多个模块。

* `python`包结构如下：

  ![image-20240109171330455](.assets\image-20240109171330455.png)

​		只要一个文件夹下含有`__init__.py`文件，那么该文件夹就是一个`python`包

* 使用`python`包：

  ![image-20240109171811856](.assets\image-20240109171811856.png)

  ```py
  # module_1.py
  def test1():
      print("module_1")
  ```

  ```py
  # module_2.py
  def test2():
      print("module_2")
  ```

  ```py
  # demo.py
  from module.module_1 import test1
  from module import module_1
  import module.module_2
  import module.module_2 as module_2
  
  
  test1()
  module_1.test1()
  module.module_2.test2()
  module_2.test2()
  
  """
  module_1
  module_1
  module_2
  module_2
  """
  ```

  ```py
  # __init__.py
  
  __all__ = ["module_1","module_2"]
  ```
  
  ```py
  # demo.py
  from module import *
  
  # 可以使用
  module_1.test1()
  # 无法使用
  module_2.test2()
  ```

### 私有模块变量

以单下划线开头的变量无法被导出

```py
# module_1.py
class Person(object):
    def __init__(self):
        self.name = "dk"


_b = 200
```

```py
# main.py
from module.module_1 import *

print(Person)
# <class 'module.module_1.Person'>
print(_b)
# NameError: name '_b' is not defined
```



## 安装第三方Python包

### pip

> 安装第三方包非常简单，我们只需要使用`Python`内置的`pip`程序即可

* 命令`pip install numpy`

![image-20240109173457888](.assets\image-20240109173457888.png)

* `pip uninstall <package_name>`卸载一个包
* `pip show tensorflow`：查看是否安装了某个包

### 镜像仓库

```cmd
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy
```

### 虚拟环境

若为项目安装了虚拟环境，则使用`pip install`安装时，把包安装在了虚拟环境中，相当于局部安装

* `pip list`：查看已经安装的`python`包

  ![image-20240109174152271](.assets\image-20240109174152271.png)

# :dancer: JSON

> `JSON`是一种在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互。

```json
{
    "name":"dk",
    "age":18
}

[
    {
    	"name":"admin",
    	"age":18
    },
    {
       	"name":"dk",
    	"age":18
    }
]
```

## JSON<—>列表 / 字典

```py
import json

data = [{"dk": 19}, {"lzz": 20}, {"cy": 30}]

# 将python列表/字典转化为 json 字符串
# 若字符串中含有中文，则配置 ensure_ascii=False
# 若为True，中文就会转化为unicode字符，若为False，中文可以正常显示
data1 = json.dumps(data, ensure_ascii=False)
print(data1)

# 将 json 字符串转化为 python 列表/字典
data2 = json.loads(data1)
print(data2)

"""
[{"dk": 19}, {"lzz": 20}, {"cy": 30}]
[{'dk': 19}, {'lzz': 20}, {'cy': 30}]
"""
```



# :last_quarter_moon: 类型系统

### 变量类型注解

> 和`typeScript`一样，类型注解只是一种注释，就算类型注释错误，也不会影响程序的最终执行

注解方式一：`变量：类型`

```py
# 对普通变量的注解
a: int = 10
b: str = "dk"
c: bool = True
d: float = 10.11

class Student:
    pass

# 对类对象的注解
stu: Student = Student()

# 对容器的注解
list1: list[int] = [1, 2]
tuple1: tuple[str, int, bool] = ("dk", 1, False)
set1: set[int] = {1, 2, 3}
dict1: dict[str, int] = {"a": 1}
```

注解方式2：`# type:类型`

```py
a = 10  # type:int
```

### 函数的类型注解

```py
def func(data: list) -> list:
    return data

value = func()
```

### Union类型

```py
# 先导包
from typing import Union

list1: list[Union[str, int]] = [1, 2, "3", "4"]
dict1: dict[str, Union[str, int]] = {"a": 1, "b": "2"}
```

### Optional类型

> `Optional` 通常用于类型注解，以表示一个值可以是某个类型或者`None`。在`Python`中，`Optional` 是从 `typing` 模块中导入的一个类型，用于表示一个值可以是某个类型或 `None`。`Optional` 是 `typing` 模块的一部分，该模块在Python 3.5及更高版本中可用。
>
> `Optional[ListNode]`: 这是一个类型注解，表示可以是`ListNode`类型或`None`。

```py
from typing import Optional
```





# :jack_o_lantern: Python高级编程

## :fallen_leaf: 引用

`python`中关于引用的使用和`JavaScript`中基本一致：

例子：函数参数引用的传递

```py
def xx(temp):
    print(temp)
    temp.append(44)
    print(temp)


nums = [100, 200]
xx(nums)
print(nums)

"""
[100, 200]
[100, 200, 44]
[100, 200, 44]
"""
```



## :sake: 闭包：自带数据的函数

<font color='red'>闭包 = 内层函数的**功能** + 外层函数的**数据**</font>

以下是一个简单的闭包演示：

```py
def outer(logo):
    def inner(msg):
        print(msg, logo)
        
    return inner

fn1 = outer("test1")
fn1("demo1")
fn1("demo2")

fn2 = outer("test2")
fn2("demo3")
fn2("demo4")
"""
demo1 test1
demo2 test1
demo3 test2
demo4 test2
"""
```

* 产生闭包的条件：<font color='#008c8c'>保存引用</font>
  - 函数嵌套
  - 必要条件：内部函数引用了外部函数的数据（<font color='red'>可以是外部函数的局部变量，也可以外部函数的形参</font>）
  - 执行**内部**函数<font color='red'>定义</font>就会产生闭包，<font color='red'>不一定要调用内部函数</font>。闭包中包含了那些被引用的数据
  - 若外部函数运行结束之后不保存内层函数的引用，闭包就会随着内部函数一起释放
  - 若外部函数运行结束之后保存了内层函数的引用，内层函数的闭包不会消失
  
* 闭包的缺点
  * 外层函数执行完之后，外层函数的被引用的局部变量没有释放，占用内存时间会变长
  * 每执行一次外部函数，就创建了一个新闭包，占用了大量的内层
  * 若执行多次外层函数，形成多个闭包，容易造成内存泄漏
  
* 闭包的释放
  
  * 闭包可以看作内层函数和它的一个小背包，这个小包存放了使用的外层函数的变量，这些变量在外层函数执行完毕之后**不会释放**
  
  * 只有当内层函数释放时，属于该内层函数的闭包也会被释放
  
    ```py
    # 释放内层函数的方法
    # 法1
    del inner
    
    # 法2
    inner = Non
    ```
  

### nonlocal

示例:

在以下代码中，内层函数的`logo = "change"`语句不会被视为对外层函数变量的修改，而是被看作在内层函数中新创建了一个变量

```py
def outer(logo):
    def inner(msg):
        logo = "change"
        print(msg, logo)

    return inner
```

若要在内层函数中修改外层函数的值，应该使用`nonlocal`关键字

```py
def outer(logo):
    def inner(msg):
        nonlocal logo
        logo = "change"
        print(msg, logo)

    return inner


fn1 = outer("test1")
fn1("demo1")
fn1("demo2")
"""
demo1 change
demo2 change
"""
```

### 多个内层函数 

> 一个外层函数返回多个内层函数，共享同一个闭包

```py
def outer(a, b):
    def inner1(x):
        nonlocal a, b
        tmp = a * x + b
        a, b = 2, 3
        return tmp

    def inner2(x):
        return 2 * a * x + 2 * b

    return inner1, inner2


inner1, inner2 = outer(1, 2)
print(inner1(5))
print(inner2(5))
```

### 闭包 vs 面向对象

闭包和对象都满足：<font color='#008c8c'>功能 + 数据 的模式</font>.

而普通函数和匿名函数都只有：<font color='#008c8c'>功能</font>

> 闭包的方式可以将外层函数接收到的局部变量保存下来
>
> 使用面向对象也可以将需要的数据保存下来
>
> 但是`python3`中的类一定会直接或者间接继承`object`类导致实例对象过于臃肿，但是使用闭包，只会保存需要的数据和内层函数，需要的代价更小。因此闭包可以视为轻量级的对象

* 面向对象

  ```py
  class Line5(object):
      def __init__(self, k, b):
          self.k = k
          self.b = b
  
      def __call__(self, x):
          print(self.k * x + self.b)
  ```

* 闭包

  ```py
  def line_6(k, b):
      def create_y(x):
          print(k * x + b)
  
      return create_y
  ```

### 闭包的应用

```py
def create():
    pos = [0, 0]

    def player(direction, step):
        nonlocal pos
        new_x = pos[0] + direction[0] * step
        new_y = pos[1] + direction[1] * step
        pos[0] = new_x
        pos[1] = new_y
        return pos

    return player


player = create()
print(player([1, 0], 10))
print(player([0, 1], 10))
print(player([-1, 0], 10))

"""
[10, 0]
[10, 10]
[0, 10]
"""
```



## :necktie: 迭代器

```py
class StuSystem(object):
    """
    学生管理系统
    """

    def __init__(self):
        self.stus = []

    def add(self):
        # 添加一个新的学生
        name = input("name：")
        tel = input("tel:")
        address = input("address:")

        new_stu = dict()
        new_stu["name"] = name
        new_stu["tel"] = tel
        new_stu["address"] = input(address)

        self.stus.append(new_stu)


# 创建管理系统对象
stu_sys = StuSystem()

# 添加三个学生信息到系统中
stu_sys.add()
stu_sys.add()
stu_sys.add()
```

> 问题1：怎么样才能实现用 `for` 循环遍历管理系统中所有的学生信息呢？
>
> 下面的方式可以实现吗？

```py
for stu in stu_sys:
    print(stu)
# TypeError: 'StuSystem' object is not iterable
# 显然无法使用 for 循环直接迭代遍历
```

<font color='red'>普通的对象是不可以用`for`循环进行遍历的，除非实现迭代器接口</font>。

### 可迭代对象

> 我们可以通俗地认为，只要是可以通过`for...in...`的方式进行遍历，那么这个数据类型就是可以迭代的。
>
> 例如，下面是可以迭代的数据类型：
>
> * 列表
> * 元组
> * 字典
> * 字符串
> * 集合
>
> 不可迭代的数据类型:
>
> * 整型
> * 浮点型

#### `Iterable`验证可迭代对象

* `isinstance(a,b)`：验证`a`是不是`b`类型，或者是`b`的继承类型，返回值 `True/False`

```py
from collections.abc import Iterable

# 判断 [] 是否是可迭代类型
print(isinstance([],Iterable)) # True
print(isinstance({}, Iterable)) # True
print(isinstance("abc", Iterable)) # True
print(isinstance(100, Iterable)) # False
```

#### 可迭代对象的本质

> 分析可迭代对象的迭代过程，发现每迭代一次（即在`for...in...`中每循环一次)都会返回对象中的下一条数据。一直向后读取数据直到迭代了所有数据之后结束。
>
> 那么这个过程中一个有一个“部件”去记录上一次访问到了第几条数据。该部件就叫做“迭代器”。
>
> 可迭代对象拥有这样一个**迭代器**，供我们遍历使用。



### 迭代器

> 迭代器是一个可以记住遍历位置的对象，迭代器对象从第一个元素开始访问，直到所有的元素被访问完毕结束。
>
> 迭代器只能往前，不能后退。
>
> <font color='red'>`for...in...`实际上就是利用迭代器的以下两个操作完成的</font>

#### iter()

* `iter(可迭代对象)`：获取可迭代对象的迭代器

```py
arr = [1, 2, 3, 4]

arr_iter = iter(arr)

print(arr_iter,type(arr_iter))
# <list_iterator object at 0x000001680E81A440> <class 'list_iterator'>
```

#### next()

* `next(迭代器)`：利用迭代器进行取值

```py
arr = [1, 2, 3, 4]

arr_iter = iter(arr)

print(next(arr_iter)) # 1
print(next(arr_iter)) # 2
print(next(arr_iter)) # 3
print(next(arr_iter)) # 4

# next()调用异常
print(next(arr_iter)) # Error:StopIteration
```

`for...in...`循环中对最后一次`next()`产生的异常进行了处理。

```py
try:
    print(next(arr_iter))
except StopIteration as ret:
    print("next()越界")
```

#### while & iteration

```py
arr = [11, 22, 33, 44]

arr_iter = iter(arr)

while True:
    try:
        num = next(arr_iter)
        print(num)
    except StopIteration as ret:
        print(ret)
        break
```

#### 推导式

利用可迭代对象和<a href='#tuple'>推导式</a>快速生成数据

### 自定义迭代器

> 为默认不可迭代对象自定义迭代器。

#### 魔术方法

##### `__iter__`

未重写`__iter__`方法

```py
from collections.abc import Iterable

class MyList(object):
    def __init__(self):
        self.container = []

print(isinstance(MyList(), Iterable))
# False
```

重写`__iter__`方法，<font color='red'>标记类创建的实例是可迭代对象</font>

```py
from collections.abc import Iterable

class MyList(object):
    def __init__(self):
        self.container = []
    
    def __iter__(self):
      pass

print(isinstance(MyList(), Iterable))
# True
```

> 当对`mylist`调用`iter()`函数的时候，实际上是调用了`MyList`类中的`__iter__`方法，返回的就是可迭代对象的迭代器。

##### `__next__`

#### **可迭代对象 vs 迭代器**：

* 可迭代对象：

> <font color='red'>如果一个类在定义时，有`__iter__`方法，那么该类创建出来的对象一定是**可迭代对象**，否则不是</font>

* 迭代器：

> 实现`__next__`：实际上在使用`next()`函数的时候，调用的是迭代器的`__next__`方法。所以我们想要构造一个迭代器，就要实现它的`__next__`方法。
>
> 实现`__iter__`：但是这还不够，`Python`要求迭代器本身也是可迭代的，所以我们还要为迭代器实现`__iter__`方法，而`__iter__`方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的`__iter__`方法返回自身即可。
>
> <font color='red'>一个实现了`__iter__`方法和`__next__`方法的对象，就是迭代器。</font>

**迭代器一定是可迭代对象，可迭代对象不一定是迭代器**

#### `Iterator`验证迭代器

```py
from collections.abc import Iterable, Iterator

# 创建可迭代对象
class MyList(object):
    def __init__(self):
        self.items = []
	
    # 为可迭代对象创建一个迭代器对象
    def __iter__(self):
        return MyIterator()

# 创建迭代器
class MyIterator(object):
    def __init__(self):
        pass

    def __iter__(self):
        pass

    def __next__(self):
        pass


mylist = MyList()

# iter(mylist)实际上调用了MyList类的__iter__方法，用于获取该可迭代对象的迭代器
mylist_iter = iter(mylist)

# 验证mylist是否是可迭代对象
print(isinstance(mylist, Iterable)) # True，实现了__iter__接口
# 验证mylist是否是迭代器
print(isinstance(mylist, Iterator)) # False，实现了__iter__，但未实现__next__

# 验证mylist_iter是否是可迭代对象
print(isinstance(mylist_iter, Iterable)) # True，实现了__iter__接口
# 验证mylist_iter是否是迭代器
print(isinstance(mylist_iter, Iterator)) # True，实现了__iter__接口，也实现了__next__接口
```

#### <font id='raise'>迭代器实例</font>

```py
class MyList(object):
    """自定义一个可迭代对象"""

    def __init__(self):
        self.items = []


    def __iter__(self):
        return MyIterator(self)

    def add(self, val):
        self.items.append(val)

class MyIterator(object):
    def __init__(self, mylist):
        self.mylist = mylist
        self.current = 0

    def __next__(self):
        if self.current < len(self.mylist.items):
            item = self.mylist.items[self.current]
            self.current += 1
            return item
        else:
            # 抛出异常，该异常是 for...in...的停止标记
            # 只有抛出了StopIteration异常，for...in...才知道迭代到了结尾
            raise StopIteration

    def __iter__(self):
        return self


if __name__ == "__main__":
    mylist = MyList()
    mylist.add(1)
    mylist.add(2)
    mylist.add(3)
    mylist.add(4)
    mylist.add(5)
    for num in mylist:
        print(num,end=" ")
# 1 2 3 4 5
```

#### 融合 可迭代对象 & 迭代器

> 定义一个类，其创建的可迭代对象，同时也是一个迭代器。每次对其迭代的时候不必创建一个额外的迭代器

```py
class MyList(object):
    """自定义一个可迭代对象"""

    def __init__(self):
        self.items = []
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current < len(self.items):
            item = self.items[self.current]
            self.current += 1
            return item
        else:
            raise StopIteration

    def add(self, val):
        self.items.append(val)
```

缺点：

> 使用这种方法时，无论是调用`iter(mylist)`还是进行`for...in...`循环，每次使用的迭代器都是`mylist`对象本身，是同一个.
>
> 如果不经过修改，则只能进行一次`for...in...`循环

```py
if __name__ == "__main__":
    mylist = MyList()
    mylist.add(1)
    mylist.add(2)
    mylist.add(3)
    mylist.add(4)
    mylist.add(5)
    for num in mylist:
        print(num, end=" ") # 1 2 3 4 5 
    for num in mylist:
        print(num, end=" ") # 
```

改进：

```py
class MyList(object):
    """自定义一个可迭代对象"""

    def __init__(self):
        self.items = []
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current < len(self.items):
            item = self.items[self.current]
            self.current += 1
            return item
        else:
            # 改进，每次迭代完毕的时候，修改遍历指针current为0
            self.current = 0
            raise StopIteration

    def add(self, val):
        self.items.append(val)
```

### 迭代器使用场景

* `for...in...`循环

* 元组转列表：`list()`函数接收可迭代对象，将该可迭代对象转化为`list`列表类型
* 列表转元组：`tuple()`函数接收可迭代对象

```py
if __name__ == "__main__":
    mylist = MyList()
    mylist.add(1)
    mylist.add(2)
    mylist.add(3)
    mylist.add(4)
    mylist.add(5)
    
    arr=list(mylist)
    print(arr)
    # [1,2,3,4,5]
```



## :new_moon_with_face: 生成器

### 引入

使用迭代器生成不确定个数的坐标：

```py
# 迭代器 & 可迭代对象 二合一
class PointXY(object):
    """
    通过迭代器，生成不确定个数的点的坐标
    """

    def __init__(self):
        self.x = 0
        self.k = 2
        self.b = 1

    def __iter__(self):
        return self
	
    # 记录了生成数据的方式，但是没有直接存储生成的数据
    def __next__(self):
        temp_y = self.k * self.x + self.b
        temp_point_x_y = (self.x, temp_y)  # 得到一个元组
        self.x = temp_y
        return temp_point_x_y
    
    def change_k_b(self, k, b):
        self.k = k
        self.b = b

# point_x_y既是可迭代对象，又是迭代器
point_x_y = PointXY()
point_x_y_iter = iter(point_x_y)
# 此例中得到的迭代器和可迭代对象实际上是同一个
print(point_x_y_iter == point_x_y) # True

print(next(point_x_y_iter))
print(next(point_x_y_iter))
print(next(point_x_y_iter))
print(next(point_x_y_iter))
print(next(point_x_y_iter))
point_x_y.change_k_b(3, 2)
print(next(point_x_y_iter))
print(next(point_x_y_iter))
print(next(point_x_y_iter))
print(next(point_x_y_iter))
"""
True
(0, 1)
(1, 3)
(3, 7)
(7, 15)
(15, 31)
(31, 95)
(95, 287)
(287, 863)
(863, 2591)
"""
```

若生成坐标的函数规则中途可能发生变化，上述代码比较复杂，如何解决？

使用生成器！

### generator

* 什么是生成器？(待生成的数据个数较多而且不确定)

  > 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且创建一个包含`100`万个元素的列表，不仅占用很大的存储空间。如果我们仅仅需要访问前面几个元素，那么后面绝大多数元素占用的空间都白白浪费了。
  >
  > 所以，如果列表元素可以按照某种算法推算出来，那么我们是否可以在需要的时候不断地推算出后续的元素呢？这样就不必创建完整的`list`,从而节省大量的存储空间。
  >
  > 通俗理解：在`Python`中，这样一边循环一边计算的机制，称为生成器：`generator`

* 生成器 & 迭代器

  > 其实利用迭代器，我们也可以在每次迭代获取数据（通过`next()`方法）时按照特定的规律进行生成。
  >
  > 但是在实现一个迭代器时，关于当前迭代到的状态需要我们自己记录，进而才能根据当前状态生成下一个数据。
  >
  > 为了达到记录当前状态，并且配合`next()`函数进行迭代使用，简而言之，迭代器是可以在循环的过程中生成数据的，但是稍微有些复杂。
  >
  > 有一个能具有迭代器的功能，而且比它更加简单的方式：生成器（`generator`)，<font color='red'>生成器是一类特殊的迭代器</font>，但是它与普通迭代器的定义方式不同

#### 生成器也是一个迭代器

```py
nums2 = (x for x in range(5000000000000))
for num in nums2:
    print(num, end=" ")
# 由于 nums2 可以被for...in...循环，因此生成器nums也是一个迭代器
```

由于 `nums2` 可以被`for...in...`循环，因此生成器`nums`也是一个迭代器，同样的`nums2`还可以使用`next()`进行迭代

```py
nums2 = (x for x in range(5))

num1 = next(nums2)
num2 = next(nums2)
num3 = next(nums2)
num4 = next(nums2)
num5 = next(nums2)
print(num1, num2, num3, num4, num5)
num6 = next(nums2)

"""
0 1 2 3 4
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\demo.py", line 9, in <module>
    num6 = next(nums2)
           ^^^^^^^^^^^
StopIteration
"""
```

也可以作为`list()`函数的参数

```py
nums2 = (x for x in range(5))
arr = list(nums2)
print(arr)
# [0, 1, 2, 3, 4]
```

#### 创建生成器

* <font id='generator'>创建方式一</font>：生成器推导式

  ```py
  nums = [x for x in range(5)]
  print(type(nums))
  print(nums)
  
  # 这不是元组推导式
  nums2 = (x for x in range(5))
  print(type(nums2))
  print(nums2)
  
  """
  <class 'list'>
  [0, 1, 2, 3, 4]
  <class 'generator'>
  <generator object <genexpr> at 0x000001A9B34B47C0>
  """
  ```

  乍一看上述方式是在使用元组推导式创建元组，可是在<a href='#tuple'>推导式</a>部分我们已经提到过，没有元组推导式.

  实际上，所谓元组推导式的语法，就是创建了一个生成器。

  那如何验证下面的方式是创建了一个生成器而不是创建了一个数组呢？观察以下代码，创建一个超大型的数组，然后将其打印

  ```py
  nums = [x for x in range(500000000000000)]
  for num in nums:
      print(num, end=" ")
  ```

  可是运行上述代码我们发现，控制台迟迟没有打印数组内容？为何会出现这种情况？

  实际上`python`解释器在疯狂创建这个容量巨大的数组，数组没有创建完毕之前，也就无法打印数据

  若我们使用生成器语法创建一个类似与数组的生成器

  ```py
  nums2 = (x for x in range(5000000000000))
  for num in nums2:
      print(num, end=" ")
  ```

  会发现控制台立马开始打印如下数据:

  ![image-20240116182945035](.assets\image-20240116182945035.png)

  这也进一步说明，生成器的数据是边生成边打印的。

  但是实际运行中，`python`解释器会实现判断，如果你需要创建的数据容器容量非常大，`python`解释器会直接释放这个容器，防止电脑崩溃。

* 创建方式二：使用迭代器实现生成器

  > `generator`功能非常强大，如果推算的算法比较复杂，用类似于元组推导式的的`for`循环无法实现的时候，还可以使用之前学习的函数来自己实现一个生成器。
  >
  > 下面以 斐波那契数列 来举例：
  >
  > 1，1，2，3，5，8，13....

  傻瓜做法如下，空间复杂度：O(1)

  ````py
  num1 = 1
  num2 = 2
  
  print(num1, end=" ") # 1
  # 交换两个变量的值
  num1, num2 = num2, num1 + num2  # (2,3)
  
  print(num1, end=" ") # 2
  num1, num2 = num2, num1 + num2  # (3,5)
  
  print(num1, end=" ") # 3
  num1, num2 = num2, num1 + num2  # (5,8)
  
  print(num1, end=" ") # 5
  num1, num2 = num2, num1 + num2  # (8,13)
  
  print(num1, end=" ") # 8
  ````

  使用迭代器解决：

  ```py
  import time
  
  class FibIterator(object):
      def __init__(self):
          self.num1 = 1
          self.num2 = 2
  
      def __next__(self):
          """使用next()函数来获取下一个数"""
          temp_num = self.num1
          self.num1, self.num2 = self.num2, self.num1 + self.num2
          return temp_num
  
      def __iter__(self):
          """迭代器的__iter__返回自身即可"""
          return self
  
  
  fib = FibIterator()
  fib_iter = iter(fib)
  print(next(fib_iter), end=" ")
  print(next(fib_iter), end=" ")
  print(next(fib_iter), end=" ")
  print(next(fib_iter), end=" ")
  print(next(fib_iter), end=" ")
  print(next(fib_iter), end=" ")
  # 1 2 3 5 8 13 
  
  for x in fib:
      time.sleep(1)
      print(x, end=" ")
  # for循环直接打印斐波那契数列
  ```

  看到上述代码，虽然可以用迭代器实现功能，但是稍微有些复杂，是否有更加简单的方式呢？

* 创建方式三：`yield`

  ```py
  def fib_generator():
      num1, num2 = 1, 1
      while True:
          temp_num = num1
          num1, num2 = num2, num1 + num2
          return temp_num
  
  
  print(fib_generator(), end=" ")
  print(fib_generator(), end=" ")
  print(fib_generator(), end=" ")
  print(fib_generator(), end=" ")
  # 1 1 1 1
  # 局部变量每次都被创建和释放，因此每次都打印1
  # 有很多方式可以解决，例如闭包和生成器
  ```

  使用生成器改进：

  ```py
  # fib_generator是一个生成器
  def fib_generator():
      num1, num2 = 1, 1
      while True:
          temp_num = num1
          num1, num2 = num2, num1 + num2
          # 将return修改为yield，返回一个生成器
          yield temp_num
  
  # fib是一个【生成器对象】
  fib = fib_generator()
  print(fib)
  # <generator object fib_generator at 0x000001AEB9E53850>
  
  # fib是一个生成器对象，又是一个迭代器，因此可以按照迭代器的next()方式去取数据
  num1 = next(fib)
  num2 = next(fib)
  num3 = next(fib)
  num4 = next(fib)
  num5 = next(fib)
  print(num1, num2, num3, num4, num5)
  # 1 1 2 3 5
  ```

  > 只要一个函数中有`yield`，那么本来看上去`fib_generator()`是调用函数，此时就变成了 创建一个【生成器对象】，这个对象当作`fib_generator()`的返回值。

#### yield 关键字

在以上创建生成器的方法三中，我们将方法二中原本在迭代器`__next__`方法里实现的基本逻辑放到一个函数中来实现，但是将每次迭代返回数值的`return`语句换成了`yield`语句，此时新定义的函数便不再是函数，而是一个生成器了

<font color='#008c8c'>简单来说，只要在`def`函数中有`yield`关键字的就称为生成器</font>

此时按照调用函数的方式`fib = fib_generator()`就不再是执行函数体了，而是会返回一个【生成器对象】，然后就可以按照使用迭代器的方式来使用生成器了。

##### 研究yield关键字的执行

```py
def fib_generator():
    print("---1---")
    num1, num2 = 1, 1
    while True:
        print("---2---")
        temp_num = num1
        print("---3---")
        num1, num2 = num2, num1 + num2
        print("---4---")
        yield temp_num
        print("---5---")

# 创建一个生成器对象
fib = fib_generator()
print(type(fib)) # <class 'generator'>

print("next1:start")
num = next(fib)
print("next1:end:", num)

print("next2:st`art")
num = next(fib)
print("next2:end:", num)

print("next3:start")
num = next(fib)
print("next3:end:", num)

"""
next1:start
---1---
---2---
---3---
---4---
next1:end: 1
next2:start
---5---
---2---
---3---
---4---
next2:end: 1
next3:start
---5---
---2---
---3---
---4---
next3:end: 2
"""
```

分析代码执行流程：

1. `fib_generator`函数中含有`yield`关键字，因此执行该函数会返回一个【生成器对象】`fib`
2. 第一次对`fib`这个生成器对象调用`next(fib)`函数，会从定义的代码块的起始处开始执行，一直执行到第一条`yield`语句，然后暂停执行，并且`yield`之后的表达式作为该`next(fib)`函数的返回值
3. 第二次对`fib`这个生成器对象调用`next(fib)`函数，会从第一次暂停的`yield`语句的下一条语句开始【继续】执行，直到执行下一条`yield`语句，并且将第二条`yield`语句之后的表达式作为第二个`next(fib)`函数的返回值
4. `......`

总结：

> 上面的代码，在函数中使用了`yield`关键字，替换了`return`，虽然看上去仅仅是关键字不同，但是功能效果已经截然不同了。
>
> 说明：
>
> 1. 只要有`yield`关键字，那么虽然看上去是调用函数，实际上已经变成了创建一个生成器对象
> 2. 通过`next()`调用生成器，可以让这个带有`yield`的`def`代码块开始执行，并且按照上述流程执行

#### return & 异常

怎样获取带有`yield`关键字的函数中的`return`的返回值？

```py
def fib_generator():
    num1, num2 = 1, 1
    temp_num = num1
    num1, num2 = num2, num1 + num2
    yield temp_num

    temp_num = num1
    num1, num2 = num2, num1 + num2
    yield temp_num

    temp_num = num1
    num1, num2 = num2, num1 + num2
    yield temp_num

    return "已经生成了3个斐波那契数列的值"

# 打断点
fib = fib_generator()
print(next(fib)) # 1
print(next(fib)) # 2
print(next(fib)) # 3
print(next(fib))
"""
StopIteration: 已经生成了3个斐波那契数列的值
"""
```

我们可以为程序打上断点，单步调试，查看生成器函数的执行方式，十分清晰明了

我们可以看到，函数的返回值作为了第四次调用`next()`函数的异常信息，表示生成器不会再生成新的数据。

总结：

> 1. 如果调用`next()`时，继续执行遇不到下一个`yield`，就会产生异常
> 2. 如果调用`next()`时，没有遇到`yield`而是遇到了`return`，那么也会产生带有`return`信息的异常
> 3. 若想要得到`return`语句的返回值，那么使用`try...except`即可

```py
def fib_generator():
    num1, num2 = 1, 1
    temp_num = num1
    num1, num2 = num2, num1 + num2
    yield temp_num

    temp_num = num1
    num1, num2 = num2, num1 + num2
    yield temp_num

    return "已经生成了3个斐波那契数列的值"

    temp_num = num1
    num1, num2 = num2, num1 + num2
    yield temp_num



fib = fib_generator()
print(next(fib))
print(next(fib))
print(next(fib))
"""
1
1
Traceback (most recent call last):
  File "d:\WEB-front-end\python_study\study\demo.py", line 22, in <module>
    print(next(fib))
          ^^^^^^^^^
StopIteration: 已经生成了3个斐波那契数列的值
"""
```

```py
try:
    print(next(fib))
except StopIteration as ret:
    print(ret.value)
    # 已经生成了3个斐波那契数列的值
```

#### send()

> 我们除了可以使用`next()`函数来唤醒，让生成器继续执行外，还可以使用`send()`函数来唤醒执行
>
> 使用`send()`函数的一个好处是：可以在唤醒的同时向断点处传入一个额外数据。

> **send() vs next()**
>
> 相同点：
>
> * 都会让生成器继续向下运行
> * 如果运行时遇不到`yield`，都会产生异常
>
> 不同点：
>
> * `next()`可以让生成器开始执行，也可以让生成器继续执行
> * `send()`只能让生成器继续运行，还可以将某个数据携带过去作为`yield`表达式的值。
> * `next()`作为函数执行，`send()`作为方法执行

```py
# 定义一个含有 yield 的生成器
def generator_test():
    while True:
        print("---1---")
        num = yield 100
        print("---2---", "num=", num)


# 创建生成器对象
g = generator_test()
print(next(g))
print(next(g))
print(next(g))

"""
---1---
100

---2--- num= None
---1---
100

---2--- num= None
---1---
100
"""
```

将以上代码中的`next()`修改为`send()`

> `yield`表达式的结果等于`g.send(value)`传递的参数`value`

```py
# 定义一个含有 yield 的生成器
def generator_test():
    while True:
        print("---1---")
        num = yield 100
        print("---2---", "num=", num)


# 创建生成器对象
g = generator_test()
# next是一个函数
print(next(g))
# send是一个生成器的方法
print(g.send(11))
print(g.send(22))

"""
---1---
100
---2--- num= 11
---1---
100
---2--- num= 22
---1---
100
"""
```

注意上述代码的写法，若想要调用`send(value)`，那么必须先调用`next()`让生成器开始执行，若一开始调用`send(value)`,`value`无法传递给`yield`表达式，就会报以下错误

```py
print(g.send(11))
print(g.send(22))
"""
TypeError: can't send non-None value to a just-started generator
"""
```

若就是想要一开始就用`send()`，那么参数必须为`None`，不能携带`value`,也不能为空

```py
print(g.send(None))
print(g.send(22))
"""
---1---
100
---2--- num= 22
---1---
100
"""
```

#### 创建多个生成器

同一个生成器创建的多个生成器对象之间的数据生成互不干扰

```py
def get_point():
    x, k, b = 0, 2, 1
    while True:
        y = k * x + b
        tmp = yield (x, y)
        if tmp:
            k, b = tmp
        x = y


# 1. 创建多个生成器
fib_1 = get_point()
fib_2 = get_point()

print(next(fib_1))
print(next(fib_2))
"""
(0, 1)
(0, 1)
"""
```



### generator实战

```py
def get_point():
    x, k, b = 0, 2, 1
    while True:
        y = k * x + b
        tmp = yield (x, y)
        if tmp:
            k, b = tmp
        x = y


# 1. 创建一个生成器
fib = get_point()
# 2. 调用next()获取 y=kx+b 坐标数据
print(fib.send(None))
print(next(fib))
print(next(fib))
print(fib.send((3, 2)))
print(next(fib))
```



## :gift: 装饰器

> 装饰器其实也是一种闭包，其功能就是在不破坏原有的代码和功能的前提下，为目标函数增加新功能。
>
> 代码的**开放封闭**原则，虽然这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但是可以被扩展，即：
>
> * 封闭：已实现的功能代码块
> * 开放：对扩展开发
>
> 装饰器允许我们在不修改原函数的基础上扩展原函数的功能！

```py
def sleep():
    import random
    import time

    print("Sleeping~")
    time.sleep(random.randint(1, 5))
```

现在希望给`sleep`函数增加一些功能：

* 在调用`sleep`前输出：我要睡觉了
* 在调用`sleep`之后输出：我起床了

### 装饰器的基础写法

> 利用`outer`将`sleep`装饰为一个新函数`fn`
>
> 因此`outer`函数参数是被装饰函数`sleep`，返回值是一个被装饰过的新函数`fn`
>
> `fn`对`sleep`进行了装饰

```py
def sleep():
    import random
    import time

    print("Sleeping~")
    time.sleep(random.randint(1, 5))

# 装饰器函数，实际上是一个闭包
def outer(func): # func是被装饰函数
    def inner(): # inner是被装饰过的函数
        print("I am going to sleep")
        # 内层函数使用到了外层函数的形参，该形参是一个函数
        func()
        print("I have waken up")

    return inner # 返回被装饰过后的函数

# 利用outer将sleep装饰为一个新函数fn
fn = outer(sleep)
fn()
```

### 装饰器的语法糖

```py
def outer(func):
    def inner():
        print("I am going to sleep")
        func()
        print("I have waken up")

    return inner

# 语法糖：@装饰器，sleep最终指向的是inner函数
@outer
def sleep():
    import random
    import time

    print("Sleeping~")
    time.sleep(random.randint(1, 5))
    
# 被装饰之后，sleep就不再指向原来的sleep而是指向被修饰过的内层函数inner
sleep()
```

被装饰之后，`sleep`就不再指向原来的`sleep`而是指向被修饰过的内层函数`inner`

#### @xxx

> `@xxx`装饰器必须放到`def`定义的函数之前，如果下面没有`def`定义的函数，那么会有语法错误
>
> 当`python`解释器遇到`@xxx`的时候会相当于调用`xxxx`函数并且把下面的函数名称当作实参

一个问题：为什么不直接使用`fn = outer(sleep)`去得到一个新函数，而是要使用`@`对`sleep`进行装饰呢？

`@`符号更清晰和准确地标识被装饰的函数，可读性更强

```py
def check(func):
    print("---1---")
    def inner():
        print("---3--")
        func()
        print("---4---")

    print("---2---")
    return inner

@check
def f1():
    print("f1")

f1()

"""
---1---
---2---
---3--
f1
---4---
"""
```

该实例说明，在调用`f1`之前，`check`对其的装饰早已经完毕了。实际上`python`解释器解析到`@check`的时候，装饰就会执行

### 深入装饰器

#### 对无参数的函数进行装饰

```py
from time import ctime, sleep

# 定义一个闭包
def timefun(func):
    def wrapped_func():
        print("%s called at %s" % (func.__name__, ctime()))

    return wrapped_func

@timefun
def foo():
    print("I am foo")

foo()
sleep(2)
foo()

"""
foo called at Wed Jan 17 21:40:20 2024
foo called at Wed Jan 17 21:40:22 2024
"""
```

#### 对有参数的函数进行装饰

> 对`foo`装饰完毕得到`wrapped_func`，装饰前后的两个函数被调用的方式应该相同，参数列表也要相同

```py
def timefun(func):
    def wrapped_func(a, b):
        print("---1---")
        print(a, b)
        func(a, b)
        print("---2---")

    return wrapped_func

@timefun
def foo(a, b):
    print("---3---")
    print(a + b)
    print("---4---")


# 此时foo指向wrapped_func，而不是原来的foo
foo(3, 5)
"""
---1---
3 5
---3---
8
---4---
---2---
"""
```

#### 同一个装饰器对多个不同的函数进行装饰

> 如下所示，被修饰的三个函数`a、b、c`参数列表各不相同，那么装饰器应该如何编写

```py
@xxx
def a(num):
    print("---1", num)

@xxx
def b(num1, num2):
    print("---2", num1, num2)

@xxx
def c(num1, num2, num3):
    print("---3", num1, num2, num3)

a(1)
b(1, 2)
c(1, 2, 3)
```

##### 展开运算符

> `*args`：位置传递的不定长
>
> `**kwargs`：关键字传递的不定长
>
> 展开运算符之后必须是一个可迭代对象
>
> 函数调用时，如果有位置参数时，<font color="#008c8c">位置参数必须在关键字参数的前面</font>，但关键字参数之间不存在先后顺序

```py
def xxx(func):
    def yyy(*args,**kwargs): # 用来接收不确定个数的参数
        # args是一个元组，*args相当于对元组进行了拆包，**kwargs相当于对字典进行了展开运算
        # 如果直接传递args就相当于传递了一个元组，因此*就相当于JavaScript里的展开运算符
        func(*args,**kwargs)

    return yyy
```

可以看出元组和列表等用一个`*`进行展开

> 字典用两个`*`进行展开

```py
a = [2, 3]
b= [1, *a, 4]
print(a,b)
# [2, 3] [1, 2, 3, 4]

a = {"a": 1}
b = {**a, "b": 2}
print(b)
# {'a': 1, 'b': 2}
```

#### 对含有返回值的函数进行装饰

##### 通用装饰器

```py
def xxx(func):
    def yyy(*args, **kwargs):
        print("---1")
        return func(*args, **kwargs)

    return yyy

@xxx
def a(num1, num2):
    print(num1 + num2)
    return num1 + num2


print("---res=", a(1, 2))
"""
---1
3
---res= 3
"""
```

至此，上述代码就得到了一个通用装饰器，可以对有参数、无参数、有返回值、无返回值的函数进行通用装饰

#### 多个装饰器装饰同一个函数

```py
def makeBold(fn):
    def wrapped():
        return "<b>" + fn() + "</b>"

    return wrapped


def makeItalic(fn):
    def wrapped():
        return "<i>" + fn() + "</i>"

    return wrapped


@makeBold
def test1():
    return "hello world-1"


@makeItalic
def test2():
    return "hello world-2"

# makeBold对被makeItalic装饰之后的test3再次进行装饰
# makeBold(makeItalic(test3))
# 下面的先装饰，下面装饰完毕之后上面再装饰
@makeBold # 相当于 test3=makeBold(test3)
@makeItalic # 相当于 test3=makeItalic(test3)
def test3():
    return "hello world-3"


print(test1())
print(test2())
print(test3())
"""
<b>hello world-1</b>
<i>hello world-2</i>
<b><i>hello world-3</i></b>
"""
```

#### 带有参数的装饰器——多层闭包

```py
import time

def call_out2(timeout=0):
    def call_out1(func):
        def call():
            print("---1---")
            time.sleep(timeout)
            ret = func()
            print("---2---")
            return ret

        return call

    return call_out1

# 下面的装饰过程 : @call_out2(2)
# 1. 执行call_out2(2)
# 2. 将1中得到的返回值进行调用，此时就变成了 call_out1
# 3. 此时会执行 call_out1(print_hello_1)
# 4. 将第三步得到的返回值赋值给 print_hello_1
@call_out2(2)
def print_hello_1():
    print("hello world")
    return "ok"


@call_out2(3)
def print_hello_2():
    print("hello world")
    return "ok"


print(print_hello_1())
print(print_hello_2())
```

以上代码实际上可以进行简化，将时间直接作为`print_hello_1`的原则。但是这么做有一些问题

* 违反了开放封闭原则
* 被装饰过后的函数和被装饰之前的函数调用方式应该一致，不应该修改参数列表
* 不能改变用户调用函数的方式

```py
import time


def call_out2(func):
    def call(timeout=0):
        print("---1---")
        time.sleep(timeout)
        ret = func()
        print("---2---")
        return ret

    return call


@call_out2
def print_hello_1():
    print("hello world")
    return "ok"

print(print_hello_1(1))
print(print_hello_1(5))
```

### 将类作为装饰器

```py
class Test(object):
    def __init__(self, func):
        print("---初始化---")
        print("func name is %s" % func.__name__)
        # 以两个下划线开头 __func 是一个私有属性
        self.__func = func

    def __call__(self):
        print("---装饰器中的功能---")
        self.__func()

@Test
def test():
    print("---test---")

test()

"""
---初始化---
func name is test
---装饰器中的功能---
---test---
"""
```

代码说明：

1. 当用`Test`来作为装饰器对`test`函数进行装饰的时候，相当于进行了如下操作：

   ```py
   test = Test(test)
   ```

2. `Test(test)`相当于把`test`这个函数作为参数传递到了`__init__`方法中，即在 `__init__`方法中的属性`__func`指向了`test`指向的函数

3. 之后`test`指向了`Test()`创建出来的<font color='red'>实例对象</font>，这个实例对象同时也是被装饰过后的函数。我们之前了解过，实例对象本身也可以当作一个函数进行调用，通过`__call__`这个魔术方法

4. 当在使用`test()`进行调用的时候，就相当于直接调用了实例对象，因此会调用这个对象的`__call__`方法

5. 为了能够在`__call__`方法`self.__func=func`这句代码，从而在调用`__call__`方法时能调用到`test`之前的函数体

#### 带参数的类装饰器

* 方式1：

```py
class Test(object):
    def __init__(self, num):
        print("---初始化---")
        print("num is %d" % num)
        self.__num = num

    def __call__(self, func):
        def wrapped_func():
            print("---装饰器---:", self.__num)
            return func()

        return wrapped_func

# 装饰器    
# test=Test(100)(test)
@Test(100)
def test():
    print("---test---")

test()

"""
study/demo.py
---初始化---
num is 100
---装饰器---: 100
---test---
"""
```

* 方式2：

```py
class Test(object):
    def __init__(self, num):
        print("---初始化---")
        print("num is %d" % num)
        self.__num = num

    def __call__(self, func):
        print("---正在进行装饰---")
        self.__func = func
        return self.call_old_func

    def call_old_func(self):
        print("---开始调用装饰器功能1---")
        self.__func()
        print("---开始调用装饰器功能2---")


@Test(100)
def test():
    print("---test---")


test()
"""
---初始化---
num is 100
---正在进行装饰---
---开始调用装饰器功能1---
---test---
---开始调用装饰器功能2---
"""
```



## :video_game: 拷贝

### is vs ==

> 很多时候，需要判断两个对象是否相同，此时我们往往能想到的是`==`，但是有时候这是不严谨的，容易产生问题
>
> 这也是我们需要学习`is`的原因

#### ==

> 之前我们在学习使用`if`的时候，经常会用到 `if a == b`，用`==`可以判断出对比的两个对象是否相同，但是<font color='red'>不能保证是同一个</font>
>
> 例如：
>
> 张三和你都有一个`iphone X`手机，那么此时用`==`就能判断是否相等，此时结果为`True`标识，你们两个人的手机大小、型号、外观等是相同的，但不是同一个

```py
a = {"demo": 1}
b = {"demo": 1}

print(a == b)	# True

a = [1, 2, 3]
b = [1, 2, 3]
print(a == b)	# True

print(a is b)	# False

print(c is b)	# True
```

#### is

> `python`一起皆对象，`is`能够判断两个对象是否是同一个，而不仅仅是数据相同.

##### id()

> 该函数可以查看一个对象的地址

```py
print(id(c), id(b))
# 1855922717824 1855922717824
```



### 深拷贝、浅拷贝

> 引入：函数的引用类型参数都是以引用的形式进行传递。
>
> 拷贝：就是复制。在`python`中分为**深拷贝**和**浅拷贝**两种方式

#### 深拷贝 (递归拷贝)

##### copy.deepcopy

```py
import copy

a = [11, 22]
b = [33, 44]
c = [a, b]

d = copy.deepcopy(c)
print(id(c) == id(d))
print(c == d)
print(c is d)

print(c[0] == d[0])
print(c[0] is d[0])

c[0][0] = 0
print(d)

"""
False
True
False
True
False
[[11, 22], [33, 44]]
"""
```

#### 浅拷贝 (顶层拷贝)

##### 引用复制

```py
a=[1,2,3] # a指向了一个列表
b=a # b也指向了a指向的那个列表
```

我们把这种通过赋值运算符来完成的这种赋值叫做 引用的复制。某些时候，我们也可以把这种引用的复制称为浅拷贝。但是从严格意义上来说，这并不是浅拷贝。

##### copy.copy

下面是一个真正的浅拷贝实例：

```py
import copy

a = [1, 2, 3]
b = copy.copy(a)

print(id(a), id(b))
print(a == b)
print(a is b)
"""
2651276497280 2651276499200
True
False
"""
```

```py
import copy

a = [11, 22]
b = [33, 44]
c = [a, b]

d = copy.copy(c)
print(id(c) == id(d))
print(c == d)
print(c is d)

print(c[0] == d[0])
print(c[0] is d[0])

c[0][0] = 0
print(d)

"""
False
True
False
True
True
[[0, 22], [33, 44]]
"""
```

###### 注意事项

> 使用`copy.copy(value)`进行浅拷贝时，当`value`是不可变类型和可变类型时，拷贝操作是不同的：
>
> 可变类型：`list`,`set`,`dict`
>
> 不可变类型：`tuple`,`string`
>
> 1. `copy.copy`：对于可变类型，会进行浅拷贝
> 2. `copy.copy`：对于不可变类型，不会拷贝，仅仅是指向
>
> 产生这两种区别的原因是，拷贝的目的是为了防止对原本的数据产生改动，但是不可变类型本身就不可改动，也就无所谓要不要拷贝的问题了，就是对不可变类型进行了真正的拷贝，也还是无法修改。

```py
import copy

a = [1, 2, 3]
b = copy.copy(a)

print(a == b, a is b) # True False

c = (1, 2, 3)
d = copy.copy(c)
print(c == d, c is d) # True True
```

##### 切片 

> 实际上，利用容器切片等容器的方法，可以间接得到容器的一个浅拷贝对象

```py
a = [11, 22]
b = [33, 44]
c = [a, b]
d = c[:]

print(c == d)
print(c is d)

print(c[0] == d[0])
print(c[0] is d[0])

"""
True
False
True
True
"""
```

##### dict().copy()

> 字典和列表等容器自带的`copy`方法也是浅拷贝

```py
d = dict(name="dk", age=18, arr=[1, 2, 3])

co = d.copy()
print(d, co)
print(d == co)
print(d is co)

print(d["arr"], co["arr"])
print(d["arr"] is co["arr"])

"""
{'name': 'dk', 'age': 18, 'arr': [1, 2, 3]} {'name': 'dk', 'age': 18, 'arr': [1, 2, 3]}
True
False
[1, 2, 3] [1, 2, 3]
True
"""
```

##### 展开运算符

```py
d = dict(name="dk", age=18, arr=[1, 2, 3])

co = {**d}
print(d, co)
print(d == co)
print(d is co)

print(d["arr"], co["arr"])
print(d["arr"] is co["arr"])
"""
{'name': 'dk', 'age': 18, 'arr': [1, 2, 3]} {'name': 'dk', 'age': 18, 'arr': [1, 2, 3]}
True
False
[1, 2, 3] [1, 2, 3]
True
"""
```

## :u6e80: 上下文管理器

> 如何你有看源码的习惯，可能会看到一些优秀的代码经常出现带有`with`关键字的语句，它通常使用在什么样的场景呢？
>
> 对比系统资源如文件、数据库连接、`socket`而言，应用程序打开这些资源并且执行完毕业务逻辑之后，必须做的一件事就是要关闭(断开)该资源。
>
> 比如`python`程序打开一个文件，在文件中写内容完成之后，就要关闭该文件，否则`python`程序就会一直占用该文件。甚至进程的打开文件表就会爆满。

#### with

一种优雅、简洁的方式来处理关闭文件等问题的方式就是使用`with`关键字，示例如下：

```py
def m3():
    with open("output.txt", "w") as f:
        f.write("python")
```

`open`方法的返回值赋值给变量`f`，当离开`with`代码块的时候，系统会自动调用`f.close()`方法，`with`的作用和使用`try/finally`语句是一样的。那么它实现的原理是什么？在讲`with`的原理前要设计另外一个概念，就是上下文管理器`Context Manager`

#### Context

什么是上下文(`context`)?

> 上下文即代码执行的环境，文章的语境...

##### Context Manager

任何实现了`__enter__`和`__exit__`两个魔术方法的对象都可以被称为上下文管理器，上下文管理器对象可以视为`with`关键字。

那么这样说来，文件对象`file`也实现了上下文管理器。

我们可以自己实现一个文件类，让该类实现`__enter__`和`__exit__`两个魔术方法

* `with`进入上下文自动调用`__enter__`方法
* 离开上下文自动调用`__exit__`方法

```py
class File(object):
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
	
    # with关键字调用__enter__
    def __enter__(self):
        print("entering")
        self.f = open(self.filename, self.mode)
        return self.f

    # 退出上下文调用__exit__
    def __exit__(self, *args):
        print("will exit")
        self.f.close()


with File("out.txt", "w") as f:
    print("writing")
    f.write("hello python")
    
"""
entering
writing
will exit
"""
```

```txt
out.txt
hello python
```

`with`代码块执行流程：

1. `FIle()`创建对象
2. 自动调用对象的`__enter__`方法
3. `__enter__`方法的返回值赋给`f`
4. 执行`with`代码块
5. `with`代码块执行完毕，自动调用`__exit__`方法

##### @contextmanager装饰器

```py
from contextlib import contextmanager

@contextmanager
def my_open(path, mode):
    f = open(path, mode)
    yield f
    f.close()


with my_open("out.txt", "w") as f:
    f.write("hello python")
```

上述代码的执行流程：（简洁版）

1. `with`关键字执行被装饰过的`my_open`函数，内部调用原来的`my_open`生成器函数得到一个生成器对象
2. 对该生成器对象调用`next()`，`yield`之后的表达式`f`作为返回值赋给`as f`中的`f`
3. 离开`with`代码块时，继续对生成器对象调用`next`函数

#### 总结

之所以用上下文管理器是因为在开发中一般都会用到系统资源（文件、网络、设备）等，我们在使用完这些资源之后一定要使用`close`关闭资源，但是出现异常时`close`函数很可能不会被调用，会导致系统资源浪费，因此我们需要使用更简单而且更有效的方式，即`with`来管理上下文。

上下文管理器简单来说分为以下两部分:

* 申请资源
* 释放资源

而在`with`中使用资源，`with`会自动调用申请资源以及释放资源的代码块，所以说这种方式更加简单便捷

## :basketball: 垃圾回收

### 小整数对象池

试想，如果`python`中的所有数据都是各自一份，那应该很恐怖，因为我们经常使用数字，例如循环时我们一般使用的`1-100`

```py
a = [1, 2]
b = [1, 2]
print(id(a))
print(id(b))
"""
1601568168192
1601568166272
"""

a = 1
b = 1
c = 1
print(id(a))
print(id(b))
print(id(c))
"""
140726567713208
140726567713208
140726567713208
"""
```

上面代码中，内容相同的数组不是同一份，但是内容相同的整数都是同一份，这是为什么呢？

`python`解释器为了让程序运行效率更快，因此将通常所用的数据例如`1，2，3`等常用的数字，在`python`解释器的开始阶段就已经创建好了，只等待被使用。这就是小整数对象池，这也就是为什么上面得到了三个相同的整数地址。

常用数字的范围是：`[-5,256]`

```py
a=-5
b=-5
print(id(a),id(b))
# 140726567713016 140726567713016

a=-6
b=-6
print(id(a),id(b))
# 1602973112624 1602973112624
```

在`ide`运行中发现两个`-6`的地址居然也是一样的，这是因为`ide`自身做了一些优化。

```cmd
Python 3.12.1 (tags/v3.12.1:2305ca5, Dec  7 2023, 22:03:25) [MSC v.1937 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> a=-6
>>> b=-6
>>> id(a)
2619413541424
>>> id(b)
2619413536944

>>> a=-5
>>> b=-5
>>> id(a)
140726763206904
>>> id(b)
140726763206904
```

直接在命令行中运行发现`-5`的`id()`相同，`-6`的`id()`不相同。符合规则。

### 大整数对象池

每一个大整数，构建一个新的对象。不是小整数的都属于大整数

```py
b = 12340
a = 12340
print(id(a), id(b))
"""
2178993201328 2178993201328
"""
```

尽管`12340`在`[-5,256]`之外，但是`ide`还是将其优化了

直接在命令行运行：

```cmd
>>> a=257
>>> b=257
>>> id(a)
2619416411664
>>> id(b)
2619416411568

>>> a=256
>>> b=256
>>> id(a)
140726763215256
>>> id(b)
140726763215256
```

可以看出大整数`257`并没有共享同一份地址

### `intern`机制（字符串驻留）

```py
a1 = "dk"
a2 = "dk"
a3 = "dk"

print(id(a1), id(a2), id(a3))
"""
2523882169248 2523882169248 2523882169248
"""
```

```cmd
>>> a='dk'
>>> b='dk'
>>> c='dk'
>>> id(a)
2619416291312
>>> id(b)
2619416291312
>>> id(c) 
2619416291312
```

可以看出，无论是在`ide`还是在命令行中，得到的字符串地址均相同。

由于`python`中`str`是不可变类型，不可修改，因此字符串没有必要存储多份，都指向同一份即可。

故`python`默认对普通字符串开启`intern`机制，即共用同一份地址空间。

但是如果字符串中包含空格等特殊字符，就不会开启

```py
a1 = "d k"
a2 = "d k"
a3 = "d k"

print(id(a1), id(a2), id(a3))
# 1599994438560 1599994438560 1599994438560
```

同样上述结果被`ide`优化了，直接在命令行运行如下

```py
>>> a='d k'
>>> b='d k'
>>> c='d k'
>>> id(a)
2833349320912
>>> id(b)
2833349322688
>>> id(c)
2833349322736
```

含有空格的相同字符串没有开启`intern`机制

### Garbage collection（GC垃圾回收）

现在的高级语言例如`java`，`c#`等，都采用了垃圾收集机制，而不再是`c`,`c++`里用户自己管理，维护内存的方式。自己管理内存极其自由，可以任意申请内存，但也可能为内存泄漏，悬空指针等`bug`埋下隐患。对于一个字符串、列表甚至数值都是对象，而且简单易用的语言`python`,自然不会让用户取处理如何分配和回收内存的问题。`python`和`java`类似一样采用了垃圾回收机制，不过不一样的是：`python`以引用计数机制为主，分代收集机制为辅的策略，尽量保证内存不会出现垃圾。

从表面上来看`python`更智能，但是`python`解释器有时候会留下一部分清理不了的内存，这就是我们研究`GC`的原因。

#### 引用计数机制

`python`中为了能够知道当前这个对象有多少个变量指向它，因此会在每个对象中有一个小小的空间，里面存放了引用计数

```py
a=XXX() # 引用计数1
b=a # 引用计数2
```

`python`里每一个对象都是对象，它们的核心就是一个结构体：`PyObject`

```c++
typedef struct_object {
    int ob_refcnt;
    struct_typeobject *ob_type;
} PyObject;
```

* 引用计数优点：

  1. 简单
  2. 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。将处理内存回收的时机分散开来。

* 缺点：

  1. 维护引用计数消耗资源

  2. <font color='red'>循环引用</font>

     ```py
     a.xx=b
     b.xx=a
     
     del a
     del b
     """
     a指向内存对象A
     b指向内存对象B
     内存对象A、B互指
     del a：删除a——>A的指向
     del b：删除b——>B的指向
     最终留下了：A和B的互指，都不会被垃圾回收
     """
     ```

     ![image-20240125180346852](.assets\image-20240125180346852.png)

##### 查看引用计数

```py
import sys
a = "hello world"
sys.getrefcount(a)
```

可以查看`a`对象的引用计数，但是比正常计数大`1`，因为调用函数的时候传入`a`，这会让`a`的引用计数`+1`

#### `python` vs `Ruby`

`GC`系统所承担的工作远比"垃圾回收"多得多。实际上，它们负责三个重要任务：

- 为新生成的对象分配内存
- 识别哪些是垃圾对象
- 回收垃圾对象占用的内存

下面是一个简单类，分别用`Python`和`Ruby`写成，我们今天就以此为例：

![img](.assets\311496-28c24ee4a234d0ae.png)

顺便提一句，两种语言的代码竟能如此相像：Ruby 和 Python 在表达同一事物上真的只是略有不同。但是在这两种语言的内部实现上是否也如此相似呢？

##### `Ruby`的对象分配

当我们执行上面的`Node.new(1)`时，`Ruby`到底做了什么？`Ruby`是如何为我们创建新的对象的呢？ 出乎意料的是它做的非常少。

实际上，早在代码开始执行前，`Ruby`就提前创建了成百上千个对象，并把它们串在链表上，名曰：可用列表。

下图所示为可用列表的概念图：

![img](.assets\311496-93f8229d900f9e29.png)

想象一下每个白色方格上都标着一个"未使用预创建对象"。

当我们调用 `Node.new` ,`Ruby`只需取一个预创建对象给我们使用即可：

![img](.assets\311496-e821eecc963df3b0.png)

上图中左侧灰格表示我们代码中使用的当前对象，同时其他白格是未使用对象。(请注意：无疑我的示意图是对实际的简化。实际上，`Ruby`会用另一个对象来装载字符串`"ABC"`,另一个对象装载`Node`类定义，还有一个对象装载了代码中分析出的抽象语法树，等等)

如果我们再次调用 `Node.new`，`Ruby`将递给我们另一个对象：

![img](.assets\311496-12e805bb08b38355.png)

这个简单的用链表来预分配对象的算法已经发明了超过50年，而发明人这是赫赫有名的计算机科学家`John McCarthy`，一开始是用`Lisp`实现的。`Lisp`不仅是最早的函数式编程语言，在计算机科学领域也有许多创举。其一就是利用垃圾回收机制自动化进行程序内存管理的概念。

标准版的`Ruby`，也就是众所周知的`"Matz's Ruby Interpreter"(MRI)`,所使用的`GC`算法与`McCarthy`在1960年的实现方式很类似。无论好坏，`Ruby`的垃圾回收机制已经53岁高龄了。像`Lisp`一样，`Ruby`预先创建一些对象，然后在你分配新对象或者变量的时候供你使用。

##### `Ruby`的垃圾回收（太懒，攒起来一次性回收）

`Ruby`把无用的对象留在内存里，直到下一次`GC`执行

回过来看`Ruby`。随着我们创建越来越多的对象，`Ruby`会持续搜可用列表里预创建对象给我们。因此，可用列表会逐渐变短:

![img](.assets\311496-07e8baeefdc53595.png)

然后更短：

![img](.assets\311496-ad17e6ae8ff5f5a6.png)

请注意我一直在为变量`n1`赋新值，`Ruby`把旧值留在原处。`"ABC"`,`"JKL"`和`"MNO"`三个`Node`实例还滞留在内存中。`Ruby`不会立即清除代码中不再使用的旧对象！`Ruby`开发者们就像是住在一间凌乱的房间，地板上摞着衣服，要么洗碗池里都是脏盘子。作为一个`Ruby`程序员，无用的垃圾对象会一直环绕着你。

##### `Ruby`标记清除

最终那间凌乱的房间充斥着垃圾，再不能岁月静好了。

在`Ruby`程序运行了一阵子以后，可用列表最终被用光光了:

![img](.assets\311496-d9d5dd3b7e830693.png)

此刻所有`Ruby`预创建对象都被程序用过了(它们都变灰了)，可用列表里空空如也（没有白格子了）。

此刻`Ruby`祭出另一`McCarthy`发明的算法，名曰：**标记-清除**。

首先`Ruby`把程序停下来，`Ruby`用"地球停转垃圾回收大法"。之后`Ruby`轮询所有指针，变量和代码产生别的引用对象和其他值。同时`Ruby`通过自身的虚拟机<font color='red'>遍历内部指针</font>。<font color='red'>标记出这些指针引用的每个对象</font>。我在图中使用`M`表示。

![img](.assets\311496-8f1071e6dcb73a02.png)

上图中那三个被标`M`的对象是程序还在使用的。在内部，`Ruby`实际上使用一串位值，被称为:**可用位图**，来跟踪对象是否被标记了。

![img](.assets\311496-708ee8d08f287618.png)

如果说被标记的对象是存活的，剩下的未被标记的对象只能是垃圾，这意味着我们的代码不再会使用它了。我会在下图中用白格子表示垃圾对象：

![img](.assets\311496-c301420b0db5512d.png)

接下来`Ruby`清除这些无用的垃圾对象，把它们送回到可用列表中：

![img](.assets\311496-cc369f14022237aa.png)

在内部这一切发生得迅雷不及掩耳，因为`Ruby`实际上不会吧对象从这拷贝到那。而是通过调整内部指针，将其指向一个新链表的方式，来将垃圾对象归位到可用列表中的。

现在等到下回再创建对象的时候`Ruby`又可以把这些垃圾对象分给我们使用了。在`Ruby`里，对象们六道轮回，转世投胎，享受多次人生。

##### `python`的对象分配

我们已经了解了`Ruby`预先创建对象并将它们存放在可用列表中。那`Python`又怎么样呢？

尽管由于许多原因`Python`也使用可用列表(用来回收一些特定对象比如 `list`)，但在为新对象和变量分配内存的方面`Python`和`Ruby`是不同的。

例如我们用`Pyhon`来创建一个`Node`对象：

![img](.assets\311496-988d8ea64a9536db.png)

与`Ruby`不同，当创建对象时`Python`立即向操作系统请求内存。(`Python`实际上实现了一套自己的内存分配系统，在操作系统堆之上提供了一个抽象层。但是我今天不展开说了。)

当我们创建第二个对象的时候，再次像`OS`请求内存：

![img](.assets\311496-86f30cfff557708f.png)

看起来够简单吧，在我们创建对象的时候，`Python`会花些时间为我们找到并分配内存。

##### `python`的垃圾回收（太勤快，有垃圾就回收）

用完的垃圾对象会立即被`Python`解释器打扫干净

`Python`与`Ruby`的垃圾回收机制颇为不同。让我们回到前面提到的三个`Python Node`对象：

![img](.assets\311496-ee6ec5dc7d0494b0.png)

在内部，创建一个对象时，`Python`总是在对象的`C`结构体里保存一个整数，称为 **引用数**。起初，`Python`将这个值设置为1：

![img](.assets\311496-dafd8b72ccb56513.png)

值为`1`说明分别有一个指针指向或是引用这个对象。

假如我们现在创建一个新的`Node`实例，`JKL`：

![img](.assets\311496-8269bfa7610aa83d.png)

与之前一样，`Python`设置`JKL`的引用数为`1`。然而，请注意由于我们改变了`n1`指向了`JKL`，不再指向`ABC`，`Python`就把`ABC`的引用数置为`0`了。 此刻，`Python`垃圾回收器立刻挺身而出！每当对象的引用数减为`0`，`Python`立即将其释放，把内存还给操作系统：

![img](.assets\311496-cce83cebee32f363.png)

上面`Python`回收了`“ABC” Node`实例使用的内存。记住，`Ruby`弃旧对象原地于不顾，也不释放它们的内存。

`Python`的这种垃圾回收算法被称为**引用计数**。

是`George-Collins`在`1960`年发明的，恰巧与`John McCarthy`发明的可用列表算法在同一年出现。就像`Mike-Bernstein`在`6`月份哥谭市`Ruby`大会杰出的垃圾回收机制演讲中说的: "`1960`年是垃圾收集器的黄金年代..."

`Python`开发者工作在卫生之家,你可以想象，有个患有轻度`OCD(`一种强迫症)的室友一刻不停地跟在你身后打扫，你一放下脏碟子或杯子，有个家伙已经准备好把它放进洗碗机了！

现在来看第二例子。加入我们让`n2`引用`n1`：

![img](.assets\311496-ce225ae9c6aefc87.png)

上图中左边的`DEF`的引用数已经被`Python`减少了，垃圾回收器会立即回收`DEF`实例。同时`JKL`的引用数已经变为了`2 `，因为`n1`和`n2`都指向它。

##### 标记-删除 vs 引用计数

乍一看，`Python`的`GC`算法貌似远胜于`Ruby`的：宁舍洁宇而居秽室乎？为什么`Ruby`宁愿定期强制程序停止运行，也不使用`Python`的算法呢？

然而，引用计数并不像第一眼看上去那样简单。

有许多原因使得许多语言不像`Python`这样使用引用计数`GC`算法：

首先，它不好实现。`Python`不得不在每个对象内部留一些空间来处理引用数。这样付出了一小点儿空间上的代价。但更糟糕的是，每个简单的操作（像修改变量或引用）都会变成一个更复杂的操作，因为`Python`需要增加一个计数，减少另一个，还可能释放对象。

第二点，它相对较慢。虽然`Python`随着程序执行`GC`很稳健（一把脏碟子放在洗碗盆里就开始洗啦），但这并不一定更快。`Python`不停地更新着众多引用数值。特别是当你不再使用一个大数据结构的时候，比如一个包含很多元素的列表，Python可能必须一次性释放大量对象。减少引用数就成了一项复杂的递归过程了。

最后，它不是总奏效的。引用计数不能处理环形数据结构—也就是含有<font color='red'>循环引用</font>的数据结构。

###### 循环引用

通过上面的学习，我们知道在`Python`中，每个对象都保存了一个称为**引用计数**的整数值，来追踪到底有多少引用指向了这个对象。

无论何时，如果我们程序中的一个变量或其他对象引用了目标对象，`Python`将会增加这个计数值，而当程序停止使用这个对象，则`Python`会减少这个计数值。一旦计数值被减到零，`Python`将会释放这个对象以及回收相关内存空间。

从六十年代开始，计算机科学界就面临了一个严重的理论问题，那就是针对引用计数这种算法来说，如果一个数据结构引用了它自身，即如果这个数据结构是一个循环数据结构，那么某些引用计数值是肯定无法变成零的。

为了更好地理解这个问题，让我们举个例子。

下面的代码展示了一些上面我们所用到的节点类：

![img](.assets\311496-f3b8a99b7a4aac48.jpg)

我们有一个"构造器"(在Python中叫做`__init__`)，在一个实例变量中存储一个单独的属性。在类定义之后我们创建两个节点，`"ABC"`以及`"DEF"`，在图中为左边的矩形框。两个节点的引用计数都被初始化为1，因为各有两个引用指向各个节点(`n1`和`n2`)。

现在，让我们在节点中定义两个附加的属性，`next`以及`prev`：

![img](.assets\311496-2646466e5aa4711d.jpg)

跟`Ruby`不同的是，`Python`中你可以在代码运行的时候动态定义实例变量或对象属性。这看起来似乎有点像`Ruby`缺失了某些有趣的魔法。

我们设置 `n1.next` 指向 `n2`，同时设置 `n2.prev` 指回 `n1`。

现在，我们的两个节点使用循环引用的方式构成了一个双向链表。同时请注意到 `ABC` 以及 `DEF`的引用计数值已经增加到了`2`。

这里有两个指针指向了每个节点：首先是 `n1` 以及 `n2`，其次就是 `next `以及 `prev`。

现在，假定我们的程序不再使用这两个节点了，我们将 `n1` 和 `n2 `都设置为`None`。

![img](.assets\311496-28ee4d77afde09b0.jpg)

好了，`Python`会像往常一样将每个节点的引用计数减少到`1`。

#### 隔代收集解决循环引用

`python`中的引用计数能够完成大部分的清理工作。但它对**循环引用**码用解决方案，此时就诞生了**隔代收集**。

正如`Ruby`使用一个链表(`free list`)来持续追踪未使用的、自由的对象一样，`Python`使用另一种不同的链表来持续追踪活跃的对象。而不将其称之为“活跃列表”，`Python`的内部`C`语言代码将其称为零代(`Generation Zero`)。

每次当你创建一个对象的时候，`Python`会将其加入零代链表：

![img](.assets\311496-7c9e91a54318d569.jpg)

从上边可以看到当我们创建`ABC`节点的时候，`Python`将其加入零代链表。请注意到这并不是一个真正的列表，并不能直接在你的代码中访问，事实上这个链表是一个完全内部的`Python`运行时。 相似的，当我们创建`DEF`节点的时候，`Python`将其加入同样的链表：

![img](.assets\311496-22b239ca5974128f.jpg)

现在零代包含了两个节点对象。(他还将包含`Python`创建的每个其他值，与一些`Python`自己使用的内部值。)

##### 检测循环引用

随后，`Python`会循环遍历零代列表上的每个对象，找出列表中每个互相引用的对象，根据规则减掉其引用计数。在这个过程中，`Python`会一个接一个的统计内部引用的数量以防过早地释放对象。

为了便于理解，来看一个例子：

![img](.assets\311496-05e563a1ddcd9cd1.jpg)

说明:

> 蓝颜色箭头表示一个变量指向了这个对象，即引用计数为`1`，如果有`2`个箭头那么引用计数为`2`，
> 如果没有箭头 但是还有引用计数，那么意味着它有循环引用

接下来你会看到`Python`的`GC`是如何处理零代链表的。

![img](.assets\311496-4da43891c8aaef04.jpg)

通过识别内部引用，`Python`能够减少许多零代链表对象的引用计数。在上图的第一行中你能够看见`ABC`和`DEF`的引用计数已经变为零了，这意味着收集器可以释放它们并回收内存空间了。剩下的活跃的对象则被移动到一个新的链表：一代链表。

从某种意义上说，`Python`的`GC`算法类似于`Ruby`所用的标记回收算法。周期性地从一个对象到另一个对象追踪引用以确定对象是否还是活跃的，正在被程序所使用的，这正类似于`Ruby`的标记过程。

##### 三代链表

在`Python`中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，该对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。

###### `gc.get_count()`

`gc`模块里面会有一个长度为`3`的列表的计数器，可以通过`gc.get_count()`获取。

例如`(488,3,0)`，其中`488`是指距离上一次一代垃圾检查，`Python`分配内存的数目减去释放内存的数目，注意是内存分配，而不是引用计数的增加。例如：

```python
print(gc.get_count()) # (590, 8, 0)
a = ClassA()
print(gc.get_count()) # (591, 8, 0)
del a
print(gc.get_count()) # (590, 8, 0)复制Error复制成功...
```

`3`是指距离上一次二代垃圾检查，已经进行了的一代垃圾检查的次数，同理，`0`是指距离上一次三代垃圾检查，二代垃圾检查的次数。

###### Python中的GC阈值

随着你的程序运行，`Python`解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。

当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则`Python`的零代垃圾收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。

随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而`Python`对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，`Python`会将剩下的活跃对象移动到二代列表。

通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，`Python`可以在不同的时间间隔处理这些对象。`Python`处理零代最为频繁，其次是一代然后才是二代。

###### `gc.get_threshold`

`gc`模快有一个自动垃圾回收的`阈值`，即通过`gc.get_threshold`函数获取到的长度为`3`的元组，该元组就是阈值。例如`(700,10,10) `每一次计数器的增加，`gc`模块就会检查增加后的计数是否达到阈值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器

例如，假设阀值是`(700,10,10)`：

```python
当计数器从(699,3,0)增加到(700,3,0)，gc模块就会执行gc.collect(0),即检查一代对象的垃圾，并重置计数器为(0,4,0)
当计数器从(699,9,0)增加到(700,9,0)，gc模块就会执行gc.collect(1),即检查一、二代对象的垃圾，并重置计数器为(0,0,1)
当计数器从(699,9,9)增加到(700,9,9)，gc模块就会执行gc.collect(2),即检查一、二、三代对象的垃圾，并重置计数器为(0,0,0)
```

<font color='red'>简而言之就是清理第一代的次数达到一定阈值之后才会清理第二代，第二代清理的次数达到一定阈值之后才会清理第三代</font>

##### 触发隔代回收

> 注意：这里的垃圾回收指的是无法被引用计数解决的`循环引用`垃圾

* 当`gc`模块的计数器达到阈值的时候，自动回收垃圾
* 调用`gc.collect()`的时候，手动回收垃圾
* 程序退出的时候，`python`解释器来回收垃圾

#### 关闭垃圾回收——产生内存泄漏

```py
import gc

class ClassA():
    def __init__(self):
        print('object born,id:%s'%str(id(self)))

def f2():
    while True:
        c1 = ClassA()
        c2 = ClassA()
        c1.t = c2
        c2.t = c1
        del c1
        del c2

#python默认是开启垃圾回收的，可以通过下面代码来将其关闭
gc.disable()

f2()
```



## :next_track_button: `logging`日志

相比于`print`，`logging`打印的信息内容更丰富。而且不止能打印到控制台，还可以输出到文件

#### 日志级别

日志一共分成`5`个等级，从低到高分别是：

```
DEBUG —>INFO —> WARNING —> ERROR —> CRITICAL
```

说明:

- `DEBUG`：详细的调试信息,通常只出现在诊断问题上
- `INFO`：确认一切按预期运行
- `WARNING`：一个迹象表明,一些意想不到的事情发生了,或表明一些问题在不久的将来(例如。磁盘空间低”)。这个软件还能按预期工作。
- `ERROR`：更严重的问题,软件没能执行一些功能
- `CRITICAL`：一个严重的错误,这表明程序本身可能无法继续运行

这`5`个等级，也分别对应`5`种打日志的方法： `DEBUG` 、`INFO `、`WARNING `、`ERROR` 、`CRITICAL`。默认的是`WARNING`，当在`WARNING`或之上时才被跟踪。

#### 日志输出

有两种方式记录跟踪，一种输出控制台，另一种是记录到文件中，如日志文件。

##### 将日志输出到控制台

比如，`log1.py `如下：

```python
import logging  
  
logging.basicConfig(level=logging.WARNING,  
                    format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')  

# 开始使用log功能
logging.debug('这是 loggging debug message')  
logging.info('这是 loggging info message')  
logging.warning('这是 loggging a warning message')  
logging.error('这是 an loggging error message')  
logging.critical('这是 loggging critical message')  复制Error复制成功...
```

运行结果

```python
2017-11-06 23:07:35,725 - log1.py[line:9] - WARNING: 这是 loggging a warning message
2017-11-06 23:07:35,725 - log1.py[line:10] - ERROR: 这是 an loggging error message
2017-11-06 23:07:35,725 - log1.py[line:11] - CRITICAL: 这是 loggging critical message复制Error复制成功...
```

###### 说明

> 通过`logging.basicConfig`函数对日志的输出格式及方式做相关配置，上面代码设置日志的输出等级是`WARNING`级别，意思是`WARNING`级别以上的日志才会输出。另外还制定了日志输出的格式。
>
> 注意，只要用过一次`log`功能再次设置格式时将失效，实际开发中格式肯定不会经常变化，所以刚开始时需要设定好格式

##### 将日志输出到文件

我们还可以将日志输出到文件，只需要在`logging.basicConfig`函数中设置好输出文件的文件名和写文件的模式。

`log2.py` 如下：

```python
import logging  
  
logging.basicConfig(level=logging.WARNING,  
                    filename='./log.txt',  
                    filemode='w',  
                    format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s')  
# use logging  
logging.debug('这是 loggging debug message')
logging.info('这是 loggging info message')  
logging.warning('这是 loggging a warning message')  
logging.error('这是 an loggging error message')  
logging.critical('这是 loggging critical message')复制Error复制成功...
```

运行效果

```python
python@ubuntu: cat log.txt 
2017-11-06 23:10:44,549 - log2.py[line:10] - WARNING: 这是 loggging a warning message
2017-11-06 23:10:44,549 - log2.py[line:11] - ERROR: 这是 an loggging error message
2017-11-06 23:10:44,549 - log2.py[line:12] - CRITICAL: 这是 loggging critical message复制Error复制成功...
```

##### 既要把日志输出到控制台， 还要写入日志文件

这就需要一个叫作`Logger `的对象来帮忙，下面将对其进行详细介绍，现在这里先学习怎么实现把日志既要输出到控制台又要输出到文件的功能。

```python
import logging  
  
# 第一步，创建一个logger  
logger = logging.getLogger()  
logger.setLevel(logging.INFO)  # Log等级总开关  
  
# 第二步，创建一个handler，用于写入日志文件  
logfile = './log.txt'  
fh = logging.FileHandler(logfile, mode='a')  # open的打开模式这里可以进行参考
fh.setLevel(logging.DEBUG)  # 输出到file的log等级的开关  
  
# 第三步，再创建一个handler，用于输出到控制台  
ch = logging.StreamHandler()  
ch.setLevel(logging.WARNING)   # 输出到console的log等级的开关  
  
# 第四步，定义handler的输出格式  
formatter = logging.Formatter("%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s")  
fh.setFormatter(formatter)  
ch.setFormatter(formatter)  
  
# 第五步，将logger添加到handler里面  
logger.addHandler(fh)  
logger.addHandler(ch)  
  
# 日志  
logger.debug('这是 logger debug message')  
logger.info('这是 logger info message')  
logger.warning('这是 logger warning message')  
logger.error('这是 logger error message')  
logger.critical('这是 logger critical message')复制Error复制成功...
```

运行时终端的输出结果:

```python
2017-11-06 23:14:04,731 - log3.py[line:28] - WARNING: 这是 logger warning message
2017-11-06 23:14:04,731 - log3.py[line:29] - ERROR: 这是 logger error message
2017-11-06 23:14:04,731 - log3.py[line:30] - CRITICAL: 这是 logger critical message复制Error复制成功...
```

在`log.txt`中，有如下数据：

```python
2017-11-06 23:14:04,731 - log3.py[line:27] - INFO: 这是 logger info message
2017-11-06 23:14:04,731 - log3.py[line:28] - WARNING: 这是 logger warning message
2017-11-06 23:14:04,731 - log3.py[line:29] - ERROR: 这是 logger error message
2017-11-06 23:14:04,731 - log3.py[line:30] - CRITICAL: 这是 logger critical message复制Error复制成功...
```

#### 日志格式说明

`logging.basicConfig`函数中，可以指定日志的输出格式`format`，这个参数可以输出很多有用的信息，如下:

- `%(levelno)s`: 打印日志级别的数值
- `%(levelname)s:` 打印日志级别名称
- `%(pathname)s`: 打印当前执行程序的路径，其实就是sys.argv[0]
- `%(filename)s`: 打印当前执行程序名
- `%(funcName)s`: 打印日志的当前函数
- `%(lineno)d`: 打印日志的当前行号
- `%(asctime)s`: 打印日志的时间
- `%(thread)d`: 打印线程ID
- `%(threadName)s`: 打印线程名称
- `%(process)d`: 打印进程ID
- `%(message)s`: 打印日志信息

在工作中给的常用格式如下:

```python
format='%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s'复制Error复制成功...
```

这个格式可以输出日志的打印时间，是哪个模块输出的，输出的日志级别是什么，以及输入的日志内容。

# :call_me_hand: 设计模式

> 设计模式不是一种语法，而是一种编程的思想和习惯

### 单例模式

> 某些场景下，我们需要一个类无论获取多少次类对象，都仅仅提供同一个具体的实例，用以节省创建类对象的开销和内存开销
>
> 比如某些工具类，仅仅需要1个实例，即可在各处使用
>
> 这就是单例模式所要实现的效果
>
> 在`JavaScript`中，可以使用闭包构建单例模式

```py
# module.py
class Tool:
    pass

tool = Tool()
```

```py
# demo1.py
from module import tool
```

```py
# demo2.py
from module import tool
```

`demo1.py`和`demo2.py`中导入的都是同一个`tool`

### 工厂模式

> 使用工厂类的`get_person()`方法代替原生类去创建具体的类对象
>
> 优点：
>
> * 大批量创建对象的时候有统一的创建入口，便于代码维护
> * 当发生修改时，仅仅需要修改工厂的创建方法即可
> * 符合现实世界的模式
